[{"id": "apps/name-forge/webui/src/components/generator/index.js::GenerateTab", "name": "GenerateTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/generator/index.js", "sourceCode": "/**\n * Generate Tab - Full control over name generation\n *\n * Note: Conditions (entityKind, subtype, tags, prominence) are evaluated at the\n * strategy GROUP level within profiles, not at the profile level. The generator\n * filters which strategy groups apply based on the generation context.\n */\nfunction GenerateTab({ worldSchema, cultures, formState, onFormStateChange }) {\n  // Use lifted state if provided, otherwise use local state\n  const [localState, setLocalState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }], // Start with one empty row\n  });\n\n  // Use formState from parent if available\n  const state = formState || localState;\n  const setState = onFormStateChange || setLocalState;\n\n  // Destructure for convenience\n  const {\n    selectedCulture,\n    selectedProfile,\n    selectedKind,\n    selectedSubKind,\n    tags,\n    prominence,\n    count,\n    contextPairs,\n  } = state;\n\n  // Update helpers\n  const updateField = (field, value) => {\n    setState({ ...state, [field]: value });\n  };\n\n  // Results\n  const [generatedNames, setGeneratedNames] = useState([]);\n  const [debugInfo, setDebugInfo] = useState([]);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [generating, setGenerating] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Get available options from schema\n  const cultureIds = Object.keys(cultures || {});\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  // Get profiles for selected culture\n  const availableProfiles = useMemo(() => {\n    if (!selectedCulture) return [];\n    return cultures[selectedCulture]?.naming?.profiles || [];\n  }, [selectedCulture, cultures]);\n\n  // Auto-select first profile when culture changes\n  useMemo(() => {\n    if (availableProfiles.length > 0 && !selectedProfile) {\n      updateField(\"selectedProfile\", availableProfiles[0].id);\n    } else if (availableProfiles.length === 0 && selectedProfile) {\n      updateField(\"selectedProfile\", \"\");\n    }\n  }, [availableProfiles]);\n\n  // Get subkinds for selected entity kind\n  const subKinds = useMemo(() => {\n    if (!selectedKind || !worldSchema?.entityKinds) return [];\n    const entity = worldSchema.entityKinds.find((e) => e.kind === selectedKind);\n    return entity?.subtypes?.map((s) => s.id) || [];\n  }, [selectedKind, worldSchema]);\n\n  // Prominence levels\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  // Get the culture for generation\n  const getSelectedCulture = () => {\n    if (!selectedCulture) return null;\n    return cultures[selectedCulture] || null;\n  };\n\n  // Context pair handlers\n  const handleAddContextPair = () => {\n    updateField(\"contextPairs\", [...contextPairs, { key: \"\", value: \"\" }]);\n  };\n\n  const handleRemoveContextPair = (index) => {\n    const newPairs = contextPairs.filter((_, i) => i !== index);\n    // Always keep at least one row\n    updateField(\"contextPairs\", newPairs.length > 0 ? newPairs : [{ key: \"\", value: \"\" }]);\n  };\n\n  const handleUpdateContextPair = (index, field, value) => {\n    const updated = [...contextPairs];\n    updated[index] = { ...updated[index], [field]: value };\n    updateField(\"contextPairs\", updated);\n  };\n\n  const handleGenerate = async () => {\n    setError(null);\n    setGenerating(true);\n\n    try {\n      const culture = getSelectedCulture();\n\n      if (!culture) {\n        throw new Error(\"No culture selected.\");\n      }\n\n      if (!culture?.naming?.profiles || culture.naming.profiles.length === 0) {\n        throw new Error(\"No profile found. Create a profile in Workshop \u2192 Profiles.\");\n      }\n\n      // Parse tags for condition matching\n      const tagList = Array.isArray(tags) ? tags : [];\n\n      // Build context object from key-value pairs for grammar context:key slots\n      const userContext = {};\n      for (const pair of contextPairs) {\n        if (pair.key) {\n          userContext[pair.key] = pair.value;\n        }\n      }\n\n      // Add standard fields to context as well\n      if (selectedKind) userContext.entityKind = selectedKind;\n      if (selectedSubKind) userContext.subtype = selectedSubKind;\n      if (prominence) userContext.prominence = prominence;\n      if (tagList.length > 0) userContext.tags = tagList.join(\",\");\n\n      // Generate names - pass culture directly\n      const result = await generateTestNames({\n        culture,\n        profileId: selectedProfile || undefined,\n        count,\n        seed: `generate-${Date.now()}`,\n        context: userContext,\n        kind: selectedKind || undefined,\n        subtype: selectedSubKind || undefined,\n        prominence: prominence || undefined,\n        tags: tagList,\n      });\n\n      setGeneratedNames(result.names || []);\n      setDebugInfo(result.debugInfo || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setError(err.message);\n      setGeneratedNames([]);\n      setDebugInfo([]);\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  const handleCopy = () => {\n    navigator.clipboard.writeText(generatedNames.join(\"\\n\"));\n  };\n\n  const handleCopyJson = () => {\n    navigator.clipboard.writeText(JSON.stringify(generatedNames, null, 2));\n  };\n\n  // Check if we can generate\n  const canGenerate = selectedCulture;\n  const culture = canGenerate ? getSelectedCulture() : null;\n  const hasProfile = culture?.naming?.profiles?.length > 0;\n\n  return (\n    <div className=\"generate-container\">\n      <h2>Name Generator</h2>\n      <p className=\"text-muted intro\">\n        Generate names using configured profiles. Strategy groups with conditions will be filtered\n        based on entity type, subtype, tags, and prominence.\n      </p>\n\n      <div className=\"generate-layout\">\n        {/* Left: Controls */}\n        <div className=\"generate-controls\">\n          <div className=\"card mb-md\">\n            <h3 className=\"mt-0 mb-md\">Generation Settings</h3>\n\n            {/* Culture Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"culture\">Culture *</label>\n              <select id=\"culture\"\n                value={selectedCulture}\n                onChange={(e) => {\n                  setState({ ...state, selectedCulture: e.target.value, selectedProfile: \"\" });\n                }}\n              >\n                <option value=\"\">Select a culture...</option>\n                {cultureIds.map((id) => (\n                  <option key={id} value={id}>\n                    {cultures[id]?.name || id}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            {/* Profile Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"profile\">Profile</label>\n              <select id=\"profile\"\n                value={selectedProfile}\n                onChange={(e) => updateField(\"selectedProfile\", e.target.value)}\n                disabled={availableProfiles.length === 0}\n              >\n                {availableProfiles.length === 0 ? (\n                  <option value=\"\">No profiles available</option>\n                ) : (\n                  availableProfiles.map((p) => (\n                    <option key={p.id} value={p.id}>\n                      {p.id}\n                    </option>\n                  ))\n                )}\n              </select>\n            </div>\n\n            <div className=\"generate-section-divider\">\n              <div className=\"generate-section-header\">\n                Context (for conditional strategy groups)\n              </div>\n\n              {/* Entity Kind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"entity-kind\">Entity Kind</label>\n                <select id=\"entity-kind\"\n                  value={selectedKind}\n                  onChange={(e) => {\n                    setState({ ...state, selectedKind: e.target.value, selectedSubKind: \"\" });\n                  }}\n                >\n                  <option value=\"\">Any type</option>\n                  {entityKinds.map((kind) => (\n                    <option key={kind} value={kind}>\n                      {kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* SubKind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"subtype\">Subtype</label>\n                <select id=\"subtype\"\n                  value={selectedSubKind}\n                  onChange={(e) => updateField(\"selectedSubKind\", e.target.value)}\n                  disabled={subKinds.length === 0}\n                >\n                  <option value=\"\">Any subtype</option>\n                  {subKinds.map((sub) => (\n                    <option key={sub} value={sub}>\n                      {sub}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Tags */}\n              <div className=\"form-group\">\n                <label>Tags\n                <TagSelector\n                  value={tags || []}\n                  onChange={(vals) => updateField(\"tags\", vals)}\n                  tagRegistry={tagRegistry}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n\n              {/* Prominence */}\n              <div className=\"form-group\">\n                <label htmlFor=\"prominence\">Prominence</label>\n                <select id=\"prominence\"\n                  value={prominence}\n                  onChange={(e) => updateField(\"prominence\", e.target.value)}\n                >\n                  <option value=\"\">Any prominence</option>\n                  {prominenceLevels.map((level) => (\n                    <option key={level} value={level}>\n                      {level}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            {/* Context Key-Value Pairs */}\n            <div className=\"generate-section-divider\">\n              <div className=\"flex justify-between items-center mb-sm\">\n                <div className=\"generate-section-header mb-0\">\n                  Context Values\n                  <span className=\"hint\">(for context:key slots)</span>\n                </div>\n                <button type=\"button\" onClick={handleAddContextPair} className=\"add-row-btn\">\n// ... (truncated)", "parameters": [{"name": "{ worldSchema, cultures, formState, onFormStateChange }", "type": "{ worldSchema: any; cultures: any; formState: any; onFormStateChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "h2", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "TagSelector", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "NumberInput", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 6}, {"name": "useMemo", "count": 3}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/modals/index.js::ConditionsModal", "name": "ConditionsModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/modals/index.js", "sourceCode": "function ConditionsModal({ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }) {\n  const [localConditions, setLocalConditions] = useState(conditions || {});\n\n  useEffect(() => {\n    setLocalConditions(conditions || {});\n  }, [conditions, isOpen]);\n\n  const handleSave = () => {\n    // Clean up empty values\n    const cleaned = {};\n    if (localConditions.tags?.length > 0) cleaned.tags = localConditions.tags;\n    if (localConditions.requireAllTags) cleaned.requireAllTags = true;\n    if (localConditions.prominence?.length > 0) cleaned.prominence = localConditions.prominence;\n    if (localConditions.subtype?.length > 0) cleaned.subtype = localConditions.subtype;\n\n    onChange(Object.keys(cleaned).length > 0 ? cleaned : undefined);\n    onClose();\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <ModalShell onClose={onClose} title=\"Strategy Conditions\" className=\"conditions-modal\">\n      <p className=\"text-muted text-small mt-0\">\n        Define when this strategy should be used. Leave empty for unconditional use.\n      </p>\n\n      {/* Tags */}\n      <div className=\"form-group\">\n        <label>Entity Tags\n        <TagSelector\n          value={localConditions.tags || []}\n          onChange={(tags) =>\n            setLocalConditions({ ...localConditions, tags: tags.length > 0 ? tags : undefined })\n          }\n          tagRegistry={tagRegistry}\n          placeholder=\"Select tags...\"\n          matchAllEnabled={true}\n          matchAll={localConditions.requireAllTags || false}\n          onMatchAllChange={(val) =>\n            setLocalConditions({ ...localConditions, requireAllTags: val || undefined })\n          }\n          onAddToRegistry={onAddTag}\n        />\n        </label>\n        <small className=\"text-muted\">\n          Use tags from the shared registry; toggle match-all when needed.\n        </small>\n      </div>\n\n      {/* Prominence */}\n      <div className=\"form-group\">\n        <span>Prominence Levels</span>\n        <div className=\"flex flex-wrap gap-sm mt-xs\">\n          {PROMINENCE_LEVELS.map((level) => {\n            const isSelected = (localConditions.prominence || []).includes(level);\n            return (\n              <button\n                key={level}\n                type=\"button\"\n                onClick={() => {\n                  const current = localConditions.prominence || [];\n                  const updated = isSelected\n                    ? current.filter((l) => l !== level)\n                    : [...current, level];\n                  setLocalConditions({\n                    ...localConditions,\n                    prominence: updated.length > 0 ? updated : undefined,\n                  });\n                }}\n                className={`pill-button ${isSelected ? \"selected-gold\" : \"\"}`}\n              >\n                {level}\n              </button>\n            );\n          })}\n        </div>\n        <small className=\"text-muted mt-sm block\">\n          Only use this strategy for entities with selected prominence levels\n        </small>\n      </div>\n\n      {/* Subtype */}\n      <div className=\"form-group\">\n        <label htmlFor=\"entity-subtypes\">Entity Subtypes</label>\n        <input id=\"entity-subtypes\"\n          value={(localConditions.subtype || []).join(\", \")}\n          onChange={(e) => {\n            const subtypes = e.target.value\n              .split(\",\")\n              .map((t) => t.trim())\n              .filter((t) => t);\n            setLocalConditions({\n              ...localConditions,\n              subtype: subtypes.length > 0 ? subtypes : undefined,\n            });\n          }}\n          placeholder=\"e.g., merchant, artisan, warrior\"\n        />\n        <small className=\"text-muted\">Comma-separated list of subtypes to match</small>\n      </div>\n\n      {/* Summary */}\n      {(localConditions.tags?.length > 0 ||\n        localConditions.prominence?.length > 0 ||\n        localConditions.subtype?.length > 0) && (\n        <div className=\"conditions-preview\">\n          <strong className=\"text-gold\">Preview:</strong> This strategy will be used when entity has{\" \"}\n          {[\n            localConditions.tags?.length > 0 &&\n              `${localConditions.requireAllTags ? \"ALL\" : \"any\"} tags: ${localConditions.tags.join(\", \")}`,\n            localConditions.prominence?.length > 0 &&\n              `prominence: ${localConditions.prominence.join(\" or \")}`,\n            localConditions.subtype?.length > 0 &&\n              `subtype: ${localConditions.subtype.join(\" or \")}`,\n          ]\n            .filter(Boolean)\n            .join(\" AND \")}\n        </div>\n      )}\n\n      <div className=\"flex gap-md mt-lg justify-end\">\n        <button className=\"secondary\" onClick={onClose}>\n          Cancel\n        </button>\n        <button className=\"primary\" onClick={handleSave}>\n          Save Conditions\n        </button>\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }", "type": "{ isOpen: any; onClose: any; conditions: any; onChange: any; tagRegistry?: any[]; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "ModalShell", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "TagSelector", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::OptimizerWorkshop", "name": "OptimizerWorkshop", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "DomainSelector", "children": [], "isMap": false, "isConditional": false}, {"tag": "OptimizerSettings", "children": [], "isMap": false, "isConditional": false}, {"tag": "ResultsModal", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 11}, {"name": "useMemo", "count": 2}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::DomainSelector", "name": "DomainSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * DomainSelector - Left panel for selecting domains to optimize\n */\nexport default function DomainSelector({\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}) {\n  return (\n    <div className=\"optimizer-sidebar\">\n      <div className=\"optimizer-sidebar-header\">\n        <h3 className=\"mt-0 mb-sm text-small\">Select Domains</h3>\n        <div className=\"flex gap-sm\">\n          <button onClick={onSelectAll} className=\"secondary btn-xs\">\n            Select All\n          </button>\n          <button onClick={onDeselectAll} className=\"secondary btn-xs\">\n            Clear\n          </button>\n        </div>\n        <div className=\"mt-sm text-small text-muted\">\n          {selectedDomains.size} of {allDomains.length} selected\n        </div>\n      </div>\n\n      <div className=\"optimizer-sidebar-list\">\n        {Object.entries(domainsByCulture).map(([cultureId, { name, domains }]) => {\n          const isExpanded = expandedCultures.has(cultureId);\n          const allSelected = domains.every((d) => selectedDomains.has(d.id));\n          const someSelected = domains.some((d) => selectedDomains.has(d.id));\n\n          return (\n            <div key={cultureId} className=\"mb-sm\">\n              <div className=\"culture-row\">\n                <input\n                  type=\"checkbox\"\n                  checked={allSelected}\n                  ref={(el) => {\n                    if (el) el.indeterminate = someSelected && !allSelected;\n                  }}\n                  onChange={() => onToggleAllInCulture(cultureId)}\n                  onClick={(e) => e.stopPropagation()}\n                  className=\"accent-ice\"\n                />\n                <span onClick={() => onToggleCulture(cultureId)} className=\"culture-row-label\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  {isExpanded ? \"\u25bc\" : \"\u25b6\"} {name || cultureId}\n                  <span className=\"text-muted font-normal ml-sm\">({domains.length})</span>\n                </span>\n              </div>\n\n              {isExpanded && (\n                <div className=\"domain-list\">\n                  {domains.map((domain) => (\n                    <div\n                      key={domain.id}\n                      className={`domain-row ${selectedDomains.has(domain.id) ? \"selected\" : \"\"}`}\n                      onClick={() => onToggleDomain(domain.id)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedDomains.has(domain.id)}\n                        onChange={() => onToggleDomain(domain.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        className=\"accent-gold\"\n                      />\n                      <span>{domain.id}</span>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          );\n        })}\n\n        {allDomains.length === 0 && (\n          <div className=\"empty-message\">\n            No domains found. Create domains in the Workshop tab first.\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}", "type": "{ domainsByCulture: any; allDomains: any; selectedDomains: any; expandedCultures: any; onToggleDomain: any; onToggleCulture: any; onToggleAllInCulture: any; onSelectAll: any; onDeselectAll: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::DomainDiff", "name": "DomainDiff", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Domain Diff Component - Shows what changed in a collapsible format\n */\nexport default function DomainDiff({ initial, optimized }) {\n  const changes = useMemo(() => computeDomainDiff(initial, optimized), [initial, optimized]);\n\n  if (changes.length === 0) {\n    return <div className=\"text-muted italic p-sm\">No changes detected</div>;\n  }\n\n  return (\n    <div className=\"text-small\">\n      {changes.map((change, i) => (\n        <div key={i} className={`diff-row ${i % 2 === 0 ? \"alt\" : \"\"}`}>\n          <div className=\"diff-path\">{change.path}</div>\n\n          {change.type === \"scalar\" && (\n            <div className=\"flex align-center gap-sm\">\n              <span className=\"diff-old\">{String(change.oldValue)}</span>\n              <span className=\"text-muted\">\u2192</span>\n              <span className=\"diff-new\">{String(change.newValue)}</span>\n            </div>\n          )}\n\n          {change.type === \"set\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.removed.map((item, j) => (\n                <span key={`r${j}`} className=\"diff-tag removed\">\n                  -{item}\n                </span>\n              ))}\n              {change.added.map((item, j) => (\n                <span key={`a${j}`} className=\"diff-tag added\">\n                  +{item}\n                </span>\n              ))}\n            </div>\n          )}\n\n          {change.type === \"weights\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.changes.slice(0, 8).map((c, j) => (\n                <span key={j} className=\"diff-weight\">\n                  <strong className=\"text-gold\">{c.label}</strong>: {c.oldVal}\u2192{c.newVal}\n                </span>\n              ))}\n              {change.changes.length > 8 && (\n                <span className=\"text-muted text-small\">+{change.changes.length - 8} more</span>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ initial, optimized }", "type": "{ initial: any; optimized: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::OptimizerSettings", "name": "OptimizerSettings", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * OptimizerSettings - Right panel for algorithm settings and optimization controls\n */\nexport default function OptimizerSettings({\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}) {\n  const handleAlgorithmParamChange = (key, defaultValue) => (v) => {\n    onAlgorithmParamsChange((prev) => ({ ...prev, [key]: v ?? defaultValue }));\n  };\n\n  // Render algorithm parameter inputs\n  const renderAlgorithmParams = () => {\n    const config = ALGORITHMS[algorithm];\n    if (!config?.params || Object.keys(config.params).length === 0) {\n      return (\n        <p className=\"text-muted text-small italic\">No additional parameters for this algorithm.</p>\n      );\n    }\n\n    return (\n      <div className=\"optimizer-param-grid\">\n        {Object.entries(config.params).map(([key, param]) => (\n          <div key={key} className=\"flex flex-col gap-xs\">\n            <label className=\"text-small\">{param.label}\n            <NumberInput\n              value={algorithmParams[key] ?? param.default}\n              onChange={handleAlgorithmParamChange(key, param.default)}\n              min={param.min}\n              max={param.max}\n              step={param.step || 1}\n              className=\"optimizer-input\"\n            />\n            </label>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"optimizer-main\">\n      {/* Settings */}\n      <div className=\"optimizer-settings-area\">\n        <h2 className=\"mt-0 mb-md\">Optimizer Settings</h2>\n\n        {/* Algorithm Selection */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm</h3>\n          <div className=\"algorithm-grid\">\n            {Object.entries(ALGORITHMS).map(([key, config]) => (\n              <div\n                key={key}\n                onClick={() => onAlgorithmChange(key)}\n                className={`algorithm-card ${algorithm === key ? \"selected\" : \"\"}`}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className={`algorithm-name ${algorithm === key ? \"selected\" : \"\"}`}>\n                  {config.name}\n                </div>\n                <div className=\"algorithm-desc\">{config.description}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Algorithm-Specific Parameters */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm Parameters</h3>\n          {renderAlgorithmParams()}\n        </div>\n\n        {/* Validation Settings */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Validation Settings</h3>\n          <div className=\"optimizer-param-grid-small\">\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Size\n              <NumberInput\n                value={validationSettings.requiredNames}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, requiredNames: v ?? 500 }))\n                }\n                min={100}\n                max={5000}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Factor\n              <NumberInput\n                value={validationSettings.sampleFactor}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, sampleFactor: v ?? 10 }))\n                }\n                min={1}\n                max={50}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        {/* Fitness Weights */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Fitness Weights</h3>\n          <div className=\"fitness-grid\">\n            {[\n              { key: \"capacity\", label: \"Capacity\", title: \"Entropy / collision rate\" },\n              { key: \"diffuseness\", label: \"Diffuseness\", title: \"Intra-domain variation\" },\n              { key: \"separation\", label: \"Separation\", title: \"Inter-domain distinctiveness\" },\n              { key: \"pronounceability\", label: \"Pronounce\", title: \"Phonetic naturalness\" },\n              { key: \"length\", label: \"Length\", title: \"Target length adherence\" },\n              { key: \"style\", label: \"Style\", title: \"LLM style judge (optional)\" },\n            ].map(({ key, label, title }) => (\n              <div key={key} className=\"flex flex-col gap-xs\">\n                <label className=\"text-small\" title={title}>\n                  {label}\n                </label>\n                <NumberInput\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  value={fitnessWeights[key]}\n                  onChange={(v) => onFitnessWeightsChange((prev) => ({ ...prev, [key]: v ?? 0 }))}\n                  title={title}\n                  disabled={key === \"separation\" && allDomains.length <= 1}\n                  className={`optimizer-input ${key === \"separation\" && allDomains.length <= 1 ? \"disabled\" : \"\"}`}\n                />\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Run Button */}\n        <div className=\"flex gap-md align-center flex-wrap\">\n          <button\n            onClick={onOptimize}\n            disabled={optimizing || selectedDomains.size === 0}\n            className={`optimize-button ${optimizing || selectedDomains.size === 0 ? \"disabled\" : \"\"}`}\n          >\n            {optimizing ? \"Optimizing...\" : `Optimize ${selectedDomains.size} Domain(s)`}\n          </button>\n\n          {results.length > 0 && results.some((r) => r.success) && (\n            <button onClick={onSaveResults} className=\"secondary optimize-action-button\">\n              Save Results\n            </button>\n          )}\n\n          {optimizing && (\n            <span className=\"text-small text-muted\">\n              {progress.current}/{progress.total}: {progress.currentDomain}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Status Bar - Shows when there are results */}\n      {results.length > 0 && !optimizing && (\n        <div className=\"optimizer-status-bar\">\n          <div className=\"flex align-center gap-md\">\n            <span className=\"text-small\">\n              Last run:{\" \"}\n              <strong className=\"text-success\">{results.filter((r) => r.success).length}</strong>{\" \"}\n              succeeded,{\" \"}\n              <strong className={results.some((r) => !r.success) ? \"text-danger\" : \"\"}>\n                {results.filter((r) => !r.success).length}\n              </strong>{\" \"}\n              failed\n            </span>\n            {results.filter((r) => r.success).length > 0 && (\n              <span className=\"text-gold font-bold text-small\">\n                Avg improvement: +\n                {(\n                  (results\n                    .filter((r) => r.success)\n                    .reduce((sum, r) => sum + (r.improvement || 0), 0) /\n                    results.filter((r) => r.success).length) *\n                  100\n                ).toFixed(1)}\n                %\n              </span>\n            )}\n          </div>\n          <button onClick={onShowModal} className=\"secondary text-small\">\n            View Details\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}", "type": "{ algorithm: any; onAlgorithmChange: any; algorithmParams: any; onAlgorithmParamsChange: any; validationSettings: any; onValidationSettingsChange: any; fitnessWeights: any; onFitnessWeightsChange: any; selectedDomains: any; allDomains: any; optimizing: any; progress: any; results: any; onOptimize: any; onSaveResults: any; onShowModal: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "p", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::ResultsModal", "name": "ResultsModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * ResultsModal - Modal showing optimization progress and results\n */\nexport default function ResultsModal({\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}) {\n  const [expandedResults, setExpandedResults] = useState(new Set());\n  const toggleExpand = domainId => {\n    setExpandedResults(prev => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n  if (!show) return null;\n  return <div className=\"optimizer-modal-overlay\" onClick={e => {\n    if (e.target === e.currentTarget && !optimizing) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"optimizer-modal\">\n        {/* Modal Header */}\n        <div className=\"optimizer-modal-header\">\n          <h2 className=\"mt-0 mb-0\">\n            {optimizing ? \"Optimization in Progress...\" : \"Optimization Results\"}\n          </h2>\n          {!optimizing && <button onClick={onClose} className=\"modal-close-btn\">\n              \u00d7\n            </button>}\n        </div>\n\n        {/* Progress Bar (during optimization) */}\n        {optimizing && <div className=\"optimizer-progress-section\">\n            <div className=\"flex justify-between mb-sm\">\n              <span className=\"text-small\">\n                Processing: <strong>{progress.currentDomain}</strong>\n              </span>\n              <span className=\"text-small text-muted\">\n                {progress.current} / {progress.total}\n              </span>\n            </div>\n            <div className=\"progress-bar-track\">\n              <div className=\"progress-bar-fill rm-progress-bar-fill\" style={{\n            '--rm-progress-width': `${progress.total > 0 ? progress.current / progress.total * 100 : 0}%`\n          }} />\n            </div>\n          </div>}\n\n        {/* Modal Body - Log and Results */}\n        <div className=\"optimizer-modal-body\">\n          {/* Log Section */}\n          <div className=\"optimizer-log-section\">\n            <h3 className=\"section-title mt-0\">Optimization Log</h3>\n            <div className=\"optimizer-log\">\n              {logs.map((log, i) => <div key={i} className={`log-entry ${log.type}`}>\n                  {log.message}\n                </div>)}\n              {logs.length === 0 && <div className=\"text-muted italic\">Waiting for optimization to start...</div>}\n            </div>\n\n            {/* Results Table */}\n            {results.length > 0 && <div className=\"mt-lg\">\n                <h3 className=\"section-title mt-0\">Results Summary</h3>\n                <div className=\"results-table-container\">\n                  <table className=\"results-table\">\n                    <thead>\n                      <tr>\n                        <th className=\"col-expand\"></th>\n                        <th>Domain</th>\n                        <th className=\"text-right\">Initial</th>\n                        <th className=\"text-right\">Final</th>\n                        <th className=\"text-right\">Improvement</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {results.map((result, i) => <ResultRow key={result.domainId} result={result} index={i} isExpanded={expandedResults.has(result.domainId)} onToggle={toggleExpand} />)}\n                    </tbody>\n                  </table>\n                </div>\n              </div>}\n          </div>\n        </div>\n\n        {/* Modal Footer */}\n        <div className=\"optimizer-modal-footer\">\n          {results.length > 0 && results.some(r => r.success) && !optimizing && <button onClick={onSaveResults} className=\"optimize-button\">\n              Save Results\n            </button>}\n          <button onClick={onClose} disabled={optimizing} className={`secondary optimize-action-button ${optimizing ? \"disabled\" : \"\"}`}>\n            {optimizing ? \"Running...\" : \"Close\"}\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}", "type": "{ show: any; onClose: any; optimizing: any; progress: any; logs: any; results: any; onSaveResults: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h2", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "table", "children": [{"tag": "thead", "children": [{"tag": "tr", "children": [{"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "tbody", "children": [{"tag": "ResultRow", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ExpandableCard", "name": "ExpandableCard", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::IconButton", "name": "IconButton", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::FormGroup", "name": "FormGroup", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::FormRow", "name": "FormRow", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * FormRow - Horizontal layout for multiple form groups\n */\nexport function FormRow({ children, className = '' }) {\n  return (\n    <div className={`form-row ${className}`.trim()}>\n      {children}\n    </div>\n  );\n}", "parameters": [{"name": "{ children, className = '' }", "type": "{ children: any; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::TagSelector", "name": "TagSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export default function TagSelector({\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [highlightedIndex, setHighlightedIndex] = useState(0);\n  const [hoveredInvalidTag, setHoveredInvalidTag] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const tagLookup = useMemo(() => {\n    const lookup = {};\n    tagRegistry.forEach((tagDef) => {\n      lookup[tagDef.tag] = tagDef;\n    });\n    return lookup;\n  }, [tagRegistry]);\n\n  const groupedTags = useMemo(() => {\n    const groups = {};\n    const filtered = tagRegistry.filter((tagDef) => {\n      const normalizedQuery = searchQuery.toLowerCase();\n      const matchesSearch =\n        !searchQuery ||\n        tagDef.tag.toLowerCase().includes(normalizedQuery) ||\n        tagDef.description?.toLowerCase().includes(normalizedQuery);\n      return matchesSearch && !value.includes(tagDef.tag);\n    });\n\n    filtered.forEach((tagDef) => {\n      if (!groups[tagDef.category]) {\n        groups[tagDef.category] = [];\n      }\n      groups[tagDef.category].push(tagDef);\n    });\n\n    return groups;\n  }, [searchQuery, tagRegistry, value]);\n\n  const canCreateTag = useMemo(() => {\n    if (!searchQuery.trim()) return false;\n    const normalized = searchQuery.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');\n    if (!normalized) return false;\n    if (tagLookup[normalized]) return false;\n    if (value.includes(normalized)) return false;\n    return normalized;\n  }, [searchQuery, tagLookup, value]);\n\n  const flatOptions = useMemo(() => {\n    const result = [];\n    Object.entries(groupedTags).forEach(([_category, tags]) => {\n      tags.forEach((tagDef) => result.push({ type: 'existing', ...tagDef }));\n    });\n    if (canCreateTag) {\n      result.push({ type: 'create', tag: canCreateTag });\n    }\n    return result;\n  }, [groupedTags, canCreateTag]);\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (containerRef.current && !containerRef.current.contains(event.target)) {\n        setIsOpen(false);\n        setHoveredInvalidTag(null);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleKeyDown = (event) => {\n    if (!isOpen) {\n      if (event.key === 'Enter' || event.key === 'ArrowDown') {\n        event.preventDefault();\n        setIsOpen(true);\n      }\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.min(index + 1, flatOptions.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.max(index - 1, 0));\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (!flatOptions[highlightedIndex]) return;\n        if (flatOptions[highlightedIndex].type === 'create') {\n          handleCreateAndSelect(flatOptions[highlightedIndex].tag);\n        } else {\n          handleSelectTag(flatOptions[highlightedIndex].tag);\n        }\n        break;\n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        break;\n      case 'Backspace':\n        if (searchQuery === '' && value.length > 0) {\n          handleRemoveTag(value[value.length - 1]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleSelectTag = (tag) => {\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemoveTag = (tag) => {\n    onChange(value.filter((item) => item !== tag));\n  };\n\n  const handleCreateAndSelect = (tag) => {\n    if (onAddToRegistry) {\n      onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n    }\n\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleInvalidTagMouseEnter = (tag) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredInvalidTag(tag);\n  };\n\n  const handleInvalidTagMouseLeave = () => {\n    hoverTimeoutRef.current = setTimeout(() => {\n      setHoveredInvalidTag(null);\n    }, 150);\n  };\n\n  const handlePopupMouseEnter = () => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n  };\n\n  const renderRarityDots = (rarity) => {\n    const count = RARITY_DOTS[rarity] || RARITY_DOTS.common;\n    return (\n      <span className=\"tag-selector-rarity-dots\">\n        {Array.from({ length: count }).map((_, index) => (\n          <span key={index} className={`tag-selector-rarity-dot ${getRarityClass(rarity)}`} />\n        ))}\n      </span>\n    );\n  };\n\n  return (\n    <div ref={containerRef} className=\"tag-selector\">\n      <div\n        className={`tag-selector-input-wrapper ${isOpen ? 'tag-selector-input-wrapper-open' : 'tag-selector-input-wrapper-closed'}`}\n        onClick={() => {\n          setIsOpen(true);\n          inputRef.current?.focus();\n        }}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(event) => {\n          if (event.key === 'Enter' || event.key === ' ') {\n            event.currentTarget.click();\n          }\n        }}\n      >\n        {value.map((tag) => {\n          const tagMeta = tagLookup[tag];\n          const isInvalid = !tagMeta;\n          const categoryClass = isInvalid ? 'tag-selector-category-invalid' : getCategoryClass(tagMeta.category);\n\n          return (\n            <span\n              key={tag}\n              className={`tag-selector-chip ${categoryClass}`}\n              title={isInvalid ? 'Tag not in registry - hover to add' : tagMeta?.description}\n              onMouseEnter={() => isInvalid && onAddToRegistry && handleInvalidTagMouseEnter(tag)}\n              onMouseLeave={() => isInvalid && handleInvalidTagMouseLeave()}\n            >\n              {isInvalid && <span className=\"tag-selector-invalid-warning\">\u26a0</span>}\n              {tag}\n              {tagMeta?.isAxis && <span title=\"Semantic plane axis label\" className=\"tag-selector-axis-indicator\">\u2194</span>}\n              {tagMeta && renderRarityDots(tagMeta.rarity)}\n              <button\n                type=\"button\"\n                className=\"tag-selector-remove-button\"\n                onClick={(event) => {\n                  event.stopPropagation();\n                  handleRemoveTag(tag);\n                }}\n              >\n                \u00d7\n              </button>\n              {isInvalid && hoveredInvalidTag === tag && onAddToRegistry && (\n                <div\n                  className=\"tag-selector-invalid-popup\"\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n                    setHoveredInvalidTag(null);\n                  }}\n                  onMouseEnter={handlePopupMouseEnter}\n                  onMouseLeave={() => setHoveredInvalidTag(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(event) => {\n                    if (event.key === 'Enter' || event.key === ' ') {\n                      event.currentTarget.click();\n                    }\n                  }}\n                >\n                  + Add to registry\n                </div>\n              )}\n            </span>\n          );\n        })}\n\n        <input\n          ref={inputRef}\n          type=\"text\"\n          className=\"tag-selector-search-input\"\n          value={searchQuery}\n          onChange={(event) => {\n            setSearchQuery(event.target.value);\n            setHighlightedIndex(0);\n          }}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsOpen(true)}\n          placeholder={value.length === 0 ? placeholder : ''}\n        />\n      </div>\n\n      {matchAllEnabled && value.length > 1 && (\n        <div className=\"tag-selector-match-all\">\n          <label className=\"tag-selector-match-all-label\">\n            <input\n              type=\"checkbox\"\n              className=\"tag-selector-match-all-checkbox\"\n              checked={matchAll}\n              onChange={(event) => onMatchAllChange?.(event.target.checked)}\n            />\n            Match all tags (AND)\n          </label>\n          <span className=\"tag-selector-match-all-hint\">\n            {matchAll ? 'Entity must have all tags' : 'Entity must have any tag'}\n          </span>\n        </div>\n      )}\n\n      {isOpen && (\n        <div className=\"tag-selector-dropdown\">\n          {canCreateTag && onAddToRegistry && (\n            <div\n              className={`tag-selector-create-option ${highlightedIndex === flatOptions.length - 1 ? 'tag-selector-create-option-highlighted' : ''}`}\n              onClick={() => handleCreateAndSelect(canCreateTag)}\n              onMouseEnter={() => setHighlightedIndex(flatOptions.length - 1)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(event) => {\n                if (event.key === 'Enter' || event.key === ' ') {\n                  event.currentTarget.click();\n                }\n              }}\n            >\n// ... (truncated)", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}", "type": "{ value?: any[]; onChange: any; tagRegistry?: any[]; onAddToRegistry: any; placeholder?: string; matchAllEnabled?: boolean; matchAll?: boolean; onMatchAllChange: any; singleSelect?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useRef", "count": 3}, {"name": "useMemo", "count": 4}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::AddCard", "name": "AddCard", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {string} props.label - Button label (default \"Add Item\")\n * @param {string} props.className - Optional CSS class name\n */\nexport function AddCard({ onClick, label = 'Add Item', className = '' }) {\n  return (\n    <div\n      className={`add-card ${className}`.trim()}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <span className=\"add-card-icon\">+</span>\n      <span>{label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/sidebar/index.js::CultureSidebar", "name": "CultureSidebar", "kind": "component", "filePath": "apps/name-forge/webui/src/components/sidebar/index.js", "sourceCode": "function CultureSidebar({\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}) {\n  const [creatingCulture, setCreatingCulture] = useState(false);\n  const [newCultureId, setNewCultureId] = useState(\"\");\n  const [newCultureName, setNewCultureName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const handleCreateCulture = () => {\n    if (!newCultureId.trim()) {\n      setError(\"Culture ID is required\");\n      return;\n    }\n    if (!/^[a-z0-9_]+$/.test(newCultureId)) {\n      setError(\"Culture ID must be lowercase letters, numbers, and underscores only (no hyphens)\");\n      return;\n    }\n    if (cultures[newCultureId]) {\n      setError(\"Culture ID already exists\");\n      return;\n    }\n    const cultureName = newCultureName || newCultureId;\n\n    // Create new culture with culture-level resources\n    const newCulture = {\n      id: newCultureId,\n      name: cultureName,\n      naming: {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: []\n      }\n    };\n    const updatedCultures = {\n      ...cultures,\n      [newCultureId]: newCulture\n    };\n    onCulturesChange(updatedCultures);\n\n    // Select the new culture\n    onSelectCulture(newCultureId);\n\n    // Reset form\n    setNewCultureId(\"\");\n    setNewCultureName(\"\");\n    setCreatingCulture(false);\n    setError(null);\n  };\n\n  // Get resource counts for a culture\n  const getResourceCounts = culture => {\n    const naming = culture?.naming || {};\n    return {\n      domains: naming.domains?.length || 0,\n      lexemes: Object.keys(naming.lexemeLists || {}).length,\n      grammars: naming.grammars?.length || 0,\n      profiles: naming.profiles?.length || 0\n    };\n  };\n\n  // Calculate completion based on having at least one of each resource\n  const calculateCompletion = culture => {\n    const counts = getResourceCounts(culture);\n    let completed = 0;\n    if (counts.domains > 0) completed++;\n    if (counts.lexemes > 0) completed++;\n    if (counts.grammars > 0) completed++;\n    if (counts.profiles > 0) completed++;\n    return Math.round(completed / 4 * 100);\n  };\n  return <div className=\"culture-sidebar\">\n      <div className=\"culture-sidebar-header\">\n        <div className=\"culture-sidebar-header-row\">\n          <h4>Cultures</h4>\n          {!readOnly && !creatingCulture && <button className=\"primary sm\" onClick={() => setCreatingCulture(true)}>\n              + New\n            </button>}\n        </div>\n\n        {creatingCulture && <div className=\"culture-form\">\n            <div className=\"form-group\">\n              <label htmlFor=\"culture-id\">Culture ID</label>\n              <input id=\"culture-id\" type=\"text\" value={newCultureId} onChange={e => setNewCultureId(e.target.value)} placeholder=\"elven\" />\n            </div>\n            <div className=\"form-group\">\n              <label htmlFor=\"display-name\">Display Name</label>\n              <input id=\"display-name\" type=\"text\" value={newCultureName} onChange={e => setNewCultureName(e.target.value)} placeholder=\"Elven\" />\n            </div>\n\n            {error && <div className=\"error\">{error}</div>}\n\n            <div className=\"culture-form-buttons\">\n              <button className=\"primary\" onClick={handleCreateCulture}>\n                Create\n              </button>\n              <button className=\"secondary\" onClick={() => {\n            setCreatingCulture(false);\n            setError(null);\n            setNewCultureId(\"\");\n            setNewCultureName(\"\");\n          }}>\n                Cancel\n              </button>\n            </div>\n          </div>}\n      </div>\n\n      <div className=\"culture-list\">\n        {Object.keys(cultures).length === 0 ? <div className=\"culture-list-empty\">No cultures yet. Create one to get started.</div> : Object.values(cultures).map(culture => {\n        const completion = calculateCompletion(culture);\n        const counts = getResourceCounts(culture);\n        const isSelected = selectedCulture === culture.id;\n        return <div key={culture.id} onClick={() => onSelectCulture(culture.id)} className={`culture-card ${isSelected ? \"selected\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n                <div className=\"culture-card-content\">\n                  <div className=\"culture-card-name\">{culture.name || culture.id}</div>\n\n                  {/* Resource counts */}\n                  <div className=\"culture-resource-grid\">\n                    <span className={`culture-resource-item ${counts.domains > 0 ? \"has-domains\" : \"\"}`}>\n                      {counts.domains} dom\n                    </span>\n                    <span className={`culture-resource-item ${counts.lexemes > 0 ? \"has-lexemes\" : \"\"}`}>\n                      {counts.lexemes} lex\n                    </span>\n                    <span className={`culture-resource-item ${counts.grammars > 0 ? \"has-grammars\" : \"\"}`}>\n                      {counts.grammars} gram\n                    </span>\n                    <span className={`culture-resource-item ${counts.profiles > 0 ? \"has-profiles\" : \"\"}`}>\n                      {counts.profiles} prof\n                    </span>\n                  </div>\n\n                  {/* Progress bar */}\n                  <div className=\"culture-progress-bar\">\n                    <div className={`culture-progress-fill csb-progress-fill ${completion === 100 ? \"complete\" : \"\"}`} style={{\n                '--csb-progress-width': `${completion}%`\n              }} />\n                  </div>\n                </div>\n              </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}", "type": "{ cultures: any; selectedCulture: any; onSelectCulture: any; onCulturesChange: any; readOnly?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 4}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::EntityWorkspace", "name": "EntityWorkspace", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function EntityWorkspace({\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}) {\n  const [error, setError] = useState(null);\n\n  // Use prop or fallback to local handling\n  const setActiveTab = onTabChange || (() => {});\n\n  if (!cultureId) {\n    return (\n      <div className=\"workspace-empty\">\n        <p className=\"text-muted\">Select a culture from the sidebar to begin</p>\n      </div>\n    );\n  }\n\n  // Handle domains change at culture level\n  const handleDomainsChange = (newDomains) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          domains: newDomains,\n        },\n      });\n    }\n  };\n\n  // Handle lexemes change at culture level\n  // Optional third param allows atomic update with grammars (for copy operations)\n  const handleLexemesChange = (newLexemeLists, newLexemeSpecs, newGrammars) => {\n    if (onCultureChange) {\n      const updates = {\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n        },\n      };\n      if (newLexemeLists !== undefined) updates.naming.lexemeLists = newLexemeLists;\n      if (newLexemeSpecs !== undefined) updates.naming.lexemeSpecs = newLexemeSpecs;\n      if (newGrammars !== undefined) updates.naming.grammars = newGrammars;\n      onCultureChange(updates);\n    }\n  };\n\n  // Handle grammars change at culture level\n  const handleGrammarsChange = (newGrammars) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          grammars: newGrammars,\n        },\n      });\n    }\n  };\n\n  // Handle profiles change at culture level\n  const handleProfilesChange = (newProfiles) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          profiles: newProfiles,\n        },\n      });\n    }\n  };\n\n  const getCompletionBadge = (key) => {\n    const naming = cultureConfig?.naming || {};\n    // Compute counts from culture-level data\n    if (key === \"domain\") {\n      const count = naming.domains?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"lexemes\") {\n      const count = Object.keys(naming.lexemeLists || {}).length;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"grammars\") {\n      const count = naming.grammars?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"profiles\") {\n      const count = naming.profiles?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className=\"workspace\">\n      {/* Header */}\n      <div className=\"workspace-header\">\n        <div className=\"workspace-header-row\">\n          <div>\n            <h3 className=\"workspace-title\">\n              <span className=\"workspace-title-name\">{cultureConfig?.name || cultureId}</span>\n              <span className=\"workspace-title-label\">Culture</span>\n            </h3>\n          </div>\n          <div className=\"workspace-autosave\">Auto-saved</div>\n        </div>\n\n        {error && (\n          <div className=\"error mt-sm\">\n            {error}\n            <button className=\"secondary ml-sm\" onClick={() => setError(null)}>\n              Dismiss\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"workspace-tabs\">\n        {[\"domain\", \"lexemes\", \"grammars\", \"profiles\"].map((tab) => (\n          <button\n            key={tab}\n            onClick={() => setActiveTab(tab)}\n            className={`workspace-tab ${activeTab === tab ? \"active\" : \"\"}`}\n          >\n            {tab} {getCompletionBadge(tab)}\n          </button>\n        ))}\n      </div>\n\n      {/* Content */}\n      <div className=\"workspace-content\">\n        {activeTab === \"domain\" && (\n          <DomainTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onDomainsChange={handleDomainsChange}\n          />\n        )}\n\n        {activeTab === \"lexemes\" && (\n          <LexemesTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onLexemesChange={handleLexemesChange}\n            apiKey={apiKey}\n          />\n        )}\n\n        {activeTab === \"grammars\" && (\n          <GrammarsTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onGrammarsChange={handleGrammarsChange}\n            onLexemesChange={handleLexemesChange}\n          />\n        )}\n\n        {activeTab === \"profiles\" && (\n          <ProfileTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            onProfilesChange={handleProfilesChange}\n            worldSchema={worldSchema}\n            onAddTag={onAddTag}\n            generators={generators}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}", "type": "{ worldSchema: any; cultureId: any; cultureConfig: any; allCultures: any; activeTab?: string; onTabChange: any; onCultureChange: any; onAddTag: any; apiKey: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::DomainTab", "name": "DomainTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "code", "children": [], "isMap": false, "isConditional": false}, {"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 4}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::LexemesTab", "name": "LexemesTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "CopyLexemeModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 9}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::GrammarsTab", "name": "GrammarsTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}, {"tag": "<>", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "GrammarPreview", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "GrammarHelpModal", "children": [], "isMap": false, "isConditional": true}, {"tag": "CopyGrammarModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 8}, {"name": "useRef", "count": 3}, {"name": "useEffect", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "ProfileModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/CopyGrammarModal.jsx::CopyGrammarModal", "name": "CopyGrammarModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/CopyGrammarModal.jsx", "sourceCode": "/**\n * Copy Grammar Modal - copy grammar from another culture with smart substitution\n */\nexport function CopyGrammarModal({\n  cultureId,\n  cultureConfig,\n  allCultures,\n  existingGrammarIds,\n  onCopy,\n  onClose,\n}) {\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [selectedGrammar, setSelectedGrammar] = useState(null);\n  const [newGrammarId, setNewGrammarId] = useState(\"\");\n  const [substitutedGrammar, setSubstitutedGrammar] = useState(null);\n  const [dependencies, setDependencies] = useState({ missing: [], existing: [] });\n  const [selectedDeps, setSelectedDeps] = useState(new Set());\n\n  const otherCultures = Object.entries(allCultures || {})\n    .filter(([id]) => id !== cultureId)\n    .map(([id, config]) => ({\n      id,\n      name: config.name || id,\n      grammars: config.naming?.grammars || [],\n    }));\n\n  useEffect(() => {\n    if (!selectedGrammar || !selectedCulture) {\n      setSubstitutedGrammar(null);\n      setDependencies({ missing: [], existing: [] });\n      setSelectedDeps(new Set());\n      return;\n    }\n\n    const sourceCulture = allCultures[selectedCulture];\n    const sourceGrammar = sourceCulture?.naming?.grammars?.find((g) => g.id === selectedGrammar);\n    if (!sourceGrammar) return;\n\n    // Find dependencies\n    const slotRefs = extractSlotReferences(sourceGrammar);\n    const targetLexemes = Object.keys(cultureConfig?.naming?.lexemeLists || {});\n    const sourceLexemes = sourceCulture?.naming?.lexemeLists || {};\n\n    const missing = [];\n    const existing = [];\n    slotRefs.forEach((slotId) => {\n      if (sourceLexemes[slotId]) {\n        const suffix = slotId.replace(/^[^_]+_/, \"\");\n        const targetEquivalent = targetLexemes.find((tl) => {\n          const tSuffix = tl.replace(/^[^_]+_/, \"\");\n          return tSuffix === suffix;\n        });\n\n        if (targetEquivalent) {\n          existing.push({ sourceId: slotId, targetId: targetEquivalent });\n        } else {\n          missing.push({ sourceId: slotId, entries: sourceLexemes[slotId].entries?.length || 0 });\n        }\n      }\n    });\n\n    setDependencies({ missing, existing });\n    setSelectedDeps(new Set(missing.map((d) => d.sourceId)));\n\n    const substituted = substituteGrammarReferences(\n      sourceGrammar,\n      sourceCulture,\n      cultureConfig,\n      cultureId\n    );\n    const finalId = generateUniqueId(cultureId, sourceGrammar.id, existingGrammarIds);\n\n    setNewGrammarId(finalId);\n    setSubstitutedGrammar({ ...substituted, id: finalId });\n  }, [selectedGrammar, selectedCulture, allCultures, cultureConfig, cultureId, existingGrammarIds]);\n\n  const toggleDep = (sourceId) => {\n    const newSelected = new Set(selectedDeps);\n    if (newSelected.has(sourceId)) {\n      newSelected.delete(sourceId);\n    } else {\n      newSelected.add(sourceId);\n    }\n    setSelectedDeps(newSelected);\n  };\n\n  const handleCopy = () => {\n    if (!substitutedGrammar) return;\n\n    const copiedLexemeLists = {};\n    const sourceCulture = allCultures[selectedCulture];\n    const existingListIds = Object.keys(cultureConfig?.naming?.lexemeLists || {});\n\n    selectedDeps.forEach((sourceId) => {\n      const sourceList = sourceCulture?.naming?.lexemeLists?.[sourceId];\n      if (sourceList) {\n        const newId = generateUniqueId(cultureId, sourceId, [\n          ...existingListIds,\n          ...Object.keys(copiedLexemeLists),\n        ]);\n        copiedLexemeLists[newId] = {\n          ...sourceList,\n          id: newId,\n          description: sourceList.description\n            ? `${sourceList.description} (copied from ${selectedCulture})`\n            : `Copied from ${selectedCulture}`,\n        };\n      }\n    });\n\n    let finalGrammar = { ...substitutedGrammar, id: newGrammarId };\n    if (Object.keys(copiedLexemeLists).length > 0) {\n      const idMapping = {};\n      selectedDeps.forEach((sourceId) => {\n        const suffix = sourceId.replace(/^[^_]+_/, \"\");\n        const newId = Object.keys(copiedLexemeLists).find((k) => {\n          const kSuffix = k.replace(/^[^_]+_/, \"\").replace(/_\\d+$/, \"\");\n          return kSuffix === suffix;\n        });\n        if (newId) idMapping[sourceId] = newId;\n      });\n\n      const newRules = {};\n      for (const [key, productions] of Object.entries(finalGrammar.rules || {})) {\n        newRules[key] = productions.map((prod) =>\n          prod.map((token) => applySlotIdMapping(token, idMapping))\n        );\n      }\n      finalGrammar = { ...finalGrammar, rules: newRules };\n    }\n\n    onCopy(finalGrammar, copiedLexemeLists);\n  };\n\n  const selectedCultureGrammars = selectedCulture\n    ? (allCultures[selectedCulture]?.naming?.grammars || []).filter(\n        (g) => Object.keys(g.rules || {}).length > 0\n      )\n    : [];\n\n  const footer = (\n    <>\n      <button className=\"secondary\" onClick={onClose}>\n        Cancel\n      </button>\n      <button\n        className=\"primary\"\n        onClick={handleCopy}\n        disabled={!substitutedGrammar || !newGrammarId.trim()}\n      >\n        Copy Grammar\n        {selectedDeps.size > 0 && (\n          ` + ${selectedDeps.size} List${selectedDeps.size > 1 ? \"s\" : \"\"}`\n        )}\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onClose} title=\"Copy Grammar from Another Culture\" className=\"copy-modal\" footer={footer}>\n      <div className=\"form-group\">\n        <label htmlFor=\"source-culture\">Source Culture</label>\n        <select id=\"source-culture\"\n          value={selectedCulture || \"\"}\n          onChange={(e) => {\n            setSelectedCulture(e.target.value || null);\n            setSelectedGrammar(null);\n          }}\n        >\n          <option value=\"\">Select a culture...</option>\n          {otherCultures.map((c) => (\n            <option key={c.id} value={c.id}>\n              {c.name} ({c.grammars.filter((g) => Object.keys(g.rules || {}).length > 0).length}{\" \"}\n              grammars)\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {selectedCulture && (\n        <div className=\"form-group\">\n          <label htmlFor=\"grammar-to-copy\">Grammar to Copy</label>\n          {selectedCultureGrammars.length === 0 ? (\n            <p className=\"text-muted text-small\">No grammars with rules in this culture.</p>\n          ) : (\n            <select\n              id=\"grammar-to-copy\"\n              value={selectedGrammar || \"\"}\n              onChange={(e) => setSelectedGrammar(e.target.value || null)}\n            >\n              <option value=\"\">Select a grammar...</option>\n              {selectedCultureGrammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      )}\n\n      {substitutedGrammar && (\n        <div className=\"copy-preview\">\n          <div className=\"form-group\">\n            <label htmlFor=\"new-grammar-id\">New Grammar ID</label>\n            <input id=\"new-grammar-id\"\n              value={newGrammarId}\n              onChange={(e) => setNewGrammarId(e.target.value)}\n              placeholder=\"grammar_id\"\n            />\n          </div>\n\n          {(dependencies.missing.length > 0 || dependencies.existing.length > 0) && (\n            <div className=\"dependency-section\">\n              <h5>Lexeme List Dependencies</h5>\n\n              {dependencies.existing.length > 0 && (\n                <div className=\"dependency-list mb-sm\">\n                  {dependencies.existing.map((dep) => (\n                    <div key={dep.sourceId} className=\"dependency-item exists\">\n                      <span>\u2713</span>\n                      <span>\n                        <code>{dep.sourceId}</code> \u2192 <code>{dep.targetId}</code>\n                      </span>\n                    </div>\n                  ))}\n                </div>\n              )}\n\n              {dependencies.missing.length > 0 && (\n                <>\n                  <p className=\"text-small text-muted mb-sm\">\n                    These lexeme lists are missing. Select which to copy:\n                  </p>\n                  <div className=\"dependency-list\">\n                    {dependencies.missing.map((dep) => (\n                      <label key={dep.sourceId} className=\"dependency-item missing\">\n                        <input\n                          type=\"checkbox\"\n                          checked={selectedDeps.has(dep.sourceId)}\n                          onChange={() => toggleDep(dep.sourceId)}\n                        />\n                        <span>\n                          <code>{dep.sourceId}</code> ({dep.entries} entries)\n                        </span>\n                      </label>\n                    ))}\n                  </div>\n                </>\n              )}\n            </div>\n          )}\n\n          <div className=\"copy-preview-section\">\n            <h4>Substitutions Applied</h4>\n            <p className=\"text-small text-muted\">\n              References to source culture resources are substituted with matching resources\n              from this culture.\n            </p>\n            <div className=\"copy-preview-rules\">\n              {Object.entries(substitutedGrammar.rules || {}).map(([key, productions]) => (\n                <div key={key} className=\"rule-card\">\n                  <div className=\"font-mono text-small\">\n                    <strong className=\"text-gold\">{key}</strong>\n                    <span className=\"text-muted\"> \u2192 </span>\n                    {productions.map((prod, i) => (\n                      <span key={i}>\n                        <span className=\"text-light\">{prod.join(\" \")}</span>\n                        {i < productions.length - 1 && <span className=\"text-muted\"> | </span>}\n                      </span>\n                    ))}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          <div className=\"copy-preview-section\">\n            <h4>Sample Names</h4>\n            <GrammarPreview\n              grammar={substitutedGrammar}\n              domains={cultureConfig?.naming?.domains || []}\n              lexemeLists={cultureConfig?.naming?.lexemeLists || EMPTY_LEXEME_LISTS}\n            />\n          </div>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  allCultures,\n  existingGrammarIds,\n  onCopy,\n  onClose,\n}", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; existingGrammarIds: any; onCopy: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "ModalShell", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "h5", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}, {"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "<>", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "GrammarPreview", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 6}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "../../../lib/browser-generator", "specifiers": ["previewGrammarNames"], "category": "internal"}], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/CopyLexemeModal.jsx::CopyLexemeModal", "name": "CopyLexemeModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/CopyLexemeModal.jsx", "sourceCode": "/**\n * Copy Lexeme List Modal - copy lexeme lists from another culture\n */\nexport function CopyLexemeModal({ cultureId, allCultures, existingListIds, onCopy, onClose }) {\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [selectedLists, setSelectedLists] = useState(new Set());\n\n  const otherCultures = Object.entries(allCultures || {})\n    .filter(([id]) => id !== cultureId)\n    .map(([id, config]) => ({\n      id,\n      name: config.name || id,\n      lexemeLists: config.naming?.lexemeLists || {},\n    }));\n\n  const selectedCultureLists = selectedCulture\n    ? Object.entries(allCultures[selectedCulture]?.naming?.lexemeLists || {})\n    : [];\n\n  const toggleList = (listId) => {\n    const newSelected = new Set(selectedLists);\n    if (newSelected.has(listId)) {\n      newSelected.delete(listId);\n    } else {\n      newSelected.add(listId);\n    }\n    setSelectedLists(newSelected);\n  };\n\n  const selectAll = () => {\n    setSelectedLists(new Set(selectedCultureLists.map(([id]) => id)));\n  };\n\n  const selectNone = () => {\n    setSelectedLists(new Set());\n  };\n\n  const handleCopy = () => {\n    if (selectedLists.size === 0) return;\n\n    const sourceCulture = allCultures[selectedCulture];\n    const copiedLists = {};\n    const usedIds = [...existingListIds];\n\n    selectedLists.forEach((listId) => {\n      const sourceList = sourceCulture?.naming?.lexemeLists?.[listId];\n      if (sourceList) {\n        const newId = generateUniqueId(cultureId, listId, usedIds);\n        usedIds.push(newId);\n\n        copiedLists[newId] = {\n          ...sourceList,\n          id: newId,\n          description: sourceList.description\n            ? `${sourceList.description} (copied from ${selectedCulture})`\n            : `Copied from ${selectedCulture}`,\n        };\n      }\n    });\n\n    onCopy(copiedLists);\n  };\n\n  const footer = (\n    <>\n      <button className=\"secondary\" onClick={onClose}>\n        Cancel\n      </button>\n      <button className=\"primary\" onClick={handleCopy} disabled={selectedLists.size === 0}>\n        Copy{\" \"}\n        {(() => {\n          if (selectedLists.size === 0) return \"Lists\";\n          const plural = selectedLists.size > 1 ? \"s\" : \"\";\n          return `${selectedLists.size} List${plural}`;\n        })()}\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onClose} title=\"Copy Lexeme Lists from Another Culture\" className=\"copy-modal\" footer={footer}>\n      <div className=\"form-group\">\n        <label htmlFor=\"source-culture\">Source Culture</label>\n        <select id=\"source-culture\"\n          value={selectedCulture || \"\"}\n          onChange={(e) => {\n            setSelectedCulture(e.target.value || null);\n            setSelectedLists(new Set());\n          }}\n        >\n          <option value=\"\">Select a culture...</option>\n          {otherCultures.map((c) => (\n            <option key={c.id} value={c.id}>\n              {c.name} ({Object.keys(c.lexemeLists).length} lists)\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {selectedCulture && selectedCultureLists.length > 0 && (\n        <div className=\"form-group\">\n          <div className=\"flex justify-between align-center mb-sm\">\n            <span className=\"mb-0\">Select Lists to Copy</span>\n            <div className=\"flex gap-sm\">\n              <button className=\"secondary sm\" onClick={selectAll}>\n                All\n              </button>\n              <button className=\"secondary sm\" onClick={selectNone}>\n                None\n              </button>\n            </div>\n          </div>\n          <div className=\"copy-list-grid\">\n            {selectedCultureLists.map(([listId, list]) => (\n              // eslint-disable-next-line jsx-a11y/label-has-associated-control\n              <label key={listId} className=\"copy-list-item\">\n                <input\n                  type=\"checkbox\"\n                  checked={selectedLists.has(listId)}\n                  onChange={() => toggleList(listId)}\n                />\n                <div className=\"copy-list-item-info\">\n                  <strong>{listId}</strong>\n                  <span className=\"text-muted text-small\">\n                    {list.entries?.length || 0} entries\n                    {list.source === \"llm\" && \" \u2022 LLM\"}\n                    {list.source === \"manual\" && \" \u2022 Manual\"}\n                  </span>\n                </div>\n              </label>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {selectedCulture && selectedCultureLists.length === 0 && (\n        <p className=\"text-muted\">No lexeme lists in this culture.</p>\n      )}\n\n      {selectedLists.size > 0 && (\n        <div className=\"copy-preview\">\n          <h4>\n            Will Copy {selectedLists.size} List{selectedLists.size > 1 ? \"s\" : \"\"}\n          </h4>\n          <p className=\"text-small text-muted\">\n            Lists will be renamed with &quot;{cultureId}_&quot; prefix.\n          </p>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ cultureId, allCultures, existingListIds, onCopy, onClose }", "type": "{ cultureId: any; allCultures: any; existingListIds: any; onCopy: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "ModalShell", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::DomainTab", "name": "DomainTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "code", "children": [], "isMap": false, "isConditional": false}, {"tag": "strong", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 4}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::LexemesTab", "name": "LexemesTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "CopyLexemeModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 9}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::GrammarsTab", "name": "GrammarsTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}, {"tag": "<>", "children": [{"tag": "code", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "GrammarPreview", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "GrammarHelpModal", "children": [], "isMap": false, "isConditional": true}, {"tag": "CopyGrammarModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 8}, {"name": "useRef", "count": 3}, {"name": "useEffect", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "ProfileModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "ProfileModal", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::StrategyGroupEditor", "name": "StrategyGroupEditor", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Strategy group editor component\n */\nexport default function StrategyGroupEditor({\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}) {\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n  const hasConditions = !!group.conditions;\n\n  const toggleConditions = () => {\n    const groups = [...editedProfile.strategyGroups];\n    if (hasConditions) {\n      groups[groupIdx] = { ...groups[groupIdx], conditions: null };\n    } else {\n      groups[groupIdx] = {\n        ...groups[groupIdx],\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      };\n    }\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  return (\n    <div className={`strategy-group ${hasConditions ? \"conditional\" : \"default\"}`}>\n      <div className=\"flex justify-between align-center mb-md\">\n        <div className=\"flex align-center gap-md\">\n          <input\n            value={group.name || \"\"}\n            onChange={(e) => {\n              const groups = [...editedProfile.strategyGroups];\n              groups[groupIdx] = { ...groups[groupIdx], name: e.target.value };\n              setEditedProfile({ ...editedProfile, strategyGroups: groups });\n            }}\n            placeholder=\"Group name\"\n            className=\"input-group-name\"\n          />\n          <div className=\"flex align-center gap-xs\">\n            <label className=\"text-xs text-muted\">Priority:\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => {\n                const groups = [...editedProfile.strategyGroups];\n                groups[groupIdx] = { ...groups[groupIdx], priority: v ?? 0 };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"input-priority\"\n              integer\n            />\n            </label>\n          </div>\n          <button className=\"secondary btn-xs\" onClick={toggleConditions}>\n            {hasConditions ? \"Remove Conditions\" : \"Add Conditions\"}\n          </button>\n        </div>\n        <button className=\"danger text-xs\" onClick={() => onDeleteGroup(groupIdx)}>\n          Delete Group\n        </button>\n      </div>\n\n      {/* Group Conditions */}\n      {hasConditions && (\n        <div className=\"conditions-panel\">\n          <div className=\"text-xs font-bold text-purple mb-md\">Group Conditions</div>\n\n          {/* Row 1: Entity Types and Prominence */}\n          <div className=\"form-grid-2 mb-md\">\n            {/* Entity Types */}\n            <div>\n              <label className=\"condition-label\">Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => onConditionChange(groupIdx, \"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            {/* Prominence */}\n            <div>\n              <label className=\"condition-label\">Prominence\n              <MultiSelectPills\n                options={prominenceLevels}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => onConditionChange(groupIdx, \"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n          </div>\n\n          {/* Row 2: Subtypes and Tags */}\n          <div className=\"form-grid-2\">\n            {/* Subtypes */}\n            <div>\n              <div className=\"flex justify-between align-center mb-xs\">\n                <span className=\"condition-label mb-0\">Subtypes</span>\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) =>\n                      onConditionChange(groupIdx, \"subtypeMatchAll\", e.target.checked)\n                    }\n                    className=\"checkbox-small\"\n                  />\n                  Match all\n                </label>\n              </div>\n              <TagsInput\n                value={group.conditions?.subtypes || []}\n                onChange={(val) => onConditionChange(groupIdx, \"subtypes\", val)}\n                placeholder=\"Type and press space...\"\n              />\n            </div>\n\n            {/* Tags */}\n            <div>\n              <label className=\"condition-label\">Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => onConditionChange(groupIdx, \"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => onConditionChange(groupIdx, \"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Strategies */}\n      {group.strategies.length === 0 && (\n        <div className=\"text-muted text-small mb-sm\">No strategies. Add one below.</div>\n      )}\n\n      {group.strategies.map((strategy, stratIdx) => (\n        <div key={stratIdx} className={`strategy-card ${strategy.type}`}>\n          <div className=\"flex justify-between align-center mb-sm\">\n            <div className=\"flex align-center gap-sm\">\n              <strong className=\"capitalize text-small\">{strategy.type}</strong>\n              <span className=\"weight-badge\">\n                {groupTotalWeight > 0 ? ((strategy.weight / groupTotalWeight) * 100).toFixed(0) : 0}\n                %\n              </span>\n            </div>\n            <button className=\"danger btn-xs\" onClick={() => onDeleteStrategy(groupIdx, stratIdx)}>\n              Remove\n            </button>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.05\"\n            value={strategy.weight}\n            onChange={(e) => onWeightChange(groupIdx, stratIdx, e.target.value)}\n            className=\"strategy-slider\"\n          />\n\n          {strategy.type === \"phonotactic\" && (\n            <select\n              value={strategy.domainId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], domainId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select domain...</option>\n              {domains.map((d) => (\n                <option key={d.id} value={d.id}>\n                  {d.id}\n                </option>\n              ))}\n            </select>\n          )}\n\n          {strategy.type === \"grammar\" && (\n            <select\n              value={strategy.grammarId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], grammarId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select grammar...</option>\n              {grammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      ))}\n\n      <div className=\"flex gap-xs mt-sm\">\n        <button\n          className=\"secondary text-xs\"\n          onClick={() => onAddStrategy(groupIdx, \"phonotactic\")}\n        >\n          + Phonotactic\n        </button>\n        <button className=\"secondary text-xs\" onClick={() => onAddStrategy(groupIdx, \"grammar\")}>\n          + Grammar\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; domains: any; grammars: any; entityKinds: any; prominenceLevels: any; tagRegistry: any; editedProfile: any; setEditedProfile: any; onDeleteGroup: any; onAddStrategy: any; onDeleteStrategy: any; onWeightChange: any; onConditionChange: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "NumberInput", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [{"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "label", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "TagsInput", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "TagSelector", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "strong", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::TestPanel", "name": "TestPanel", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Test panel for generating test names from a profile\n */\nexport default function TestPanel({\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}) {\n  return (\n    <div className=\"test-panel\">\n      <div className=\"flex justify-between align-center mb-md\">\n        <h4 className=\"mt-0 mb-0\">Test: {profile.id}</h4>\n        <div className=\"flex gap-sm\">\n          <button\n            className=\"primary text-small\"\n            onClick={() => onTest(profile, 10)}\n            disabled={testLoading}\n          >\n            {testLoading ? \"...\" : \"Generate\"}\n          </button>\n          <button className=\"secondary text-small\" onClick={onClose}>\n            Close\n          </button>\n        </div>\n      </div>\n\n      {testError && <div className=\"error mb-md text-small\">{testError}</div>}\n\n      {strategyUsage && (\n        <div className=\"strategy-usage-panel\">\n          {Object.entries(strategyUsage)\n            .filter(([, count]) => count > 0)\n            .map(([strategy, count]) => (\n              <span key={strategy} className=\"mr-sm\">\n                {strategy}: {count}\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-names-list\">\n          {testNames.map((name, i) => (\n            <div key={i} className=\"test-name-item\">\n              {name}\n            </div>\n          ))}\n        </div>\n      ) : (\n        <p className=\"text-muted text-small mt-0 mb-0\">Click Generate to test this profile</p>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}", "type": "{ profile: any; testNames: any; testLoading: any; testError: any; strategyUsage: any; onTest: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::MultiSelectPills", "name": "MultiSelectPills", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Multi-select pills component for selecting multiple options\n * Note: Consider replacing with ChipSelect from shared-components in future\n */\nexport default function MultiSelectPills({ options, selected, onChange, allLabel = \"All\" }) {\n  const isAllSelected = selected.length === 0 || (selected.length === 1 && selected[0] === \"*\");\n\n  const handleToggle = (value) => {\n    if (value === \"*\") {\n      onChange([]);\n    } else {\n      const newSelected = selected.filter((s) => s !== \"*\");\n      if (newSelected.includes(value)) {\n        const filtered = newSelected.filter((s) => s !== value);\n        onChange(filtered.length === 0 ? [] : filtered);\n      } else {\n        onChange([...newSelected, value]);\n      }\n    }\n  };\n\n  return (\n    <div className=\"flex flex-wrap gap-xs\">\n      <button\n        type=\"button\"\n        onClick={() => handleToggle(\"*\")}\n        className={`pill-button ${isAllSelected ? \"selected-gold\" : \"\"}`}\n      >\n        {allLabel}\n      </button>\n      {options.map((opt) => {\n        const isSelected = !isAllSelected && selected.includes(opt);\n        return (\n          <button\n            key={opt}\n            type=\"button\"\n            onClick={() => handleToggle(opt)}\n            className={`pill-button ${isSelected ? \"selected-green\" : \"\"}`}\n          >\n            {opt}\n          </button>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ options, selected, onChange, allLabel = \"All\" }", "type": "{ options: any; selected: any; onChange: any; allLabel?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::TagsInput", "name": "TagsInput", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Tags input with auto-split on space/comma\n * Note: Consider using TagSelector from shared-components in future\n */\nexport default function TagsInput({ value, onChange, placeholder }) {\n  const tags = Array.isArray(value) ? value : [];\n\n  const handleKeyDown = (e) => {\n    if (e.key === \" \" || e.key === \",\" || e.key === \"Enter\") {\n      e.preventDefault();\n      const input = e.target.value.trim();\n      if (input && !tags.includes(input)) {\n        onChange([...tags, input]);\n      }\n      e.target.value = \"\";\n    } else if (e.key === \"Backspace\" && e.target.value === \"\" && tags.length > 0) {\n      onChange(tags.slice(0, -1));\n    }\n  };\n\n  const handleRemove = (tag) => {\n    onChange(tags.filter((t) => t !== tag));\n  };\n\n  return (\n    <div className=\"tags-input-container\">\n      {tags.map((tag) => (\n        <span key={tag} className=\"tag-chip\">\n          {tag}\n          <button type=\"button\" onClick={() => handleRemove(tag)} className=\"tag-remove-btn\">\n            x\n          </button>\n        </span>\n      ))}\n      <input\n        type=\"text\"\n        onKeyDown={handleKeyDown}\n        placeholder={tags.length === 0 ? placeholder : \"\"}\n        className=\"tags-input\"\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ value, onChange, placeholder }", "type": "{ value: any; onChange: any; placeholder: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::OverviewTab", "name": "OverviewTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function OverviewTab({\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}) {\n  const matchCount = generatorUsage?.totalMatches || 0;\n  const groups = profile.strategyGroups || [];\n\n  // Drag state\n  const [draggedIdx, setDraggedIdx] = useState(null);\n  const [dragOverIdx, setDragOverIdx] = useState(null);\n  const dragNodeRef = useRef(null);\n\n  const handleDragStart = (e, idx) => {\n    setDraggedIdx(idx);\n    dragNodeRef.current = e.target;\n    e.target.classList.add(\"dragging\");\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setData(\"text/plain\", idx);\n  };\n\n  const handleDragEnd = (e) => {\n    e.target.classList.remove(\"dragging\");\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n    dragNodeRef.current = null;\n  };\n\n  const handleDragOver = (e, idx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === idx) return;\n    setDragOverIdx(idx);\n  };\n\n  const handleDragLeave = () => {\n    setDragOverIdx(null);\n  };\n\n  const handleDrop = (e, dropIdx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === dropIdx) return;\n\n    const newGroups = [...groups];\n    const [draggedGroup] = newGroups.splice(draggedIdx, 1);\n    newGroups.splice(dropIdx, 0, draggedGroup);\n\n    onChange({ ...profile, strategyGroups: newGroups });\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n  };\n\n  const getStrategyTypeCounts = (group) => {\n    const counts = { phonotactic: 0, grammar: 0 };\n    (group.strategies || []).forEach((s) => {\n      if (counts[s.type] !== undefined) counts[s.type]++;\n    });\n    return counts;\n  };\n\n  return (\n    <div className=\"profile-overview-tab\">\n      {/* Profile ID */}\n      <div className=\"form-group\">\n        <label htmlFor=\"profile-id\">Profile ID</label>\n        <input id=\"profile-id\"\n          value={profile.id || \"\"}\n          onChange={(e) => onChange({ ...profile, id: e.target.value })}\n          placeholder=\"e.g., culture_default\"\n        />\n        <small className=\"text-muted\">\n          Unique identifier used to reference this profile in generators\n        </small>\n      </div>\n\n      {/* Default Profile Toggle */}\n      <div className=\"form-group\">\n        <label className=\"checkbox-label\">\n          <input\n            type=\"checkbox\"\n            checked={profile.isDefault || false}\n            onChange={(e) => onChange({ ...profile, isDefault: e.target.checked })}\n          />\n          <span>Default Profile</span>\n        </label>\n        <small className=\"text-muted\">\n          Use this profile when no entity kind matches. Only one profile should be marked as\n          default.\n        </small>\n      </div>\n\n      {/* Entity Kinds Binding */}\n      <div className=\"form-group\">\n        <label>Entity Kinds\n        <MultiSelectPills\n          options={entityKinds}\n          selected={profile.entityKinds || []}\n          onChange={(kinds) => onChange({ ...profile, entityKinds: kinds })}\n          allLabel=\"Any\"\n        />\n        </label>\n        <small className=\"text-muted\">\n          Profile applies when generating names for these entity kinds. &quot;Any&quot; means use default\n          profile logic.\n        </small>\n      </div>\n\n      {/* Stats */}\n      <div className=\"profile-stats\">\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.length}</div>\n          <div className=\"stat-label\">Strategy Groups</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">\n            {groups.reduce((sum, g) => sum + (g.strategies?.length || 0), 0)}\n          </div>\n          <div className=\"stat-label\">Total Strategies</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.filter((g) => g.conditions).length}</div>\n          <div className=\"stat-label\">Conditional</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{matchCount}</div>\n          <div className=\"stat-label\">Generator Matches</div>\n        </div>\n      </div>\n\n      {/* Groups Overview */}\n      <div className=\"groups-overview\">\n        <div className=\"groups-header\">\n          <h4>Strategy Groups</h4>\n          <span className=\"text-muted text-small\">Drag to reorder priority</span>\n        </div>\n\n        {groups.length === 0 ? (\n          <div className=\"empty-groups\">\n            <p>No strategy groups yet. Add one using the buttons below the sidebar.</p>\n          </div>\n        ) : (\n          <div className=\"groups-list\">\n            {groups.map((group, idx) => {\n              const isConditional = !!group.conditions;\n              const counts = getStrategyTypeCounts(group);\n              const isDragOver = dragOverIdx === idx && draggedIdx !== idx;\n\n              return (\n                <div\n                  key={idx}\n                  className={`group-row ${isDragOver ? \"drag-over\" : \"\"} ${draggedIdx === idx ? \"dragging\" : \"\"}`}\n                  draggable\n                  onDragStart={(e) => handleDragStart(e, idx)}\n                  onDragEnd={handleDragEnd}\n                  onDragOver={(e) => handleDragOver(e, idx)}\n                  onDragLeave={handleDragLeave}\n                  onDrop={(e) => handleDrop(e, idx)}\n                  onClick={() => onNavigateToGroup?.(idx)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div className=\"drag-handle\" title=\"Drag to reorder\">\n                    <span>\u22ee\u22ee</span>\n                  </div>\n\n                  <div className=\"group-info\">\n                    <span className=\"group-name\">{group.name || `Group ${idx + 1}`}</span>\n                    <span\n                      className={`group-type-badge ${isConditional ? \"conditional\" : \"default\"}`}\n                    >\n                      {isConditional ? \"\ud83c\udfaf Conditional\" : \"\ud83d\udce6 Default\"}\n                    </span>\n                  </div>\n\n                  <div className=\"group-meta\">\n                    <span className=\"priority-badge\" title=\"Priority\">\n                      P{group.priority || 0}\n                    </span>\n                    {counts.phonotactic > 0 && (\n                      <span className=\"strategy-count phonotactic\" title=\"Phonotactic strategies\">\n                        {counts.phonotactic}\n                      </span>\n                    )}\n                    {counts.grammar > 0 && (\n                      <span className=\"strategy-count grammar\" title=\"Grammar strategies\">\n                        {counts.grammar}\n                      </span>\n                    )}\n                    {counts.phonotactic === 0 && counts.grammar === 0 && (\n                      <span className=\"no-strategies\">No strategies</span>\n                    )}\n                  </div>\n\n                  <div className=\"group-arrow\">\u2192</div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n\n        <p className=\"text-muted text-xs mt-sm\">\n          Groups are evaluated by priority (highest first). First matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Actions */}\n      <div className=\"profile-actions\">\n        <button className=\"secondary\" onClick={onDuplicate}>\n          Duplicate Profile\n        </button>\n      </div>\n\n      {/* Danger Zone */}\n      <div className=\"danger-zone\">\n        <h4>Danger Zone</h4>\n        <button className=\"danger\" onClick={onDelete}>\n          Delete Profile\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}", "type": "{ profile: any; onChange: any; onDelete: any; onDuplicate: any; onNavigateToGroup: any; generatorUsage: any; entityKinds?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "small", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::SingleGroupTab", "name": "SingleGroupTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function SingleGroupTab({\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}) {\n  const hasConditions = !!group.conditions;\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n\n  // Compute available subtypes based on selected entity kinds\n  // worldSchema.hardState has: { kind, subtype: string[], status: string[] }\n  const availableSubtypes = useMemo(() => {\n    const selectedKinds = group.conditions?.entityKinds || [];\n    const entityDefs = worldSchema?.hardState || [];\n\n    // If no entity kinds selected, show all subtypes from all entity kinds\n    const kindsToCheck =\n      selectedKinds.length > 0\n        ? entityDefs.filter((e) => selectedKinds.includes(e.kind))\n        : entityDefs;\n\n    const subtypes = new Set();\n    kindsToCheck.forEach((entityDef) => {\n      // subtype is already a string array in hardState format\n      (entityDef.subtype || []).forEach((st) => {\n        if (st) subtypes.add(st);\n      });\n    });\n\n    return Array.from(subtypes).sort();\n  }, [group.conditions?.entityKinds, worldSchema]);\n\n  const updateGroup = (updates) => {\n    onChange({ ...group, ...updates });\n  };\n\n  const toggleConditions = () => {\n    if (hasConditions) {\n      updateGroup({ conditions: null });\n    } else {\n      updateGroup({\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      });\n    }\n  };\n\n  const handleConditionChange = (field, value) => {\n    updateGroup({\n      conditions: { ...group.conditions, [field]: value },\n    });\n  };\n\n  const handleAddStrategy = (type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n    updateGroup({\n      strategies: [...group.strategies, newStrategy],\n    });\n  };\n\n  const handleDeleteStrategy = (stratIdx) => {\n    updateGroup({\n      strategies: group.strategies.filter((_, i) => i !== stratIdx),\n    });\n  };\n\n  const handleWeightChange = (stratIdx, newWeight) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    updateGroup({ strategies });\n  };\n\n  const handleStrategyConfigChange = (stratIdx, field, value) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], [field]: value };\n    updateGroup({ strategies });\n  };\n\n  return (\n    <div className=\"single-group-tab\">\n      {/* Group Header */}\n      <div className=\"group-header-section\">\n        <div className=\"group-name-row\">\n          <div className=\"form-group\">\n            <label htmlFor=\"group-name\">Group Name</label>\n            <input id=\"group-name\"\n              value={group.name || \"\"}\n              onChange={(e) => updateGroup({ name: e.target.value })}\n              placeholder=\"e.g., Noble Names\"\n            />\n          </div>\n          <div className=\"form-group priority-field\">\n            <label>Priority\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => updateGroup({ priority: v ?? 0 })}\n              integer\n            />\n            </label>\n          </div>\n        </div>\n        <p className=\"text-muted text-small mt-0\">\n          Higher priority groups are evaluated first. The first matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Conditions Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Conditions</h4>\n          <button\n            className={`toggle-btn ${hasConditions ? \"active\" : \"\"}`}\n            onClick={toggleConditions}\n          >\n            {hasConditions ? \"Conditional\" : \"Always Match\"}\n          </button>\n        </div>\n\n        {hasConditions ? (\n          <div className=\"conditions-grid\">\n            <div className=\"condition-field\">\n              <label>Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => handleConditionChange(\"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Prominence\n              <MultiSelectPills\n                options={PROMINENCE_LEVELS}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => handleConditionChange(\"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>\n                Subtypes\n                <label className=\"match-all-toggle\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) => handleConditionChange(\"subtypeMatchAll\", e.target.checked)}\n                  />\n                  Match all\n                </label>\n              </label>\n              {availableSubtypes.length > 0 ? (\n                <MultiSelectPills\n                  options={availableSubtypes}\n                  selected={group.conditions?.subtypes || []}\n                  onChange={(val) => handleConditionChange(\"subtypes\", val)}\n                  allLabel=\"Any\"\n                />\n              ) : (\n                <p className=\"text-muted text-small sgt-no-subtypes\">\n                  {(group.conditions?.entityKinds?.length || 0) > 0\n                    ? \"Selected entity types have no subtypes defined\"\n                    : \"Select entity types to see available subtypes\"}\n                </p>\n              )}\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => handleConditionChange(\"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => handleConditionChange(\"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        ) : (\n          <p className=\"text-muted text-small\">\n            This group will always be considered. Click &quot;Always Match&quot; to add conditions.\n          </p>\n        )}\n      </div>\n\n      {/* Strategies Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Strategies</h4>\n          <div className=\"add-strategy-buttons\">\n            <button\n              className=\"add-btn phonotactic\"\n              onClick={() => handleAddStrategy(\"phonotactic\")}\n            >\n              + Phonotactic\n            </button>\n            <button className=\"add-btn grammar\" onClick={() => handleAddStrategy(\"grammar\")}>\n              + Grammar\n            </button>\n          </div>\n        </div>\n\n        {group.strategies.length === 0 ? (\n          <div className=\"empty-strategies\">\n            <p>No strategies yet. Add a strategy to define how names are generated.</p>\n          </div>\n        ) : (\n          <div className=\"strategies-list\">\n            {group.strategies.map((strategy, stratIdx) => (\n              <div key={stratIdx} className={`strategy-item ${strategy.type}`}>\n                <div className=\"strategy-header\">\n                  <span className=\"strategy-type\">{strategy.type}</span>\n                  <span className=\"strategy-weight\">\n                    {groupTotalWeight > 0\n                      ? Math.round((strategy.weight / groupTotalWeight) * 100)\n                      : 0}\n                    %\n                  </span>\n                  <button className=\"remove-btn\" onClick={() => handleDeleteStrategy(stratIdx)}>\n                    \u00d7\n                  </button>\n                </div>\n\n                <div className=\"strategy-body\">\n                  <div className=\"weight-slider\">\n                    <label htmlFor=\"weight\">Weight</label>\n                    <input id=\"weight\"\n                      type=\"range\"\n                      min=\"0\"\n                      max=\"1\"\n                      step=\"0.05\"\n                      value={strategy.weight}\n                      onChange={(e) => handleWeightChange(stratIdx, e.target.value)}\n                    />\n                  </div>\n\n                  {strategy.type === \"phonotactic\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"domain\">Domain</label>\n                      <select id=\"domain\"\n                        value={strategy.domainId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"domainId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select domain...</option>\n                        {domains.map((d) => (\n                          <option key={d.id} value={d.id}>\n                            {d.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n\n                  {strategy.type === \"grammar\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"grammar\">Grammar</label>\n                      <select id=\"grammar\"\n                        value={strategy.grammarId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"grammarId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select grammar...</option>\n                        {grammars.map((g) => (\n                          <option key={g.id} value={g.id}>\n                            {g.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n                </div>\n              </div>\n// ... (truncated)", "parameters": [{"name": "{\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; onChange: any; onDelete: any; domains: any; grammars: any; entityKinds: any; worldSchema: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "NumberInput", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [{"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "label", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "MultiSelectPills", "children": [], "isMap": false, "isConditional": true}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [{"tag": "TagSelector", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h4", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::TestTab", "name": "TestTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function TestTab({ profile, cultureConfig }) {\n  const [testNames, setTestNames] = useState([]);\n  const [testLoading, setTestLoading] = useState(false);\n  const [testError, setTestError] = useState(null);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [count, setCount] = useState(10);\n\n  const handleTestNames = async () => {\n    if (!profile || !cultureConfig) return;\n\n    setTestLoading(true);\n    setTestError(null);\n    setTestNames([]);\n    setStrategyUsage(null);\n\n    try {\n      const result = await generateTestNames({\n        culture: cultureConfig,\n        profileId: profile.id,\n        count,\n        seed: `test-${Date.now()}`,\n      });\n\n      setTestNames(result.names || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setTestError(err.message);\n    } finally {\n      setTestLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"profile-test-tab\">\n      <div className=\"test-controls\">\n        <div className=\"test-count-control\">\n          <label>Count:\n          <NumberInput\n            min={1}\n            max={100}\n            value={count}\n            onChange={(v) => setCount(v ?? 10)}\n            integer\n          />\n          </label>\n        </div>\n        <button className=\"primary\" onClick={handleTestNames} disabled={testLoading}>\n          {testLoading ? \"Generating...\" : \"Generate Names\"}\n        </button>\n      </div>\n\n      {testError && <div className=\"error-box\">{testError}</div>}\n\n      {strategyUsage && Object.keys(strategyUsage).length > 0 && (\n        <div className=\"strategy-usage-summary\">\n          <span className=\"usage-label\">Strategy usage:</span>\n          {Object.entries(strategyUsage)\n            .filter(([, cnt]) => cnt > 0)\n            .map(([strategy, cnt]) => (\n              <span key={strategy} className=\"usage-item\">\n                <span className=\"usage-strategy\">{strategy}</span>\n                <span className=\"usage-count\">{cnt}</span>\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-results\">\n          <div className=\"results-header\">\n            <span className=\"results-count\">{testNames.length} names generated</span>\n          </div>\n          <div className=\"test-names-grid\">\n            {testNames.map((name, i) => (\n              <div key={i} className=\"test-name-card\">\n                {name}\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div className=\"empty-test-state\">\n          <p>Click &quot;Generate Names&quot; to test this profile</p>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ profile, cultureConfig }", "type": "{ profile: any; cultureConfig: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "label", "children": [{"tag": "NumberInput", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "p", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 5}], "imports": [], "storeAccess": []}]