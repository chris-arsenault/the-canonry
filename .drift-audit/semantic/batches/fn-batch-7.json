[{"id": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx", "sourceCode": "export default function RemotePlaceholder({ name, instructions }) {\n  return (\n    <div className=\"rph-container\">\n      <div className=\"rph-icon\">\ud83d\udd0c</div>\n      <div className=\"rph-title\">{name} Not Connected</div>\n      <div className=\"rph-message\">\n        The {name} module is not currently running. Start it to enable this feature.\n      </div>\n      {instructions && <div className=\"rph-instructions\">{instructions}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{ name, instructions }", "type": "{ name: any; instructions: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./RemotePlaceholder.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForSimulation", "name": "getCompletedChroniclesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForProject", "name": "getCompletedChroniclesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForProject(projectId) {\n  if (!projectId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"projectId\");\n        const request = index.getAll(IDBKeyRange.only(projectId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::importChronicles", "name": "importChronicles", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "/**\n * Import chronicles into a project (overwrite-merge by chronicleId).\n *\n * @param {string} projectId\n * @param {Array} chronicles\n * @param {Object} options\n * @param {string} options.simulationRunId - Optional run ID to apply when missing\n */\nexport async function importChronicles(projectId, chronicles, options = {}) {\n  if (!projectId || !Array.isArray(chronicles) || chronicles.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  const { simulationRunId } = options;\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n\n      for (const chronicle of chronicles) {\n        if (!chronicle?.chronicleId) {\n          skipped += 1;\n          continue;\n        }\n        const record = {\n          ...chronicle,\n          projectId,\n          simulationRunId: chronicle.simulationRunId || simulationRunId || null,\n        };\n        const req = store.get(record.chronicleId);\n        req.onsuccess = () => {\n          if (req.result) overwritten += 1;\n          store.put(record);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "chronicles", "type": "any[]", "optional": false}, {"name": "options", "type": "{ simulationRunId: string; }", "optional": true}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getChronicleCountForProject", "name": "getChronicleCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getChronicleCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/db.js::openDatabase", "name": "openDatabase", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Open (or reuse) the IndexedDB database.\n */\nexport async function openDatabase() {\n  if (dbInstance) return dbInstance;\n\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n\n    request.onsuccess = () => {\n      dbInstance = request.result;\n      resolve(dbInstance);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n        store.createIndex(\"name\", \"name\", { unique: false });\n        store.createIndex(\"updatedAt\", \"updatedAt\", { unique: false });\n      }\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/db.js::saveProject", "name": "saveProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Save a project to the database.\n */\nexport async function saveProject(project) {\n  const db = await openDatabase();\n  const timestamp = new Date().toISOString();\n\n  const projectToSave = {\n    ...project,\n    updatedAt: timestamp,\n    createdAt: project.createdAt || timestamp,\n  };\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put(projectToSave);\n\n    request.onsuccess = () => resolve(projectToSave);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "project", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/db.js::loadProject", "name": "loadProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Load a project by ID.\n */\nexport async function loadProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.get(id);\n\n    request.onsuccess = () => resolve(request.result || null);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/db.js::deleteProject", "name": "deleteProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Delete a project by ID.\n */\nexport async function deleteProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.delete(id);\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/db.js::listProjects", "name": "listProjects", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * List all projects (metadata only, sorted by recency).\n */\nexport async function listProjects() {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.getAll();\n\n    request.onsuccess = () => {\n      const projects = request.result.map((p) => ({\n        id: p.id,\n        name: p.name,\n        updatedAt: p.updatedAt,\n        entityCount: p.seedEntities?.length || 0,\n        cultureCount: p.cultures?.length || 0,\n      }));\n\n      // Sort by most recently updated\n      projects.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));\n      resolve(projects);\n    };\n\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/db.js::createEmptyProject", "name": "createEmptyProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Create a new empty project with default structure.\n */\nexport function createEmptyProject(name = \"New World\") {\n  return {\n    id: `project_${Date.now()}`,\n    name,\n    version: \"1.0\",\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    // Schema (Enumerist)\n    entityKinds: [],\n    relationshipKinds: [],\n    // Cultures (Enumerist + Name Forge + Cosmographer)\n    cultures: [],\n    // Tag Registry (Enumerist)\n    tagRegistry: [],\n    // Axis definitions (Cosmographer)\n    axisDefinitions: [],\n    // UI configuration (Archivist + UI hints)\n    uiConfig: DEFAULT_UI_CONFIG,\n    // Temporal structure (Cosmographer)\n    eras: [],\n    // Simulation config (Coherence Engine)\n    pressures: [],\n    generators: [],\n    systems: [],\n    actions: [],\n    // Seed data (Cosmographer)\n    seedEntities: [],\n    seedRelationships: [],\n    // Distribution targets (Lore Weave)\n    distributionTargets: null,\n    // Simulation (Simulation Workshop) - optional, undefined until configured\n    simulation: undefined,\n  };\n}", "parameters": [{"name": "name", "type": "string", "optional": true}], "returnType": "{ id: string; name: string; version: string; createdAt: string; updatedAt: string; entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; axisDefinitions: any[]; uiConfig: { worldIcon: string; prominenceLevels: string[]; prominenceColors: { forgotten: string; marginal: string; recognized: string; renowned: string; mythic: string; }; }; eras: any[]; pressures: any[]; generators: any[]; systems: any[]; actions: any[]; seedEntities: any[]; seedRelationships: any[]; distributionTargets: any; simulation: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::importEntities", "name": "importEntities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function importEntities(simulationRunId, entities) {\n  if (!simulationRunId || !Array.isArray(entities) || entities.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(ENTITIES_STORE_NAME)) {\n      throw new Error(\"Illuminator entities store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n\n      for (const entity of entities) {\n        if (!entity?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(entity.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n\n          const merged = mergeDefined(existing, incoming);\n          const incomingEnrichment = incoming.enrichment || {};\n          const existingEnrichment = existing.enrichment || {};\n\n          merged.enrichment = { ...existingEnrichment, ...incomingEnrichment };\n          merged.summary = incoming.summary ?? existing.summary;\n          merged.description = incoming.description ?? existing.description;\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "entities", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::getEntityCountForRun", "name": "getEntityCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function getEntityCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/eraNarrativeStorage.js::getCompletedEraNarrativesForSimulation", "name": "getCompletedEraNarrativesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eraNarrativeStorage.js", "sourceCode": "export async function getCompletedEraNarrativesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Check if the store exists (older DB versions may not have it)\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        return [];\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(STORE_NAME, \"readonly\");\n        const store = tx.objectStore(STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allRecords = request.result || [];\n          const projected = allRecords.map(projectForExport).filter(Boolean);\n\n          // Keep only the latest completed narrative per era\n          const byEra = new Map();\n          for (const record of projected) {\n            const existing = byEra.get(record.eraId);\n            if (!existing || record.updatedAt > existing.updatedAt) {\n              byEra.set(record.eraId, record);\n            }\n          }\n\n          resolve(Array.from(byEra.values()));\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get era narratives\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[eraNarrativeStorage] Failed to load era narratives:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::importNarrativeEvents", "name": "importNarrativeEvents", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function importNarrativeEvents(simulationRunId, events) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(EVENTS_STORE_NAME)) {\n      throw new Error(\"Illuminator narrativeEvents store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n\n      for (const event of events) {\n        if (!event?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...event,\n          simulationRunId: event.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(event.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n          const merged = mergeDefined(existing, incoming);\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "events", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::getNarrativeEventCountForRun", "name": "getNarrativeEventCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function getNarrativeEventCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () =>\n        reject(request.error || new Error(\"Failed to count narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::importBundleImageReferences", "name": "importBundleImageReferences", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function importBundleImageReferences({ projectId, imageData, images } = {}) {\n  if (!projectId) return { imported: 0, skipped: 0 };\n  const results = Array.isArray(imageData?.results) ? imageData.results : [];\n  if (results.length === 0) return { imported: 0, skipped: 0 };\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(IMAGES_STORE_NAME)) {\n      throw new Error(\"Illuminator images store is unavailable.\");\n    }\n\n    const now = Date.now();\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n\n      for (const entry of results) {\n        const imageId = entry?.imageId;\n        if (!imageId) {\n          skipped += 1;\n          continue;\n        }\n\n        const rawPath = (images && images[imageId]) || entry.localPath;\n        const sourcePath = normalizeSourcePath(rawPath);\n        const mimeType = inferMimeType(sourcePath);\n        const incomingEntityId = entry.entityId || entry.chronicleId || null;\n\n        const getReq = store.get(imageId);\n        getReq.onsuccess = () => {\n          const existing = getReq.result || {};\n          if (getReq.result) overwritten += 1;\n          const merged = {\n            ...existing,\n            imageId,\n            projectId,\n            entityId: incomingEntityId ?? existing.entityId ?? \"chronicle\",\n            entityName: entry.entityName ?? existing.entityName,\n            entityKind: entry.entityKind ?? existing.entityKind,\n            entityCulture: entry.entityCulture ?? existing.entityCulture,\n            originalPrompt: entry.prompt ?? existing.originalPrompt,\n            finalPrompt: entry.prompt ?? existing.finalPrompt,\n            imageType: entry.imageType ?? existing.imageType,\n            chronicleId: entry.chronicleId ?? existing.chronicleId,\n            imageRefId: entry.imageRefId ?? existing.imageRefId,\n            sceneDescription: entry.sceneDescription ?? existing.sceneDescription,\n            generatedAt: existing.generatedAt ?? now,\n            model: existing.model || \"imported\",\n            mimeType: existing.mimeType || mimeType,\n            size: typeof existing.size === \"number\" ? existing.size : 0,\n            savedAt: existing.savedAt ?? now,\n          };\n\n          store.put(merged);\n          imported += 1;\n        };\n        getReq.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import image references\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{ projectId, imageData, images }", "type": "{}", "optional": true}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::getImageCountForProject", "name": "getImageCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function getImageCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count images\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlots", "name": "getRunSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlots(projectId) {\n  if (!projectId) return {};\n  const records = await idbGetByProject(projectId);\n  return records.reduce((acc, record) => {\n    acc[record.slotIndex] = stripRunRecord(record);\n    return acc;\n  }, {});\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlot", "name": "getRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlot(projectId, slotIndex) {\n  if (!projectId) return null;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = await idbGet(projectId, normalized);\n  return stripRunRecord(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/runStore.js::saveRunSlot", "name": "saveRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function saveRunSlot(projectId, slotIndex, slotData) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = {\n    projectId,\n    slotIndex: normalized,\n    ...slotData,\n  };\n  await idbSet(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlot", "name": "deleteRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlot(projectId, slotIndex) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  await idbDelete(projectId, normalized);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlotsForProject", "name": "deleteRunSlotsForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlotsForProject(projectId) {\n  if (!projectId) return;\n  await idbDeleteProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "// ============================================================================\n// Storage Operations\n// ============================================================================\n\n/**\n * Get all static pages for a project (both draft and published)\n */\nexport async function getStaticPagesForProject(projectId) {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const req = index.getAll(projectId);\n      req.onsuccess = () => {\n        const pages = req.result || [];\n        pages.sort((a, b) => b.updatedAt - a.updatedAt);\n        resolve(pages);\n      };\n      req.onerror = () => reject(req.error || new Error(\"Failed to get static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::importStaticPages", "name": "importStaticPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Import static pages into a project (used during project import)\n * This replaces all existing pages for the project.\n *\n * @param {string} projectId - The project ID to import pages into\n * @param {Array} pages - Array of page objects to import\n * @param {Object} options - Import options\n * @param {boolean} options.preserveIds - If true, use page IDs from import data\n */\nexport async function importStaticPages(projectId, pages, options = {}) {\n  if (!Array.isArray(pages) || pages.length === 0) {\n    return 0;\n  }\n\n  const db = await openIlluminatorDb();\n  const now = Date.now();\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      let importedCount = 0;\n\n      for (const pageData of pages) {\n        const page = {\n          pageId: options.preserveIds && pageData.pageId ? pageData.pageId : generatePageId(),\n          projectId,\n          title: pageData.title || \"Untitled\",\n          slug: pageData.slug || generateSlug(pageData.title || \"untitled\"),\n          content: pageData.content || \"\",\n          summary: pageData.summary,\n          status: pageData.status || \"draft\",\n          createdAt: pageData.createdAt || now,\n          updatedAt: pageData.updatedAt || now,\n          linkedEntityIds: extractEntityLinks(pageData.content || \"\"),\n          wordCount: countWords(pageData.content || \"\"),\n        };\n\n        store.put(page);\n        importedCount++;\n      }\n\n      tx.oncomplete = () => resolve(importedCount);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import static pages\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "pages", "type": "any[]", "optional": false}, {"name": "options", "type": "{ preserveIds: boolean; }", "optional": true}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Delete all static pages for a project\n */\nexport async function deleteStaticPagesForProject(projectId) {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      for (const page of pages) {\n        store.delete(page.pageId);\n      }\n\n      tx.oncomplete = () => resolve(pages.length);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to delete static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::loadAndImportSeedPages", "name": "loadAndImportSeedPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Load seed pages from staticPages.json and import them\n * Used when reloading defaults\n */\nexport async function loadAndImportSeedPages(projectId, seedPagesUrl) {\n  const url = seedPagesUrl || `${import.meta.env.BASE_URL}default-project/staticPages.json`;\n\n  let seedPages;\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.log(\"No seed pages file found\");\n      return 0;\n    }\n    seedPages = await response.json();\n  } catch (err) {\n    console.log(\"Failed to load seed pages:\", err);\n    return 0;\n  }\n\n  if (!Array.isArray(seedPages) || seedPages.length === 0) {\n    return 0;\n  }\n\n  // Convert seed pages to import format\n  const pagesToImport = seedPages.map((seed) => ({\n    title: seed.title,\n    slug: seed.slug,\n    content: seed.content,\n    summary: seed.summary,\n    status: seed.status || \"published\",\n  }));\n\n  // Clear existing pages and import fresh\n  await deleteStaticPagesForProject(projectId);\n  return importStaticPages(projectId, pagesToImport);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "seedPagesUrl", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadUiState", "name": "loadUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadUiState() {\n  if (!canUseStorage()) return null;\n  try {\n    const raw = localStorage.getItem(UI_STATE_KEY);\n    if (!raw) return null;\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveUiState", "name": "saveUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveUiState(state) {\n  if (!canUseStorage()) return;\n  try {\n    localStorage.setItem(UI_STATE_KEY, JSON.stringify(state));\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "state", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadLastProjectId", "name": "loadLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadLastProjectId() {\n  if (!canUseStorage()) return null;\n  try {\n    return localStorage.getItem(LAST_PROJECT_KEY);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveLastProjectId", "name": "saveLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveLastProjectId(projectId) {\n  if (!canUseStorage()) return;\n  try {\n    if (projectId) {\n      localStorage.setItem(LAST_PROJECT_KEY, projectId);\n    } else {\n      localStorage.removeItem(LAST_PROJECT_KEY);\n    }\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldStore", "name": "loadWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Public API - Core Store Operations\n// =============================================================================\n\n/**\n * Load all persisted data for a project\n */\nexport async function loadWorldStore(projectId) {\n  if (!projectId) return null;\n  let record = null;\n  try {\n    record = await idbGet(projectId);\n  } catch {\n    // Fall back to localStorage\n    record = lsGet(projectId);\n  }\n  if (!record) record = lsGet(projectId);\n  return normalizeWorldStore(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldStore", "name": "saveWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save all data for a project (merges with existing)\n */\nexport async function saveWorldStore(projectId, data) {\n  if (!projectId) return;\n  let existing = null;\n  try {\n    existing = await idbGet(projectId);\n  } catch {\n    existing = null;\n  }\n\n  const merged = { ...(normalizeWorldStore(existing) || { activeSlotIndex: 0 }), ...data };\n  delete merged.projectId;\n  delete merged.slots;\n\n  try {\n    await idbSet(projectId, merged);\n  } catch {\n    const localExisting = normalizeWorldStore(lsGet(projectId)) || { activeSlotIndex: 0 };\n    const localMerged = { ...localExisting, ...data };\n    delete localMerged.slots;\n    lsSet(projectId, localMerged);\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "data", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearWorldStore", "name": "clearWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear all persisted data for a project\n */\nexport async function clearWorldStore(projectId) {\n  if (!projectId) return;\n  try {\n    await idbDelete(projectId);\n  } catch {\n    // Ignore\n  }\n  lsDelete(projectId);\n  await deleteRunSlotsForProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlotIndex", "name": "getActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Slot Operations\n// =============================================================================\n\n/**\n * Get the active slot index for a project\n */\nexport async function getActiveSlotIndex(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.activeSlotIndex ?? 0;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::setActiveSlotIndex", "name": "setActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Set the active slot index for a project\n */\nexport async function setActiveSlotIndex(projectId, slotIndex) {\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlots", "name": "getSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get all slots for a project\n */\nexport async function getSlots(projectId) {\n  await loadWorldStore(projectId);\n  return getRunSlots(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for a specific slot\n */\nexport async function getSlot(projectId, slotIndex) {\n  await loadWorldStore(projectId);\n  return getRunSlot(projectId, slotIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlot", "name": "getActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for the currently active slot\n */\nexport async function getActiveSlot(projectId) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  return getSlot(projectId, activeIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSlot", "name": "saveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to a specific slot\n */\nexport async function saveSlot(projectId, slotIndex, slotData) {\n  await saveRunSlot(projectId, slotIndex, slotData);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToActiveSlot", "name": "saveToActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to the currently active slot (merges with existing slot data)\n */\nexport async function saveToActiveSlot(projectId, slotData) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  const existingSlot = (await getSlot(projectId, activeIndex)) || {};\n  const updatedSlot = { ...existingSlot, ...slotData };\n  await saveRunSlot(projectId, activeIndex, updatedSlot);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToSlot", "name": "saveToSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Move data from scratch (slot 0) to a save slot (1-4)\n * Clears scratch and switches active to the target slot\n */\nexport async function saveToSlot(projectId, targetSlotIndex) {\n  if (targetSlotIndex < 1 || targetSlotIndex > MAX_SAVE_SLOTS) {\n    throw new Error(`Invalid save slot: ${targetSlotIndex}. Must be 1-${MAX_SAVE_SLOTS}`);\n  }\n\n  const scratchData = await getSlot(projectId, 0);\n\n  if (!scratchData || !scratchData.simulationResults) {\n    throw new Error(\"No data in scratch slot to save\");\n  }\n\n  // Generate title if not present\n  const title =\n    scratchData.title && scratchData.title !== \"Scratch\"\n      ? scratchData.title\n      : generateSlotTitle(targetSlotIndex);\n\n  // Move data to target slot\n  await saveRunSlot(projectId, targetSlotIndex, { ...scratchData, title, savedAt: Date.now() });\n  await deleteRunSlot(projectId, 0);\n  await saveWorldStore(projectId, { activeSlotIndex: targetSlotIndex });\n\n  return targetSlotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "targetSlotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSlot", "name": "loadSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load a saved slot by switching active index\n */\nexport async function loadSlot(projectId, slotIndex) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} is empty`);\n  }\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n  return slotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearSlot", "name": "clearSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear a specific slot\n */\nexport async function clearSlot(projectId, slotIndex) {\n  const store = (await loadWorldStore(projectId)) || { activeSlotIndex: 0 };\n  await deleteRunSlot(projectId, slotIndex);\n\n  const slots = await getSlots(projectId);\n\n  // Determine new active slot index\n  let newActiveSlotIndex = store.activeSlotIndex ?? 0;\n  if (newActiveSlotIndex === slotIndex) {\n    // If clearing the active slot:\n    // - If it's slot 0 (scratch), stay on 0 (scratch is conceptually always available)\n    // - Otherwise, switch to scratch (0) or first available slot\n    if (slotIndex === 0) {\n      newActiveSlotIndex = 0;\n    } else {\n      // Find first available slot (prefer scratch if it exists, otherwise first saved slot)\n      const availableSlots = Object.keys(slots)\n        .map(Number)\n        .sort((a, b) => a - b);\n      newActiveSlotIndex = availableSlots.length > 0 ? availableSlots[0] : 0;\n    }\n  }\n\n  await saveWorldStore(projectId, { activeSlotIndex: newActiveSlotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::updateSlotTitle", "name": "updateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Update the title of a slot\n */\nexport async function updateSlotTitle(projectId, slotIndex, title) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} does not exist`);\n  }\n  await saveRunSlot(projectId, slotIndex, { ...slot, title });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "title", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getNextAvailableSlot", "name": "getNextAvailableSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get the next available save slot (1-4), or null if all full\n */\nexport async function getNextAvailableSlot(projectId) {\n  const slots = await getSlots(projectId);\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (!slots[i]) return i;\n  }\n  return null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::generateSlotTitle", "name": "generateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Generate a default title for a slot\n */\nexport function generateSlotTitle(slotIndex, timestamp = Date.now()) {\n  const date = new Date(timestamp);\n  const formatted = date.toLocaleString(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n  return `Run ${slotIndex} - ${formatted}`;\n}", "parameters": [{"name": "slotIndex", "type": "any", "optional": false}, {"name": "timestamp", "type": "number", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSimulationData", "name": "saveSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Convenience methods - operate on active slot\n// =============================================================================\n\n/**\n * Save simulation run data to the active slot\n */\nexport async function saveSimulationData(projectId, { simulationResults, simulationState }) {\n  // Always write new simulations to scratch (slot 0)\n  const existingSlot = (await getSlot(projectId, 0)) || {};\n  const updatedSlot = { ...existingSlot, simulationResults, simulationState };\n  await saveRunSlot(projectId, 0, updatedSlot);\n  await saveWorldStore(projectId, { activeSlotIndex: 0 });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "{ simulationResults, simulationState }", "type": "{ simulationResults: any; simulationState: any; }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSimulationData", "name": "loadSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load simulation run data from the active slot\n */\nexport async function loadSimulationData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return {\n    simulationResults: slot?.simulationResults || null,\n    simulationState: slot?.simulationState || null,\n  };\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<{ simulationResults: any; simulationState: any; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldData", "name": "saveWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save world data to the active slot\n */\nexport async function saveWorldData(projectId, worldData) {\n  await saveToActiveSlot(projectId, { worldData });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldData", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldData", "name": "loadWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load world data from the active slot\n */\nexport async function loadWorldData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return slot?.worldData || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldContext", "name": "saveWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator world context (shared across slots)\n */\nexport async function saveWorldContext(projectId, worldContext) {\n  await saveWorldStore(projectId, { worldContext });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldContext", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldContext", "name": "loadWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator world context\n */\nexport async function loadWorldContext(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.worldContext || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEnrichmentConfig", "name": "saveEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator enrichment config (shared across slots)\n */\nexport async function saveEnrichmentConfig(projectId, enrichmentConfig) {\n  await saveWorldStore(projectId, { enrichmentConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "enrichmentConfig", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadEnrichmentConfig", "name": "loadEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator enrichment config\n */\nexport async function loadEnrichmentConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.enrichmentConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEntityGuidance", "name": "saveEntityGuidance", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save entity guidance (shared across slots)\n */\nexport async function saveEntityGuidance(projectId, entityGuidance) {\n  await saveWorldStore(projectId, { entityGuidance });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "entityGuidance", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveCultureIdentities", "name": "saveCultureIdentities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save culture identities (shared across slots)\n */\nexport async function saveCultureIdentities(projectId, cultureIdentities) {\n  await saveWorldStore(projectId, { cultureIdentities });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "cultureIdentities", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveStyleSelection", "name": "saveStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator style selection (shared across slots)\n */\nexport async function saveStyleSelection(projectId, styleSelection) {\n  await saveWorldStore(projectId, { styleSelection });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "styleSelection", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveHistorianConfig", "name": "saveHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save historian persona config (shared across slots)\n */\nexport async function saveHistorianConfig(projectId, historianConfig) {\n  await saveWorldStore(projectId, { historianConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "historianConfig", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadHistorianConfig", "name": "loadHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load historian persona config\n */\nexport async function loadHistorianConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.historianConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadStyleSelection", "name": "loadStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator style selection\n */\nexport async function loadStyleSelection(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.styleSelection || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./runStore.js", "specifiers": ["getRunSlots", "getRunSlot", "saveRunSlot", "deleteRunSlot", "deleteRunSlotsForProject"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/stores/useCanonryUiStore.js::selectActiveSection", "name": "selectActiveSection", "kind": "function", "filePath": "apps/canonry/webui/src/stores/useCanonryUiStore.js", "sourceCode": "/** Selector for the computed activeSection */\r\nexport function selectActiveSection(s) {\r\n  return s.activeTab ? (s.activeSectionByTab[s.activeTab] ?? null) : null;\r\n}", "parameters": [{"name": "s", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "../storage/uiState", "specifiers": ["loadUiState", "saveUiState"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/ActionsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/ActionsEditor.jsx", "sourceCode": "export default function ActionsEditor({\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"actions:selected\");\n  const {\n    selectedItem: selectedAction,\n    handleItemChange: handleActionChange,\n    handleToggle,\n    handleDelete,\n    handleAdd: handleAddAction,\n    handleSelect,\n    handleClose,\n  } = useEditorState(actions, onChange, { createItem: createAction, persistKey: selectionKey });\n\n  // Collect unique pressures across all actions\n  const uniquePressures = new Set();\n  actions.forEach((action) => {\n    (action.probability?.pressureModifiers || []).forEach((mod) => {\n      if (mod.pressure) uniquePressures.add(mod.pressure);\n    });\n  });\n\n  return (\n    <div className=\"actions-editor\">\n      <div className=\"actions-header\">\n        <h1 className=\"actions-title\">Actions</h1>\n        <p className=\"actions-subtitle\">\n          Actions define what agents can do during the simulation via the universal catalyst system.\n          Click an action to edit.\n        </p>\n        <div className=\"actions-stats\">\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Total Actions</span>\n            <span className=\"actions-stat-value\">{actions.length}</span>\n          </div>\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Pressures Referenced</span>\n            <span className=\"actions-stat-value\">{uniquePressures.size}</span>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"actions-grid\">\n        {actions.map((action, index) => (\n          <ActionListCard\n            key={action.id}\n            action={action}\n            onClick={() => handleSelect(index)}\n            onToggle={() => handleToggle(action)}\n            usageMap={usageMap}\n          />\n        ))}\n\n        <div className=\"actions-add-card\" onClick={() => handleAddAction()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <span className=\"text-2xl\">+</span>\n          <span>Add Action</span>\n        </div>\n      </div>\n\n      {selectedAction && (\n        <ActionModal\n          action={selectedAction}\n          onChange={handleActionChange}\n          onClose={handleClose}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; actions?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/CausalLoopEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/CausalLoopEditor.jsx", "sourceCode": "export default function CausalLoopEditor({\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}) {\n  const containerRef = useRef(null);\n  const graphRef = useRef(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [showLegend, setShowLegend] = useState(true);\n  const [showDisabled, setShowDisabled] = useState(true);\n  const [hoverNode, setHoverNode] = useState(null);\n\n  // Resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const updateDimensions = () => {\n      const rect = containerRef.current.getBoundingClientRect();\n      setDimensions({\n        width: rect.width || 800,\n        height: Math.max(500, window.innerHeight - rect.top - 100),\n      });\n    };\n\n    updateDimensions();\n    const observer = new ResizeObserver(updateDimensions);\n    observer.observe(containerRef.current);\n    window.addEventListener(\"resize\", updateDimensions);\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, []);\n\n  // Extract graph data\n  const {\n    nodes: graphNodes,\n    links: graphLinks,\n    warnings,\n  } = useMemo(\n    () =>\n      extractCausalGraph(pressures, generators, systems, actions, schema, showDisabled, usageMap),\n    [pressures, generators, systems, actions, schema, showDisabled, usageMap]\n  );\n  const graphData = useMemo(\n    () => ({ nodes: graphNodes, links: graphLinks }),\n    [graphNodes, graphLinks]\n  );\n\n  // Count disabled nodes for UI\n  const disabledCount = useMemo(() => {\n    const allNodes = extractCausalGraph(\n      pressures,\n      generators,\n      systems,\n      actions,\n      schema,\n      true,\n      usageMap\n    ).nodes;\n    return allNodes.filter((n) => n.isDisabled).length;\n  }, [pressures, generators, systems, actions, schema, usageMap]);\n\n  // Detect loops\n  const loops = useMemo(() => detectLoops(graphData.nodes, graphData.links), [graphData]);\n\n  const reinforcingLoops = loops.filter((l) => l.type === \"reinforcing\");\n  const balancingLoops = loops.filter((l) => l.type === \"balancing\");\n\n  // Node styling\n  const nodeCanvasObject = useCallback(\n    (node, ctx, globalScale) => {\n      const label = node.label;\n      const fontSize = Math.max(10 / globalScale, 3);\n      const abbrevFontSize = Math.max(8 / globalScale, 3);\n      const nodeRadius = Math.sqrt(node.val) * 3;\n      const isDisabled = node.isDisabled;\n\n      // Draw node circle with opacity for disabled\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = isDisabled ? `${node.color}60` : node.color;\n      ctx.fill();\n\n      // Strikethrough pattern for disabled nodes\n      if (isDisabled) {\n        ctx.strokeStyle = \"#64748b\";\n        ctx.lineWidth = 1 / globalScale;\n        ctx.setLineDash([2 / globalScale, 2 / globalScale]);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // Highlight selected/hovered\n      if (selectedNode === node.id || hoverNode === node.id) {\n        ctx.strokeStyle = \"#ffffff\";\n        ctx.lineWidth = 2 / globalScale;\n        ctx.stroke();\n      }\n\n      // Draw abbreviation inside node\n      ctx.font = `bold ${abbrevFontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#0a1929\";\n      ctx.fillText(node.abbrev || \"?\", node.x, node.y);\n\n      // Draw label below node\n      ctx.font = `${fontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"top\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#e2e8f0\";\n      const displayLabel = label.length > 15 ? label.slice(0, 13) + \"...\" : label;\n      ctx.fillText(displayLabel, node.x, node.y + nodeRadius + 2);\n    },\n    [selectedNode, hoverNode]\n  );\n\n  // Link styling\n  const linkColor = useCallback((link) => {\n    return EDGE_COLORS[link.polarity] || EDGE_COLORS.neutral;\n  }, []);\n\n  const linkWidth = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? 1 : 2;\n  }, []);\n\n  const linkLineDash = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? [4, 4] : [];\n  }, []);\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node) => {\n      setSelectedNode(selectedNode === node.id ? null : node.id);\n    },\n    [selectedNode]\n  );\n\n  // Zoom to fit on load\n  useEffect(() => {\n    if (graphRef.current && graphData.nodes.length > 0) {\n      setTimeout(() => {\n        graphRef.current.zoomToFit(400, 60);\n      }, 500);\n    }\n  }, [graphData.nodes.length]);\n\n  const selectedNodeData = selectedNode ? graphData.nodes.find((n) => n.id === selectedNode) : null;\n\n  // Get edges for selected node\n  const selectedNodeEdges = useMemo(() => {\n    if (!selectedNode) return { incoming: [], outgoing: [] };\n    return {\n      incoming: graphData.links.filter((l) => {\n        const targetId = typeof l.target === \"object\" ? l.target.id : l.target;\n        return targetId === selectedNode;\n      }),\n      outgoing: graphData.links.filter((l) => {\n        const sourceId = typeof l.source === \"object\" ? l.source.id : l.source;\n        return sourceId === selectedNode;\n      }),\n    };\n  }, [selectedNode, graphData.links]);\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Causal Loop Diagram</h1>\n        <p className=\"subtitle\">\n          Visualize feedback loops between pressures, generators, systems, and entity kinds.\n          {loops.length > 0 && (\n            <span className=\"cl-loop-count\">\n              <span className=\"cl-loop-reinforcing\">{reinforcingLoops.length} reinforcing</span>\n              {\" / \"}\n              <span className=\"cl-loop-balancing\">{balancingLoops.length} balancing</span>\n              {\" loops detected\"}\n            </span>\n          )}\n        </p>\n      </div>\n\n      <div className=\"cl-toolbar\">\n        <button className=\"button-secondary\" onClick={() => setShowLegend(!showLegend)}>\n          {showLegend ? \"Hide\" : \"Show\"} Legend\n        </button>\n        {disabledCount > 0 && (\n          <button\n            className=\"button-secondary\"\n            onClick={() => setShowDisabled(!showDisabled)}\n            // eslint-disable-next-line local/no-inline-styles -- dynamic opacity toggle\n            style={{ opacity: showDisabled ? 1 : 0.7 }}\n          >\n            {showDisabled ? \"Hide\" : \"Show\"} Disabled ({disabledCount})\n          </button>\n        )}\n        <button className=\"button-secondary\" onClick={() => graphRef.current?.zoomToFit(400, 60)}>\n          Fit to View\n        </button>\n        <div className=\"cl-stats\">\n          <span>{graphData.nodes.length} nodes</span>\n          <span>{graphData.links.length} edges</span>\n          {warnings.length > 0 && (\n            <span className=\"cl-stats-warning\">{warnings.length} warnings</span>\n          )}\n          <span className=\"cl-stats-hint\">Scroll to zoom, drag to pan</span>\n        </div>\n      </div>\n\n      {/* Warnings */}\n      {warnings.length > 0 && (\n        <div className=\"cl-warnings-box\">\n          <div className=\"cl-warnings-title\">\n            Referential Integrity Warnings\n          </div>\n          <div className=\"cl-warnings-list\">\n            {warnings.slice(0, 5).map((w, i) => (\n              <div key={i}>{w.message}</div>\n            ))}\n            {warnings.length > 5 && (\n              <div className=\"cl-warnings-more\">\n                ...and {warnings.length - 5} more warnings\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Legend */}\n      {showLegend && (\n        <div className=\"cl-legend\">\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Nodes:</span>\n            {Object.entries(NODE_TYPES).map(([type, config]) => (\n              <span key={type} className=\"cl-legend-item\">\n                <span\n                  className=\"cl-legend-node\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic color per node type\n                  style={{ '--cl-node-color': config.color, backgroundColor: 'var(--cl-node-color)' }}\n                >\n                  {config.abbrev}\n                </span>\n                <span className=\"cl-legend-node-label\">{config.label}</span>\n              </span>\n            ))}\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Edges:</span>\n            <span className=\"cl-legend-item cl-edge-positive\">+ Positive</span>\n            <span className=\"cl-legend-item cl-edge-negative\">- Negative</span>\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Loops:</span>\n            <span className=\"cl-legend-item cl-loop-reinforcing\">Reinforcing (unstable)</span>\n            <span className=\"cl-legend-item cl-loop-balancing\">Balancing (stable)</span>\n          </div>\n        </div>\n      )}\n\n      {/* Graph container */}\n      <div ref={containerRef} className=\"cl-graph-container\">\n        {graphData.nodes.length === 0 ? (\n          <div className=\"cl-empty-state\">\n            <div className=\"cl-empty-icon\">&#128260;</div>\n            <div className=\"cl-empty-title\">\n              No causal relationships found\n            </div>\n            <div className=\"cl-empty-desc\">\n              Add pressures with feedback factors, generators with state updates, or systems with\n              pressure changes to see the causal loop diagram.\n            </div>\n          </div>\n        ) : (\n          <ForceGraph2D\n            ref={graphRef}\n            graphData={graphData}\n            width={dimensions.width}\n            height={dimensions.height}\n            backgroundColor=\"#0f172a\"\n            nodeCanvasObject={nodeCanvasObject}\n            nodePointerAreaPaint={(node, color, ctx) => {\n              const nodeRadius = Math.sqrt(node.val) * 3;\n              ctx.beginPath();\n              ctx.arc(node.x, node.y, nodeRadius + 5, 0, 2 * Math.PI);\n              ctx.fillStyle = color;\n              ctx.fill();\n            }}\n            linkColor={linkColor}\n            linkWidth={linkWidth}\n            linkLineDash={linkLineDash}\n            linkDirectionalArrowLength={6}\n            linkDirectionalArrowRelPos={0.9}\n            linkCurvature={0.2}\n            onNodeClick={handleNodeClick}\n            onNodeHover={(node) => setHoverNode(node?.id || null)}\n// ... (truncated)", "parameters": [{"name": "{\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}", "type": "{ pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; schema?: {}; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/DependencyViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/DependencyViewer.jsx", "sourceCode": "export default function DependencyViewer({ usageMap }) {\n  // Prepare entity kinds data\n  const entityKindsData = useMemo(() => {\n    if (!usageMap?.entityKinds) return [];\n    return Object.entries(usageMap.entityKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare relationship kinds data\n  const relationshipKindsData = useMemo(() => {\n    if (!usageMap?.relationshipKinds) return [];\n    return Object.entries(usageMap.relationshipKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare pressures data\n  const pressuresData = useMemo(() => {\n    if (!usageMap?.pressures) return [];\n    return Object.entries(usageMap.pressures)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare generators data\n  const generatorsData = useMemo(() => {\n    if (!usageMap?.generators) return [];\n    return Object.entries(usageMap.generators)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare systems data\n  const systemsData = useMemo(() => {\n    if (!usageMap?.systems) return [];\n    return Object.entries(usageMap.systems)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare tags data\n  const tagsData = useMemo(() => {\n    if (!usageMap?.tags) return [];\n    return Object.entries(usageMap.tags)\n      .map(([tag, usage]) => ({\n        id: tag,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  if (!usageMap) {\n    return (\n      <div className=\"dependency-viewer-container\">\n        <div className=\"dependency-empty-state\">Loading dependency data...</div>\n      </div>\n    );\n  }\n\n  const renderSchemaItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      <UsageBadges usage={item.usage} />\n    </div>\n  );\n\n  const renderEraItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      {item.eraCount > 0 ? (\n        <div className=\"dependency-used-by-list\">\n          <span className=\"dependency-badge dependency-badge-era\">\n            {item.eraCount} era{item.eraCount !== 1 ? \"s\" : \"\"}\n          </span>\n        </div>\n      ) : (\n        <span className=\"dependency-orphan-badge\">Not in any era</span>\n      )}\n    </div>\n  );\n\n  return (\n    <div className=\"dependency-viewer-container\">\n      <div className=\"dependency-viewer-header\">\n        <div className=\"dependency-viewer-title\">\n          <span>\ud83d\udd17</span>\n          <span>Dependencies</span>\n        </div>\n        <div className=\"dependency-viewer-legend\">\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-generators\" />\n            <span>Generators</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-systems\" />\n            <span>Systems</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-actions\" />\n            <span>Actions</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-eras\" />\n            <span>Eras</span>\n          </div>\n        </div>\n      </div>\n\n      <DependencySection\n        title=\"Entity Kinds\"\n        icon=\"\ud83d\udce6\"\n        items={entityKindsData}\n        renderItem={renderSchemaItem}\n        defaultExpanded={true}\n      />\n\n      <DependencySection\n        title=\"Relationship Kinds\"\n        icon=\"\ud83d\udd17\"\n        items={relationshipKindsData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection title=\"Tags\" icon=\"\ud83c\udff7\ufe0f\" items={tagsData} renderItem={renderSchemaItem} />\n\n      <DependencySection\n        title=\"Pressures\"\n        icon=\"\ud83d\udcca\"\n        items={pressuresData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection\n        title=\"Generators \u2192 Eras\"\n        icon=\"\u2728\"\n        items={generatorsData}\n        renderItem={renderEraItem}\n      />\n\n      <DependencySection\n        title=\"Systems \u2192 Eras\"\n        icon=\"\u2699\ufe0f\"\n        items={systemsData}\n        renderItem={renderEraItem}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ usageMap }", "type": "{ usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/GeneratorsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/GeneratorsEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.generators - Array of generator configurations\n * @param {Function} props.onChange - Callback when generators change\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport default function GeneratorsEditor({\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"generators:selected\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [expandedCategories, setExpandedCategories] = useState({});\n\n  // Derive selected generator from index - this ensures we always have the latest data\n  const resolvedIndex = selectedId ? generators.findIndex((g) => g.id === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedGenerator = selectedIndex !== null ? generators[selectedIndex] : null;\n\n  // Build entity kind info map for icons and labels\n  const entityKindInfo = useMemo(() => {\n    const info = {};\n    (schema?.entityKinds || []).forEach((ek) => {\n      info[ek.kind] = {\n        label: ek.description || ek.name || ek.kind,\n        icon: ek.icon || DEFAULT_KIND_ICONS[ek.kind] || \"\ud83d\udce6\",\n      };\n    });\n    return info;\n  }, [schema]);\n\n  // Group generators by the primary entity kind they create\n  const groupedGenerators = useMemo(() => {\n    const groups = {};\n\n    generators.forEach((generator) => {\n      // Get primary creation kind (first entity created, or target kind if no creation)\n      const createdKinds = (generator.creation || []).map((c) => c.kind).filter(Boolean);\n      const primaryKind = createdKinds[0] || generator.selection?.kind || \"uncategorized\";\n\n      if (!groups[primaryKind]) {\n        groups[primaryKind] = [];\n      }\n      groups[primaryKind].push(generator);\n    });\n\n    return groups;\n  }, [generators]);\n\n  // Get ordered list of categories\n  const categories = useMemo(() => {\n    // Order by schema entity kinds first, then any uncategorized\n    const schemaKinds = (schema?.entityKinds || []).map((ek) => ek.kind);\n    const usedKinds = Object.keys(groupedGenerators);\n\n    // Sort: schema kinds in order, then others alphabetically\n    return usedKinds.sort((a, b) => {\n      const aIdx = schemaKinds.indexOf(a);\n      const bIdx = schemaKinds.indexOf(b);\n      if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;\n      if (aIdx >= 0) return -1;\n      if (bIdx >= 0) return 1;\n      return a.localeCompare(b);\n    });\n  }, [groupedGenerators, schema]);\n\n  // Initialize expanded state for new categories\n  useEffect(() => {\n    const needsUpdate = categories.some((cat) => expandedCategories[cat] === undefined);\n    if (!needsUpdate) return;\n    const updated = { ...expandedCategories };\n    categories.forEach((cat) => {\n      if (updated[cat] === undefined) {\n        updated[cat] = true;\n      }\n    });\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync category expansion defaults when categories change\n    setExpandedCategories(updated);\n  }, [categories, expandedCategories]);\n\n  // Restore selectedId from storage when selectionKey changes\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!selectionKey) return;\n    if (selectedId) {\n      saveStoredValue(selectionKey, selectedId);\n    } else {\n      clearStoredValue(selectionKey);\n    }\n  }, [selectionKey, selectedId]);\n\n  // Clear invalid selectedId (during render)\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n    clearStoredValue(selectionKey);\n  }\n\n  const handleGeneratorChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex < generators.length) {\n        const newGenerators = [...generators];\n        newGenerators[selectedIndex] = updated;\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (generator) => {\n      const index = generators.findIndex((g) => g.id === generator.id);\n      if (index >= 0) {\n        const newGenerators = [...generators];\n        newGenerators[index] = {\n          ...generator,\n          enabled: generator.enabled === false ? true : false,\n        };\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedGenerator &&\n      confirm(`Delete generator \"${selectedGenerator.name || selectedGenerator.id}\"?`)\n    ) {\n      const newGenerators = [...generators];\n      newGenerators.splice(selectedIndex, 1);\n      onChange(newGenerators);\n      setSelectedId(null);\n    }\n  }, [generators, onChange, selectedIndex, selectedGenerator]);\n\n  const handleAdd = useCallback(() => {\n    const newGenerator = {\n      id: `generator_${Date.now()}`,\n      name: \"New Generator\",\n      applicability: [],\n      selection: { strategy: \"by_kind\", kind: \"location\", pickStrategy: \"random\" },\n      creation: [],\n      relationships: [],\n      stateUpdates: [],\n      variables: {},\n    };\n    onChange([...generators, newGenerator]);\n    setSelectedId(newGenerator.id);\n  }, [generators, onChange]);\n\n  const handleDuplicate = useCallback(() => {\n    if (!selectedGenerator) return;\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(selectedGenerator)), // Deep clone\n      id: `${selectedGenerator.id}_copy_${Date.now()}`,\n      name: `${selectedGenerator.name || selectedGenerator.id} (Copy)`,\n    };\n    onChange([...generators, duplicated]);\n    setSelectedId(duplicated.id);\n  }, [generators, onChange, selectedGenerator]);\n\n  const toggleCategoryExpand = useCallback((kind) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [kind]: !prev[kind],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (kind) => {\n      const categoryItems = groupedGenerators[kind] || [];\n      const allEnabled = categoryItems.every((g) => g.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of generators in this category\n      const categoryIds = new Set(categoryItems.map((g) => g.id));\n\n      const newGenerators = generators.map((g) => {\n        if (categoryIds.has(g.id)) {\n          return { ...g, enabled: newEnabled };\n        }\n        return g;\n      });\n      onChange(newGenerators);\n    },\n    [generators, groupedGenerators, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Generators</h1>\n        <p className=\"subtitle\">\n          Configure entity generators that populate your world. Click a generator to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((kind) => {\n        const kindInfo = entityKindInfo[kind] || {\n          label: kind.charAt(0).toUpperCase() + kind.slice(1),\n          icon: DEFAULT_KIND_ICONS[kind] || \"\ud83d\udce6\",\n        };\n        const categoryItems = groupedGenerators[kind] || [];\n        const allEnabled = categoryItems.every((g) => g.enabled !== false);\n\n        return (\n          <CategorySection\n            key={kind}\n            id={kind}\n            icon={kindInfo.icon}\n            label={`${kindInfo.label} Generators`}\n            items={categoryItems}\n            expanded={expandedCategories[kind] !== false}\n            onToggleExpand={() => toggleCategoryExpand(kind)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(kind)}\n            renderItem={(generator) => (\n              <GeneratorListCard\n                key={generator.id}\n                generator={generator}\n                onClick={() => setSelectedId(generator.id)}\n                onToggle={() => handleToggle(generator)}\n                usageMap={usageMap}\n              />\n            )}\n          />\n        );\n      })}\n\n      {/* Add Generator button */}\n      <div className=\"mt-lg\">\n        <AddCard onClick={handleAdd} label=\"Add Generator\" />\n      </div>\n\n      {selectedGenerator && (\n        <GeneratorModal\n          generator={selectedGenerator}\n          onChange={handleGeneratorChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          schema={schema}\n          pressures={pressures}\n          eras={eras}\n          usageMap={usageMap}\n          tagRegistry={schema.tagRegistry || []}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}", "type": "{ generators: any[]; onChange: Function; schema: any; pressures: any[]; eras: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/NamingProfileMappingViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/NamingProfileMappingViewer.jsx", "sourceCode": "export default function NamingProfileMappingViewer({ generators = [], schema = {} }) {\n  const [showInherited, setShowInherited] = useState(false);\n\n  const { mappings, warnings } = useMemo(\n    () => analyzeNamingMappings(generators, schema),\n    [generators, schema]\n  );\n\n  // Group by generator for display\n  const groupedMappings = useMemo(() => {\n    const groups = {};\n    for (const m of mappings) {\n      if (!groups[m.generatorId]) {\n        groups[m.generatorId] = {\n          generatorId: m.generatorId,\n          generatorName: m.generatorName,\n          items: [],\n        };\n      }\n      groups[m.generatorId].items.push(m);\n    }\n    return Object.values(groups);\n  }, [mappings]);\n\n  // Filter warnings - show all by default, but can filter to just explicit cultures\n  const displayWarnings = showInherited\n    ? warnings\n    : warnings.filter(\n        (w) => w.cultureSource === \"explicit\" || w.reason === \"No matching strategy group\"\n      );\n\n  const successCount = mappings.filter((m) => m.match).length;\n  const warningCount = warnings.filter((w) => w.reason === \"No matching strategy group\").length;\n\n  if (mappings.length === 0) {\n    return (\n      <div className=\"naming-profile-container\">\n        <div className=\"naming-profile-header\">\n          <div className=\"naming-profile-title\">\n            <span>Naming Profile Mappings</span>\n          </div>\n        </div>\n        <div className=\"naming-profile-empty-state\">\n          No generators with entity creation defined. Add generators to see naming profile mappings.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"naming-profile-container\">\n      <div className=\"naming-profile-header\">\n        <div className=\"naming-profile-title\">\n          <span>Naming Profile Mappings</span>\n        </div>\n        <div className=\"naming-profile-stats\">\n          <div className=\"naming-profile-stat-item\">\n            <span className=\"naming-profile-stat-value text-success\">{successCount}</span>\n            <span>matched</span>\n          </div>\n          <div className=\"naming-profile-stat-item\">\n            <span\n              className={`naming-profile-stat-value ${warningCount > 0 ? \"text-danger\" : \"text-muted\"}`}\n            >\n              {warningCount}\n            </span>\n            <span>missing</span>\n          </div>\n          <label className=\"cursor-pointer flex items-center gap-xs\">\n            <input\n              type=\"checkbox\"\n              checked={showInherited}\n              onChange={(e) => setShowInherited(e.target.checked)}\n            />\n            <span>Show inherited cultures</span>\n          </label>\n        </div>\n      </div>\n\n      <div className=\"naming-profile-content\">\n        {/* Warnings section */}\n        {displayWarnings.length > 0 && (\n          <div className=\"naming-profile-section\">\n            <div className=\"naming-profile-section-title\">\n              <span className=\"naming-profile-warning-icon\">Warning</span>\n              <span>Naming May Fail ({displayWarnings.length})</span>\n            </div>\n            <div className=\"naming-profile-warning-list\">\n              {displayWarnings.slice(0, 10).map((w, i) => (\n                <div\n                  key={`${w.generatorId}-${w.cultureId}-${i}`}\n                  className=\"naming-profile-warning-item\"\n                >\n                  <span className=\"naming-profile-warning-icon\">!</span>\n                  <span>\n                    <strong>{w.generatorName}</strong> creates <strong>{w.entityKind}</strong>\n                    {w.subtype && `:${w.subtype}`} for culture <strong>{w.cultureName}</strong> -{\" \"}\n                    {w.reason}\n                  </span>\n                </div>\n              ))}\n              {displayWarnings.length > 10 && (\n                <div\n                  className=\"text-muted py-md px-lg\"\n                >\n                  ... and {displayWarnings.length - 10} more\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Mappings table */}\n        <div className=\"naming-profile-section\">\n          <div className=\"naming-profile-section-title\">\n            <span>Entity Creation to Naming Profile</span>\n          </div>\n          <table className=\"naming-profile-mapping-table\">\n            <thead>\n              <tr>\n                <th className=\"naming-profile-table-header\">Generator</th>\n                <th className=\"naming-profile-table-header\">Entity Kind</th>\n                <th className=\"naming-profile-table-header\">Culture</th>\n                <th className=\"naming-profile-table-header\">Naming Profile</th>\n              </tr>\n            </thead>\n            <tbody>\n              {groupedMappings.slice(0, 20).flatMap((group) => {\n                // Filter items based on showInherited toggle\n                const filteredItems = showInherited\n                  ? group.items\n                  : group.items.filter(\n                      (m) => m.cultureSource === \"explicit\" || m.cultureSource === \"any\"\n                    );\n                // If no explicit cultures, show first inherited one as representative\n                const displayItems =\n                  filteredItems.length > 0 ? filteredItems : group.items.slice(0, 1);\n                return displayItems.map((m, idx) => (\n                  <tr\n                    key={`${m.generatorId}-${m.cultureId}-${m.entityKind}-${idx}`}\n                    className={`naming-profile-table-row ${!m.match && m.hasNamingProfile ? \"naming-profile-warning-row\" : \"\"}`}\n                  >\n                    <td className=\"naming-profile-table-cell naming-profile-generator-cell\">\n                      {idx === 0 ? m.generatorName : \"\"}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <span className=\"naming-profile-kind-badge\">{m.entityKind}</span>\n                      {m.subtype && (\n                        <span\n                          className=\"naming-profile-kind-badge naming-profile-kind-badge-transparent\"\n                        >\n                          {m.subtype}\n                        </span>\n                      )}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <div className=\"naming-profile-culture-cell\">\n                        {/* eslint-disable-next-line local/no-inline-styles -- dynamic culture color */}\n                        <span\n                          className=\"naming-profile-culture-dot\"\n                          style={{ '--npm-culture-color': m.cultureColor, backgroundColor: 'var(--npm-culture-color)' }}\n                        />\n                        <span>{m.cultureName}</span>\n                        {m.cultureSource === \"inherited\" && (\n                          <span className=\"naming-profile-badge naming-profile-badge-inherited\">\n                            inherited\n                          </span>\n                        )}\n                      </div>\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      {m.match && (\n                        <span className=\"naming-profile-badge naming-profile-badge-match\">\n                          {m.match.profileName || m.match.profileId}\n                          {m.match.groupName && ` / ${m.match.groupName}`}\n                        </span>\n                      )}\n                      {!m.match && !m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No profiles configured\n                        </span>\n                      )}\n                      {!m.match && m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No matching group\n                        </span>\n                      )}\n                    </td>\n                  </tr>\n                ));\n              })}\n            </tbody>\n          </table>\n          {groupedMappings.length > 20 && (\n            <div className=\"text-muted text-center text-xs p-md\">\n              Showing first 20 generators. Total: {groupedMappings.length}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generators = [], schema = {} }", "type": "{ generators?: any[]; schema?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/PressuresEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/PressuresEditor.jsx", "sourceCode": "export default function PressuresEditor({ projectId, pressures = [], onChange, schema, usageMap }) {\n  const [expandedPressure, setExpandedPressure] = useState(null);\n  const factorModalKey = buildStorageKey(projectId, \"pressures:factorModal\");\n  const restoredRef = useRef(false);\n\n  useEffect(() => {\n    restoredRef.current = false;\n  }, [factorModalKey]);\n\n  // Restore expanded pressure from storage (one-time per modal key)\n  useEffect(() => {\n    if (restoredRef.current || !factorModalKey || pressures.length === 0) return;\n\n    const stored = loadStoredValue(factorModalKey);\n    if (stored?.pressureId) {\n      const index = pressures.findIndex((pressure) => pressure.id === stored.pressureId);\n      if (index >= 0) {\n        // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted UI expansion state\n        setExpandedPressure(index);\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    }\n    restoredRef.current = true;\n  }, [factorModalKey, pressures]);\n\n  const handlePressureChange = useCallback(\n    (index, updatedPressure) => {\n      const newPressures = [...pressures];\n      newPressures[index] = updatedPressure;\n      onChange(newPressures);\n    },\n    [pressures, onChange]\n  );\n\n  const handleDeletePressure = useCallback(\n    (index) => {\n      if (confirm(`Delete \"${pressures[index].name}\"?`)) {\n        const newPressures = pressures.filter((_, i) => i !== index);\n        onChange(newPressures);\n        if (expandedPressure === index) {\n          setExpandedPressure(null);\n        }\n      }\n    },\n    [pressures, onChange, expandedPressure]\n  );\n\n  const handleAddPressure = useCallback(() => {\n    const newPressure = {\n      id: `pressure_${Date.now()}`,\n      name: \"New Pressure\",\n      initialValue: 0,\n      homeostasis: 0.05,\n      description: \"\",\n      growth: {\n        positiveFeedback: [],\n        negativeFeedback: [],\n      },\n    };\n    onChange([...pressures, newPressure]);\n    setExpandedPressure(pressures.length);\n  }, [pressures, onChange]);\n\n  if (pressures.length === 0) {\n    return (\n      <div className=\"editor-container\">\n        <div className=\"header\">\n          <h1 className=\"title\">Pressures</h1>\n          <p className=\"subtitle\">\n            Configure environmental and social pressures that drive world evolution\n          </p>\n        </div>\n        <div className=\"empty-state\">\n          <div className=\"empty-state-icon\">\ud83c\udf21\ufe0f</div>\n          <div className=\"pe-empty-title\">\n            No pressures defined\n          </div>\n          <div className=\"pe-empty-desc\">\n            Pressures respond to world state with feedback and a pull toward equilibrium, driving\n            the narrative forward.\n          </div>\n          <button\n            className=\"btn btn-primary pe-create-btn\"\n            onClick={handleAddPressure}\n          >\n            + Create First Pressure\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Pressures</h1>\n        <p className=\"subtitle\">\n          Configure environmental and social pressures that drive world evolution. Each pressure has\n          feedback factors that make it grow or shrink based on world state plus a homeostatic pull\n          toward equilibrium.\n        </p>\n      </div>\n\n      <div className=\"list-stack\">\n        {pressures.map((pressure, index) => (\n          <PressureCard\n            key={index}\n            pressure={pressure}\n            expanded={expandedPressure === index}\n            onToggle={() => setExpandedPressure(expandedPressure === index ? null : index)}\n            onChange={(updatedPressure) => handlePressureChange(index, updatedPressure)}\n            onDelete={() => handleDeletePressure(index)}\n            schema={schema}\n            usageMap={usageMap}\n            projectId={projectId}\n          />\n        ))}\n\n        <button className=\"btn btn-add\" onClick={handleAddPressure}>\n          + Add Pressure\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, pressures = [], onChange, schema, usageMap }", "type": "{ projectId: any; pressures?: any[]; onChange: any; schema: any; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/SystemsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/SystemsEditor.jsx", "sourceCode": "export default function SystemsEditor({\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"systems:selected\");\n  const typePickerKey = buildStorageKey(projectId, \"systems:typePicker\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [showTypePicker, setShowTypePicker] = useState(\n    () => loadStoredValue(typePickerKey) === true\n  );\n\n  // Derive selectedSystem from index\n  const resolvedIndex = selectedId\n    ? systems.findIndex((system) => system.config?.id === selectedId)\n    : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedSystem = selectedIndex !== null ? systems[selectedIndex] : null;\n  const [expandedCategories, setExpandedCategories] = useState(() => {\n    // Start with all categories expanded\n    return Object.keys(SYSTEM_CATEGORIES).reduce((acc, cat) => {\n      acc[cat] = true;\n      return acc;\n    }, {});\n  });\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowTypePicker(false);\n    }\n  }, []);\n\n  // Group systems by category (framework systems grouped together)\n  const groupedSystems = useMemo(() => {\n    const groups = {};\n    systems.forEach((system) => {\n      const category = getSystemCategory(system.systemType || \"unknown\");\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(system);\n    });\n    return groups;\n  }, [systems]);\n\n  // Get ordered list of categories that have systems\n  const categories = useMemo(() => {\n    const usedCategories = Object.keys(groupedSystems);\n    // Sort by defined order in SYSTEM_CATEGORIES\n    return usedCategories.sort((a, b) => {\n      const orderA = SYSTEM_CATEGORIES[a]?.order ?? 999;\n      const orderB = SYSTEM_CATEGORIES[b]?.order ?? 999;\n      return orderA - orderB;\n    });\n  }, [groupedSystems]);\n\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  useEffect(() => {\n    setShowTypePicker(loadStoredValue(typePickerKey) === true);\n  }, [typePickerKey]);\n\n  useEffect(() => {\n    if (selectionKey) {\n      if (selectedId) {\n        saveStoredValue(selectionKey, selectedId);\n      } else {\n        clearStoredValue(selectionKey);\n      }\n    }\n  }, [selectionKey, selectedId]);\n\n  useEffect(() => {\n    if (typePickerKey) {\n      if (showTypePicker) {\n        saveStoredValue(typePickerKey, true);\n      } else {\n        clearStoredValue(typePickerKey);\n      }\n    }\n  }, [typePickerKey, showTypePicker]);\n\n  useEffect(() => {\n    if (selectedId && selectedIndex === null) {\n      setSelectedId(null);\n      clearStoredValue(selectionKey);\n    }\n  }, [selectedId, selectedIndex, selectionKey]);\n\n  const handleSystemChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex >= 0 && selectedIndex < systems.length) {\n        const newSystems = [...systems];\n        newSystems[selectedIndex] = updated;\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (system) => {\n      const index = systems.findIndex((s) => s.config?.id === system.config?.id);\n      if (index >= 0) {\n        const newSystems = [...systems];\n        newSystems[index] = { ...system, enabled: system.enabled === false ? true : false };\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedSystem &&\n      confirm(`Delete system \"${selectedSystem.config?.name || selectedSystem.config?.id}\"?`)\n    ) {\n      const newSystems = systems.filter((_, i) => i !== selectedIndex);\n      onChange(newSystems);\n      setSelectedId(null);\n    }\n  }, [systems, onChange, selectedIndex, selectedSystem]);\n\n  const handleAddSystem = useCallback(\n    (type) => {\n      const needsSelection = [\n        \"graphContagion\",\n        \"connectionEvolution\",\n        \"thresholdTrigger\",\n        \"clusterFormation\",\n        \"tagDiffusion\",\n        \"planeDiffusion\",\n      ].includes(type);\n      const newSystem = {\n        systemType: type,\n        config: {\n          id: `system_${Date.now()}`,\n          name: `New ${SYSTEM_TYPES[type]?.label || type}`,\n          description: \"\",\n          ...(needsSelection ? { selection: { strategy: \"by_kind\", kind: \"any\" } } : {}),\n        },\n      };\n      onChange([...systems, newSystem]);\n      setSelectedId(newSystem.config.id);\n      setShowTypePicker(false);\n    },\n    [systems, onChange]\n  );\n\n  const toggleCategoryExpand = useCallback((type) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [type]: !prev[type],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (category) => {\n      const categoryItems = groupedSystems[category] || [];\n      const allEnabled = categoryItems.every((s) => s.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of systems in this category\n      const categoryIds = new Set(categoryItems.map((s) => s.config?.id));\n\n      const newSystems = systems.map((s) => {\n        if (categoryIds.has(s.config?.id)) {\n          return { ...s, enabled: newEnabled };\n        }\n        return s;\n      });\n      onChange(newSystems);\n    },\n    [systems, groupedSystems, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Systems</h1>\n        <p className=\"subtitle\">\n          Configure simulation systems that run during the simulation phase. Click a system to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((category) => {\n        const categoryConfig = SYSTEM_CATEGORIES[category] || { icon: \"\u2699\ufe0f\", label: category };\n        const categoryItems = groupedSystems[category] || [];\n        const allEnabled = categoryItems.every((s) => s.enabled !== false);\n\n        return (\n          <CategorySection\n            key={category}\n            id={category}\n            icon={categoryConfig.icon}\n            label={categoryConfig.label}\n            items={categoryItems}\n            expanded={expandedCategories[category] !== false}\n            onToggleExpand={() => toggleCategoryExpand(category)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(category)}\n            gridClassName=\"list-grid\"\n            renderItem={(system) => {\n              const flatIndex = systems.findIndex((s) => s.config?.id === system.config?.id);\n              return (\n                <SystemListCard\n                  key={flatIndex}\n                  system={system}\n                  onClick={() => setSelectedId(system.config.id)}\n                  onToggle={() => handleToggle(system)}\n                  usageMap={usageMap}\n                />\n              );\n            }}\n          />\n        );\n      })}\n\n      {/* Add System button */}\n      <div className=\"mt-xl\">\n        <div\n          className=\"add-card se-add-card-wrap\"\n          onClick={() => setShowTypePicker(true)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"se-add-icon\">+</span>\n          <span>Add System</span>\n        </div>\n      </div>\n\n      {showTypePicker && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal se-type-picker-modal\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Choose System Type</div>\n              <button className=\"close-btn\" onClick={() => setShowTypePicker(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"se-type-picker-content\">\n              <div className=\"type-picker\">\n                {Object.entries(SYSTEM_TYPES).map(([type, config]) => (\n                  <div\n                    key={type}\n                    className=\"se-type-option type-option\"\n                    onClick={() => handleAddSystem(type)}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <div className=\"type-option-icon\">{config.icon}</div>\n                    <div className=\"type-option-label\">{config.label}</div>\n                    <div className=\"type-option-desc\">{config.desc}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {selectedSystem && (\n        <SystemModal\n          system={selectedSystem}\n          onChange={handleSystemChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; systems?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/ValidationEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/ValidationEditor.jsx", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/ValidationEditor.jsx::getValidationStatus", "name": "getValidationStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/ValidationEditor.jsx", "sourceCode": "/**\n * Export validation status calculation for use by parent\n */\nexport function getValidationStatus(usageMap, schema, eras, pressures, generators, systems) {\n  const results = runValidations(\n    usageMap,\n    schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    eras || [],\n    pressures || [],\n    generators || [],\n    systems || []\n  );\n  return {\n    status: getOverallStatus(results),\n    errorCount: results.errors.length,\n    warningCount: results.warnings.length,\n    totalIssues: results.errors.length + results.warnings.length,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}], "returnType": "{ status: string; errorCount: number; warningCount: number; totalIssues: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/utils/persistence.js::buildStorageKey", "name": "buildStorageKey", "kind": "function", "filePath": "apps/coherence-engine/webui/src/utils/persistence.js", "sourceCode": "export function buildStorageKey(projectId, suffix) {\n  if (!projectId) return null;\n  return `${STORAGE_PREFIX}${projectId}:${suffix}`;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "suffix", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/utils/persistence.js::loadStoredValue", "name": "loadStoredValue", "kind": "function", "filePath": "apps/coherence-engine/webui/src/utils/persistence.js", "sourceCode": "export function loadStoredValue(key) {\n  if (!key || !canUseStorage()) return null;\n  try {\n    const raw = localStorage.getItem(key);\n    if (!raw) return null;\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}", "parameters": [{"name": "key", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/utils/persistence.js::saveStoredValue", "name": "saveStoredValue", "kind": "function", "filePath": "apps/coherence-engine/webui/src/utils/persistence.js", "sourceCode": "export function saveStoredValue(key, value) {\n  if (!key || !canUseStorage()) return;\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "key", "type": "any", "optional": false}, {"name": "value", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/utils/persistence.js::clearStoredValue", "name": "clearStoredValue", "kind": "function", "filePath": "apps/coherence-engine/webui/src/utils/persistence.js", "sourceCode": "export function clearStoredValue(key) {\n  if (!key || !canUseStorage()) return;\n  try {\n    localStorage.removeItem(key);\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "key", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getEffectiveDomain", "name": "getEffectiveDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get effective domain from culture config\n */\nexport function getEffectiveDomain(cultureConfig) {\n  const domains = cultureConfig?.naming?.domains;\n  if (domains && domains.length > 0) {\n    return domains[0];\n  }\n  return null;\n}", "parameters": [{"name": "cultureConfig", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getAllDomains", "name": "getAllDomains", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Collect all domains from all cultures\n */\nexport function getAllDomains(allCultures) {\n  const allDomains = [];\n  if (allCultures) {\n    Object.entries(allCultures).forEach(([cultId, cultConfig]) => {\n      if (cultConfig?.naming?.domains) {\n        cultConfig.naming.domains.forEach((domain) => {\n          allDomains.push({\n            ...domain,\n            sourceCulture: cultId,\n          });\n        });\n      }\n    });\n  }\n  return allDomains;\n}", "parameters": [{"name": "allCultures", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getStrategyColor", "name": "getStrategyColor", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get strategy color based on type\n */\nexport function getStrategyColor(type) {\n  switch (type) {\n    case \"phonotactic\":\n      return \"rgba(59, 130, 246, 0.3)\";\n    case \"grammar\":\n      return \"rgba(147, 51, 234, 0.3)\";\n    default:\n      return \"rgba(100, 100, 100, 0.3)\";\n  }\n}", "parameters": [{"name": "type", "type": "any", "optional": false}], "returnType": "\"rgba(59, 130, 246, 0.3)\" | \"rgba(147, 51, 234, 0.3)\" | \"rgba(100, 100, 100, 0.3)\"", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getStrategyBorder", "name": "getStrategyBorder", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get strategy border color based on type\n */\nexport function getStrategyBorder(type) {\n  switch (type) {\n    case \"phonotactic\":\n      return \"rgba(59, 130, 246, 0.5)\";\n    case \"grammar\":\n      return \"rgba(147, 51, 234, 0.5)\";\n    default:\n      return \"rgba(100, 100, 100, 0.5)\";\n  }\n}", "parameters": [{"name": "type", "type": "any", "optional": false}], "returnType": "\"rgba(59, 130, 246, 0.5)\" | \"rgba(147, 51, 234, 0.5)\" | \"rgba(100, 100, 100, 0.5)\"", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::listAppliesHere", "name": "listAppliesHere", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Check if a lexeme list applies to a given culture/entity\n */\nexport function listAppliesHere(list, cultureId, entityKind) {\n  const appliesTo = list.appliesTo || {};\n  const cultures = appliesTo.cultures || [];\n  const entityKinds = appliesTo.entityKinds || [];\n\n  // Check culture match (empty array or '*' means all)\n  const cultureMatch =\n    cultures.length === 0 || cultures.includes(\"*\") || cultures.includes(cultureId);\n\n  // Check entity kind match\n  const entityMatch =\n    entityKinds.length === 0 || entityKinds.includes(\"*\") || entityKinds.includes(entityKind);\n\n  return cultureMatch && entityMatch;\n}", "parameters": [{"name": "list", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getSharedLexemeLists", "name": "getSharedLexemeLists", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get shared lexeme lists from other cultures/entity types\n */\nexport function getSharedLexemeLists(allCultures, cultureId, entityKind) {\n  const shared = {};\n\n  if (allCultures) {\n    Object.entries(allCultures).forEach(([cultId, cultConfig]) => {\n      if (cultId === cultureId) return;\n      const lists = cultConfig?.naming?.lexemeLists || {};\n      Object.entries(lists).forEach(([listId, list]) => {\n        if (listAppliesHere(list, cultureId, entityKind) && !shared[listId]) {\n          shared[listId] = {\n            ...list,\n            id: listId,\n            sourceCulture: cultId,\n            isShared: true,\n          };\n        }\n      });\n    });\n  }\n\n  return shared;\n}", "parameters": [{"name": "allCultures", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getAvailableLexemeLists", "name": "getAvailableLexemeLists", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get available lexeme lists (local and shared from same culture)\n */\nexport function getAvailableLexemeLists(entityConfig, cultureConfig, cultureId, entityKind) {\n  const lists = [];\n  // Local lists\n  if (entityConfig?.lexemeLists) {\n    Object.keys(entityConfig.lexemeLists).forEach((id) => {\n      lists.push({ id, source: \"local\" });\n    });\n  }\n  // Shared lists from same culture\n  const cultureLists = cultureConfig?.naming?.lexemeLists || {};\n  Object.entries(cultureLists).forEach(([id, list]) => {\n    if (entityConfig?.lexemeLists && entityConfig.lexemeLists[id]) return;\n    const appliesTo = list.appliesTo || {};\n    const cultureMatch =\n      !appliesTo.cultures?.length ||\n      appliesTo.cultures.includes(\"*\") ||\n      appliesTo.cultures.includes(cultureId);\n    const entityMatch =\n      !appliesTo.entityKinds?.length ||\n      appliesTo.entityKinds.includes(\"*\") ||\n      appliesTo.entityKinds.includes(entityKind);\n    if (cultureMatch && entityMatch) {\n      lists.push({ id, source: cultureId });\n    }\n  });\n  return lists;\n}", "parameters": [{"name": "entityConfig", "type": "any", "optional": false}, {"name": "cultureConfig", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/utils.js::getSortedGroups", "name": "getSortedGroups", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Sort strategy groups by priority (highest first)\n */\nexport function getSortedGroups(groups) {\n  if (!groups) return [];\n  return [...groups].sort((a, b) => b.priority - a.priority);\n}", "parameters": [{"name": "groups", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::generateTestNames", "name": "generateTestNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Generate names using a culture's configuration.\n *\n * @param {Object} options\n * @param {Object} options.culture - The culture object (from project.cultures[id])\n * @param {string} options.profileId - Which profile to use (optional, uses first if not specified)\n * @param {number} options.count - Number of names to generate\n * @param {string} options.seed - Optional seed for reproducibility\n * @param {Object} options.context - Context key-value pairs for context:key slots\n * @param {string} options.kind - Entity kind for condition matching\n * @param {string} options.subtype - Entity subtype for condition matching\n * @param {string} options.prominence - Prominence level for condition matching\n * @param {string[]} options.tags - Tags for condition matching\n * @returns {Promise<Object>} { names: string[], strategyUsage: Record<string, number> }\n */\nexport async function generateTestNames({\n  culture,\n  profileId,\n  count = 10,\n  seed,\n  context = {},\n  kind,\n  subtype,\n  prominence,\n  tags = []\n}) {\n  const nameForgeCulture = toNameForgeCulture(culture);\n  if (!nameForgeCulture) {\n    throw new Error('Culture required');\n  }\n\n  if (!nameForgeCulture.profiles || nameForgeCulture.profiles.length === 0) {\n    throw new Error('Culture has no profiles');\n  }\n\n  // generate() handles Markov model preloading internally\n  return generate(nameForgeCulture, {\n    cultureId: nameForgeCulture.id,\n    profileId: profileId,\n    context: context,\n    count: count,\n    seed: seed || `test-${Date.now()}`,\n    kind: kind,\n    subtype: subtype,\n    prominence: prominence,\n    tags: tags\n  });\n}", "parameters": [{"name": "{\n  culture,\n  profileId,\n  count = 10,\n  seed,\n  context = {},\n  kind,\n  subtype,\n  prominence,\n  tags = []\n}", "type": "{ culture: any; profileId: string; count: number; seed: string; context: any; kind: string; subtype: string; prominence: string; tags: string[]; }", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/generate.js", "specifiers": ["generate", "generateFromDomain", "previewGrammar"], "category": "external"}, {"source": "@lib/markov-loader.js", "specifiers": ["setMarkovBaseUrl"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::generateNamesFromDomain", "name": "generateNamesFromDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Generate names directly from a domain (without profile)\n */\nexport function generateNamesFromDomain(domain, count = 10, seed) {\n  return generateFromDomain(domain, count, seed);\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/generate.js", "specifiers": ["generate", "generateFromDomain", "previewGrammar"], "category": "external"}, {"source": "@lib/markov-loader.js", "specifiers": ["setMarkovBaseUrl"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::previewGrammarNames", "name": "previewGrammarNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Preview a grammar by generating sample names.\n * Used for live preview in the grammar editor.\n *\n * @param {Object} options\n * @param {Object} options.grammar - The grammar to preview\n * @param {Array} options.domains - Available domains\n * @param {Object} options.lexemeLists - Available lexeme lists (keyed by id)\n * @param {number} options.count - Number of names to generate (default 8)\n * @returns {Promise<string[]>} Generated sample names\n */\nexport async function previewGrammarNames({ grammar, domains, lexemeLists, count = 8 }) {\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\n    return [];\n  }\n\n  // Convert lexemeLists object to array format expected by lib\n  const lexemeListsArray = Object.entries(lexemeLists || {}).map(([id, list]) => ({\n    id,\n    entries: list.entries || [],\n    ...list\n  }));\n\n  return previewGrammar({\n    grammar,\n    domains: domains || [],\n    lexemeLists: lexemeListsArray,\n    count\n  });\n}", "parameters": [{"name": "{ grammar, domains, lexemeLists, count = 8 }", "type": "{ grammar: any; domains: any[]; lexemeLists: any; count: number; }", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/generate.js", "specifiers": ["generate", "generateFromDomain", "previewGrammar"], "category": "external"}, {"source": "@lib/markov-loader.js", "specifiers": ["setMarkovBaseUrl"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Main optimizer entry point\n */\nexport async function optimizeDomain(\n  domain,\n  validationSettings,\n  fitnessWeights,\n  optimizationSettings,\n  siblingDomains = [],\n  onProgress = null\n) {\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\n  const seed = `optimize-${domain.id}-${Date.now()}`;\n\n  onProgress?.('Starting optimization...');\n\n  try {\n    let result;\n\n    switch (algorithm) {\n      case 'hillclimb':\n        result = await hillclimb(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          DEFAULT_BOUNDS,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'sim_anneal':\n        result = await simulatedAnnealing(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          DEFAULT_BOUNDS,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'bayes':\n        result = await bayesianOptimization(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'ga':\n        result = await geneticAlgorithm(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      default:\n        throw new Error(`Unknown algorithm: ${algorithm}`);\n    }\n\n    onProgress?.('Optimization complete!');\n    return result;\n  } catch (error) {\n    onProgress?.(`Error: ${error.message}`);\n    throw error;\n  }\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "validationSettings", "type": "any", "optional": false}, {"name": "fitnessWeights", "type": "any", "optional": false}, {"name": "optimizationSettings", "type": "any", "optional": false}, {"name": "siblingDomains", "type": "any[]", "optional": true}, {"name": "onProgress", "type": "any", "optional": true}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/optimizer/hillclimb.js", "specifiers": ["hillclimb"], "category": "external"}, {"source": "@lib/optimizer/sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "external"}, {"source": "@lib/optimizer/bayesian.js", "specifiers": ["bayesianOptimization"], "category": "external"}, {"source": "@lib/optimizer/genetic.js", "specifiers": ["geneticAlgorithm"], "category": "external"}, {"source": "@lib/optimizer/optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "external"}, {"source": "@lib/validation/metrics/capacity.js", "specifiers": ["validateCapacity"], "category": "external"}, {"source": "@lib/validation/metrics/diffuseness.js", "specifiers": ["validateDiffuseness"], "category": "external"}, {"source": "@lib/validation/metrics/separation.js", "specifiers": ["validateSeparation"], "category": "external"}, {"source": "@lib/phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "external"}, {"source": "@lib/utils/rng.js", "specifiers": ["createRNG"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::generateTestNames", "name": "generateTestNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Generate test names using a domain\n */\nexport function generateTestNames(domain, count = 10, seed) {\n  const rng = createRNG(seed || `test-${Date.now()}`);\n  const names = [];\n\n  for (let i = 0; i < count; i++) {\n    names.push(generatePhonotacticName(rng, domain));\n  }\n\n  return names;\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/optimizer/hillclimb.js", "specifiers": ["hillclimb"], "category": "external"}, {"source": "@lib/optimizer/sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "external"}, {"source": "@lib/optimizer/bayesian.js", "specifiers": ["bayesianOptimization"], "category": "external"}, {"source": "@lib/optimizer/genetic.js", "specifiers": ["geneticAlgorithm"], "category": "external"}, {"source": "@lib/optimizer/optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "external"}, {"source": "@lib/validation/metrics/capacity.js", "specifiers": ["validateCapacity"], "category": "external"}, {"source": "@lib/validation/metrics/diffuseness.js", "specifiers": ["validateDiffuseness"], "category": "external"}, {"source": "@lib/validation/metrics/separation.js", "specifiers": ["validateSeparation"], "category": "external"}, {"source": "@lib/phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "external"}, {"source": "@lib/utils/rng.js", "specifiers": ["createRNG"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::validateDomain", "name": "validateDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Validate a domain configuration\n *\n * Returns metrics without running full optimization.\n */\nexport async function validateDomain(domain, sampleSize = 500, siblingDomains = []) {\n  const seed = `validate-${Date.now()}`;\n\n  const capacityReport = validateCapacity(domain, { sampleSize, seed: `${seed}-cap` });\n  const diffusenessReport = validateDiffuseness(domain, { sampleSize, seed: `${seed}-diff` });\n\n  let separationReport = null;\n  if (siblingDomains.length > 0) {\n    const allDomains = [domain, ...siblingDomains];\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\n    separationReport = validateSeparation(allDomains, { sampleSize: perDomainSample, seed: `${seed}-sep` });\n  }\n\n  return {\n    capacity: capacityReport,\n    diffuseness: diffusenessReport,\n    separation: separationReport,\n  };\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "siblingDomains", "type": "any[]", "optional": true}], "returnType": "Promise<{ capacity: any; diffuseness: any; separation: any; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@lib/optimizer/hillclimb.js", "specifiers": ["hillclimb"], "category": "external"}, {"source": "@lib/optimizer/sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "external"}, {"source": "@lib/optimizer/bayesian.js", "specifiers": ["bayesianOptimization"], "category": "external"}, {"source": "@lib/optimizer/genetic.js", "specifiers": ["geneticAlgorithm"], "category": "external"}, {"source": "@lib/optimizer/optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "external"}, {"source": "@lib/validation/metrics/capacity.js", "specifiers": ["validateCapacity"], "category": "external"}, {"source": "@lib/validation/metrics/diffuseness.js", "specifiers": ["validateDiffuseness"], "category": "external"}, {"source": "@lib/validation/metrics/separation.js", "specifiers": ["validateSeparation"], "category": "external"}, {"source": "@lib/phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "external"}, {"source": "@lib/utils/rng.js", "specifiers": ["createRNG"], "category": "external"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx", "sourceCode": "export default function CultureEditor({ cultures, onChange }) {\n  const [expandedCultures, setExpandedCultures] = useState({});\n\n  const getStableKey = (culture) => culture._key || culture.id;\n\n  const toggleCulture = useCallback((stableKey) => {\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addCulture = () => {\n    const stableKey = `culture_${Date.now()}`;\n    const newCulture = {\n      id: stableKey,\n      name: \"New Culture\",\n      description: \"\",\n      color: PRESET_COLORS[cultures.length % PRESET_COLORS.length],\n      _key: stableKey,\n    };\n    onChange([...cultures, newCulture]);\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateCulture = (cultureId, updates) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    onChange(cultures.map((c) => (c.id === cultureId ? { ...c, ...updates } : c)));\n  };\n\n  const deleteCulture = (cultureId) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this culture?\")) {\n      onChange(cultures.filter((c) => c.id !== cultureId));\n    }\n  };\n\n  const getCultureSummary = (culture) => {\n    const parts = [];\n    if (culture.naming?.domains?.length) parts.push(`${culture.naming.domains.length} domains`);\n    if (culture.axisBiases && Object.keys(culture.axisBiases).length) parts.push(\"axis biases\");\n    return parts.length > 0 ? parts.join(\", \") : \"not configured\";\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addCulture}>\n      + Add Culture\n    </button>\n  );\n\n  const renderCultureTitle = (culture) => (\n    <span className=\"ced-title-wrapper\">\n      <span\n        className=\"ced-color-swatch\"\n        style={{ '--ced-swatch-color': culture.color }}\n      />\n      {culture.name}\n    </span>\n  );\n\n  const renderCultureActions = (culture, isFramework) => (\n    <span className=\"text-muted text-small\">\n      {getCultureSummary(culture)}\n      {isFramework && (\n        <span className=\"badge badge-info ced-framework-badge\">\n          framework\n        </span>\n      )}\n    </span>\n  );\n\n  return (\n    <div className=\"editor-container ced-container\">\n      <SectionHeader\n        title=\"Cultures\"\n        description=\"Define cultural groups with their own naming conventions and placement biases.\"\n        count={cultures.length}\n        actions={renderHeaderActions()}\n      />\n\n      {cultures.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83c\udfad\"\n          title=\"No cultures defined\"\n          description=\"Add one to give your world cultural diversity.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {cultures.map((culture) => {\n            const stableKey = getStableKey(culture);\n            const isExpanded = expandedCultures[stableKey];\n            const isFramework = Boolean(culture.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleCulture}\n                toggleId={stableKey}\n                title={renderCultureTitle(culture)}\n                subtitle={culture.id}\n                actions={renderCultureActions(culture, isFramework)}\n              >\n                {/* Name and ID */}\n                <FormRow>\n                  <FormGroup label=\"Name\">\n                    <input\n                      className=\"input\"\n                      value={culture.name}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { name: e.target.value })}\n                      placeholder=\"Culture name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"ID\">\n                    <input\n                      className=\"input\"\n                      value={culture.id}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newId = e.target.value.toLowerCase().replace(/[^a-z0-9-_]/g, \"\");\n                        if (newId && !cultures.some((c) => c.id === newId && c.id !== culture.id)) {\n                          updateCulture(culture.id, { id: newId });\n                        }\n                      }}\n                      placeholder=\"culture-id\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                <FormRow>\n                  <FormGroup label=\"Description\" wide>\n                    <input\n                      className=\"input\"\n                      value={culture.description || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { description: e.target.value })}\n                      placeholder=\"Optional description\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                {/* Color Selection */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Color</div>\n                  <div className=\"ced-color-row\">\n                    <div\n                      className=\"ced-color-preview\"\n                      style={{ '--ced-preview-color': culture.color }}\n                    />\n                    <div className=\"chip-list\">\n                      {PRESET_COLORS.map((color) => (\n                        <div\n                          key={color}\n                          className={`chip chip-clickable ced-color-chip ${culture.color === color ? \"chip-active\" : \"\"}`}\n                          style={{\n                            '--ced-chip-bg': color,\n                            '--ced-chip-border': culture.color === color ? '#fff' : 'transparent',\n                            '--ced-chip-opacity': isFramework ? 0.6 : 1,\n                            '--ced-chip-pointer': isFramework ? 'none' : 'auto',\n                          }}\n                          onClick={() => updateCulture(culture.id, { color })}\n                          role=\"button\"\n                          tabIndex={0}\n                          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                        />\n                      ))}\n                    </div>\n                  </div>\n                </div>\n\n                {/* Info about other editors */}\n                <InfoBox title=\"Additional configuration\">\n                  <ul className=\"ced-info-list\">\n                    <li>\n                      <strong>Names tab</strong> \u2014 Configure naming domains, grammars, and profiles\n                    </li>\n                    <li>\n                      <strong>Cosmography tab</strong> \u2014 Configure axis biases and home regions\n                    </li>\n                  </ul>\n                </InfoBox>\n\n                {/* Actions */}\n                <div className=\"danger-zone\">\n                  <div className=\"ced-action-badges\">\n                    {culture.naming && <span className=\"badge\">has naming</span>}\n                    {culture.axisBiases && <span className=\"badge\">has biases</span>}\n                  </div>\n                  <button\n                    className=\"btn btn-danger\"\n                    onClick={() => deleteCulture(culture.id)}\n                    disabled={isFramework}\n                  >\n                    Delete Culture\n                  </button>\n                </div>\n              </ExpandableCard>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ cultures, onChange }", "type": "{ cultures: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableCard", "FormGroup", "FormRow", "SectionHeader", "EmptyState", "InfoBox"], "category": "external"}, {"source": "./CultureEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx", "sourceCode": "export default function EntityKindEditor({\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}) {\n  const [expandedKinds, setExpandedKinds] = useState({});\n  const [newSubtype, setNewSubtype] = useState({});\n  const [newStatus, setNewStatus] = useState({});\n\n  const namingProfileUsage = useMemo(() => computeNamingProfileUsage(namingData), [namingData]);\n\n  const getNamingProfileCount = (kind) => {\n    const specific = namingProfileUsage[kind]?.profiles?.length || 0;\n    const wildcard = namingProfileUsage[\"*\"]?.profiles?.length || 0;\n    return specific + wildcard;\n  };\n\n  const getStableKey = (ek) => ek._key || ek.kind;\n\n  const toggleKind = useCallback((stableKey) => {\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addEntityKind = () => {\n    const stableKey = `kind_${Date.now()}`;\n    const newKind = {\n      kind: stableKey,\n      description: \"New Entity Kind\",\n      subtypes: [],\n      statuses: [{ id: \"active\", name: \"Active\", isTerminal: false }],\n      defaultStatus: \"active\",\n      style: { color: getDefaultKindColor(stableKey, entityKinds.length) },\n      _key: stableKey,\n    };\n    onChange([...entityKinds, newKind]);\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateKind = (kindKey, updates) => {\n    const existing = entityKinds.find((k) => k.kind === kindKey);\n    if (existing?.isFramework) return;\n    onChange(entityKinds.map((k) => (k.kind === kindKey ? { ...k, ...updates } : k)));\n  };\n\n  const updateKindStyle = (kindKey, updates) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (!kind) return;\n    updateKind(kindKey, { style: { ...(kind.style || {}), ...updates } });\n  };\n\n  const deleteKind = (kindKey) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (kind?.isFramework) return;\n    if (confirm(\"Delete this entity kind? This cannot be undone.\")) {\n      onChange(entityKinds.filter((k) => k.kind !== kindKey));\n    }\n  };\n\n  const addSubtype = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newSubtype[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const subtype = { id: generateId(name), name };\n    updateKind(kindKey, { subtypes: [...ek.subtypes, subtype] });\n    setNewSubtype((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeSubtype = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { subtypes: ek.subtypes.filter((s) => s.id !== subtypeId) });\n  };\n\n  const addStatus = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newStatus[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const status = { id: generateId(name), name, isTerminal: false, polarity: \"neutral\" };\n    updateKind(kindKey, { statuses: [...ek.statuses, status] });\n    setNewStatus((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeStatus = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { statuses: ek.statuses.filter((s) => s.id !== statusId) });\n  };\n\n  const toggleStatusTerminal = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, isTerminal: !s.isTerminal } : s\n      ),\n    });\n  };\n\n  const updateStatusPolarity = (kindKey, statusId, polarity) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) => (s.id === statusId ? { ...s, polarity } : s)),\n    });\n  };\n\n  const updateStatusTransitionVerb = (kindKey, statusId, transitionVerb) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, transitionVerb: transitionVerb || undefined } : s\n      ),\n    });\n  };\n\n  const toggleSubtypeAuthority = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      subtypes: ek.subtypes.map((s) =>\n        s.id === subtypeId ? { ...s, isAuthority: !s.isAuthority } : s\n      ),\n    });\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addEntityKind}>\n      + Add Entity Kind\n    </button>\n  );\n\n  const renderKindActions = (kind, profileCount, isFramework) => (\n    <>\n      <UsageBadges usage={getEntityKindUsageSummary(schemaUsage, kind.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {profileCount > 0 && (\n        <span\n          className=\"badge badge-warning\"\n          title={`Used in ${profileCount} naming profile group${profileCount !== 1 ? \"s\" : \"\"}`}\n        >\n          \u270e {profileCount}\n        </span>\n      )}\n      <span className=\"text-muted text-small\">\n        {kind.subtypes.length} subtypes, {kind.statuses.length} statuses\n      </span>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container eke-container\">\n      <SectionHeader\n        title=\"Entity Kinds\"\n        description=\"Define the types of entities that exist in your world.\"\n        count={entityKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {entityKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udce6\"\n          title=\"No entity kinds defined\"\n          description=\"Add one to get started.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {entityKinds.map((ek) => {\n            const stableKey = getStableKey(ek);\n            const isExpanded = expandedKinds[stableKey];\n            const profileCount = getNamingProfileCount(ek.kind);\n            const kindColor = ek.style?.color;\n            const isFramework = Boolean(ek.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleKind}\n                toggleId={stableKey}\n                title={ek.description}\n                subtitle={ek.kind}\n                actions={renderKindActions(ek, profileCount, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <FormRow>\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={ek.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateKind(ek.kind, { description: e.target.value })}\n                      placeholder=\"Entity kind display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={ek.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !entityKinds.some((k) => k.kind === newKind && k.kind !== ek.kind)\n                        ) {\n                          updateKind(ek.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"entity_kind_id\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Color\">\n                    <input\n                      className=\"input\"\n                      type=\"color\"\n                      value={kindColor ?? \"#000000\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateKindStyle(ek.kind, { color: e.target.value })}\n                    />\n                    {!kindColor && (\n                      <div className=\"eke-color-missing\">\n                        Color required\n                      </div>\n                    )}\n                  </FormGroup>\n                  <FormGroup\n                    label=\"Category\"\n                    tooltip=\"Abstract category for narrative style recommendations\"\n                  >\n                    <select\n                      className=\"input\"\n                      value={ek.category || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) =>\n                        updateKind(ek.kind, { category: e.target.value || undefined })\n                      }\n                    >\n                      <option value=\"\">-- Not set --</option>\n                      {Object.entries(ENTITY_CATEGORIES).map(([categoryId, categoryInfo]) => (\n                        <option key={categoryId} value={categoryId}>\n                          {categoryInfo.name}\n                        </option>\n                      ))}\n                    </select>\n                  </FormGroup>\n                </FormRow>\n\n                {/* Subtypes */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Subtypes</div>\n                  <div className=\"chip-list\">\n                    {ek.subtypes.map((subtype) => {\n                      const usage = getSubtypeUsage(schemaUsage, ek.kind, subtype.id);\n                      const isUnused = usage.total === 0;\n                      const tooltipParts = [];\n                      if (usage.generators > 0)\n                        tooltipParts.push(\n                          `${usage.generators} generator${usage.generators !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.systems > 0)\n                        tooltipParts.push(\n                          `${usage.systems} system${usage.systems !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.seeds > 0)\n                        tooltipParts.push(`${usage.seeds} seed${usage.seeds !== 1 ? \"s\" : \"\"}`);\n                      const tooltip =\n                        tooltipParts.length > 0\n                          ? tooltipParts.join(\", \")\n                          : \"Not used by any generator, system, or seed\";\n\n                      return (\n                        <div\n                          key={subtype.id}\n                          className={`chip ${isUnused ? \"chip-unused\" : \"\"}`}\n                          title={tooltip}\n                        >\n                          <input\n                            type=\"checkbox\"\n                            checked={subtype.isAuthority || false}\n                            disabled={isFramework}\n                            onChange={() => toggleSubtypeAuthority(ek.kind, subtype.id)}\n                            title=\"Authority subtype (for leadership/succession events)\"\n                          />\n                          <span className=\"chip-content\">\n                            {subtype.name}\n                            {subtype.isAuthority && (\n                              <span className=\"badge badge-warning eke-authority-badge\">\n                                \ud83d\udc51\n// ... (truncated)", "parameters": [{"name": "{\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ entityKinds: any; onChange: any; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableCard", "FormGroup", "FormRow", "SectionHeader", "EmptyState"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ToolUsageBadges as UsageBadges", "getEntityKindUsageSummary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["ENTITY_CATEGORIES"], "category": "external"}, {"source": "./EntityKindEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/index.jsx", "sourceCode": "export default function SchemaEditor({\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}) {\n  // Use passed-in activeSection, fallback to entityKinds\n  const currentSection = activeSection || \"entityKinds\";\n  const handleNavigateToRelationship = useCallback(() => {\n    onSectionChange(\"relationshipKinds\");\n  }, [onSectionChange]);\n  const tagRegistryOrEmpty = useMemo(() => project.tagRegistry || [], [project.tagRegistry]);\n\n  const counts = {\n    entityKinds: project.entityKinds.length,\n    relationshipKinds: project.relationshipKinds.length,\n    cultures: project.cultures.length,\n    tagRegistry: (project.tagRegistry || []).length,\n  };\n\n  const renderEditor = () => {\n    switch (currentSection) {\n      case \"entityKinds\":\n        return (\n          <EntityKindEditor\n            entityKinds={project.entityKinds}\n            onChange={onUpdateEntityKinds}\n            schemaUsage={schemaUsage}\n            namingData={namingData}\n          />\n        );\n\n      case \"relationshipKinds\":\n        return (\n          <RelationshipKindEditor\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateRelationshipKinds}\n            schemaUsage={schemaUsage}\n          />\n        );\n\n      case \"relationshipMatrix\":\n        return (\n          <RelationshipKindMatrix\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onNavigateToRelationship={handleNavigateToRelationship}\n          />\n        );\n\n      case \"cultures\":\n        return <CultureEditor cultures={project.cultures} onChange={onUpdateCultures} />;\n\n      case \"tags\":\n        return (\n          <TagRegistryEditor\n            tagRegistry={tagRegistryOrEmpty}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateTagRegistry}\n            tagUsage={tagUsage}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"se-container\">\n      <div className=\"se-sidebar\">\n        <div className=\"se-sidebar-title\">Schema</div>\n        {SECTIONS.map((section) => (\n          <div\n            key={section.id}\n            className={`se-sidebar-item ${section.id === currentSection ? \"se-sidebar-item-active\" : \"se-sidebar-item-inactive\"}`}\n            style={section.id === currentSection ? { '--se-sidebar-active-bg': getAccentGradient(\"enumerist\") } : undefined}\n            onClick={() => onSectionChange(section.id)}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            {section.label}\n            {section.countKey && (\n              <span className=\"se-sidebar-count\">{counts[section.countKey]}</span>\n            )}\n          </div>\n        ))}\n      </div>\n      <div className=\"se-main\">{renderEditor()}</div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ project: any; activeSection: any; onSectionChange: any; onUpdateEntityKinds: any; onUpdateRelationshipKinds: any; onUpdateCultures: any; onUpdateTagRegistry: any; tagUsage?: {}; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useCallback", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./EntityKindEditor", "specifiers": ["EntityKindEditor"], "category": "internal"}, {"source": "./RelationshipKindEditor", "specifiers": ["RelationshipKindEditor"], "category": "internal"}, {"source": "./CultureEditor", "specifiers": ["CultureEditor"], "category": "internal"}, {"source": "./TagRegistryEditor", "specifiers": ["TagRegistryEditor"], "category": "internal"}, {"source": "./RelationshipKindMatrix", "specifiers": ["RelationshipKindMatrix"], "category": "internal"}, {"source": "../../theme", "specifiers": ["getAccentGradient"], "category": "internal"}, {"source": "./SchemaEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx", "sourceCode": "export default function RelationshipKindEditor({\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}) {\n  const [expandedRels, setExpandedRels] = useState({});\n\n  const getStableKey = (rel) => rel._key || rel.kind;\n\n  const toggleRel = useCallback((stableKey) => {\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addRelationship = () => {\n    const stableKey = `rel_${Date.now()}`;\n    const newRel = {\n      kind: stableKey,\n      description: \"New Relationship\",\n      srcKinds: [],\n      dstKinds: [],\n      cullable: true,\n      decayRate: \"medium\",\n      polarity: \"neutral\",\n      _key: stableKey,\n    };\n    onChange([...relationshipKinds, newRel]);\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateRel = (relKind, updates) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    onChange(relationshipKinds.map((r) => (r.kind === relKind ? { ...r, ...updates } : r)));\n  };\n\n  const deleteRel = (relKind) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this relationship kind?\")) {\n      onChange(relationshipKinds.filter((r) => r.kind !== relKind));\n    }\n  };\n\n  const toggleEntityKind = (relKind, field, entityKindId) => {\n    const rel = relationshipKinds.find((r) => r.kind === relKind);\n    if (!rel || rel.isFramework) return;\n    const current = rel[field] || [];\n    const updated = current.includes(entityKindId)\n      ? current.filter((k) => k !== entityKindId)\n      : [...current, entityKindId];\n    updateRel(relKind, { [field]: updated });\n  };\n\n  const getSummary = (rel) => {\n    const srcNames =\n      rel.srcKinds?.length > 0\n        ? rel.srcKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    const dstNames =\n      rel.dstKinds?.length > 0\n        ? rel.dstKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    return { srcNames, dstNames };\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addRelationship}>\n      + Add Relationship\n    </button>\n  );\n\n  const renderRelationshipActions = (rel, srcNames, dstNames, isFramework) => (\n    <>\n      <UsageBadges usage={getRelationshipKindUsageSummary(schemaUsage, rel.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {rel.cullable === false && <span className=\"badge badge-info\">protected</span>}\n      <div className=\"text-muted text-small rke-actions-flow\">\n        {srcNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.srcKinds?.length > 2 && <span>+{rel.srcKinds.length - 2}</span>}\n        <span>\u2192</span>\n        {dstNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.dstKinds?.length > 2 && <span>+{rel.dstKinds.length - 2}</span>}\n      </div>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container rke-container\">\n      <SectionHeader\n        title=\"Relationship Kinds\"\n        description=\"Define how entities can be connected to each other.\"\n        count={relationshipKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {relationshipKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udd17\"\n          title=\"No relationship kinds defined\"\n          description=\"Add one to connect entities.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {relationshipKinds.map((rel) => {\n            const stableKey = getStableKey(rel);\n            const isExpanded = expandedRels[stableKey];\n            const { srcNames, dstNames } = getSummary(rel);\n            const isFramework = Boolean(rel.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleRel}\n                toggleId={stableKey}\n                title={rel.description}\n                subtitle={rel.kind}\n                actions={renderRelationshipActions(rel, srcNames, dstNames, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <div className=\"rke-name-row\">\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={rel.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateRel(rel.kind, { description: e.target.value })}\n                      placeholder=\"Relationship display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={rel.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !relationshipKinds.some((r) => r.kind === newKind && r.kind !== rel.kind)\n                        ) {\n                          updateRel(rel.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"relationship_kind_id\"\n                    />\n                  </FormGroup>\n                </div>\n\n                {/* Entity Kind Constraints */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-constraint-label\">\n                    Entity Kind Constraints\n                  </div>\n                  {entityKinds.length === 0 ? (\n                    <div className=\"text-muted text-small\">\n                      Define entity kinds first to set constraints.\n                    </div>\n                  ) : (\n                    <div className=\"rke-constraint-row\">\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Source</span>\n                          {rel.srcKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.srcKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"srcKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                      <div className=\"text-dim rke-arrow\">\n                        \u2192\n                      </div>\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Destination</span>\n                          {rel.dstKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.dstKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"dstKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    </div>\n                  )}\n                </div>\n\n                {/* Maintenance Settings */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-maintenance-label\">\n                    Maintenance Settings\n                  </div>\n                  <div className=\"rke-maintenance-row\">\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Decay</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.decayRate || \"medium\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { decayRate: e.target.value })}\n                      >\n                        <option value=\"none\">None</option>\n                        <option value=\"slow\">Slow</option>\n                        <option value=\"medium\">Medium</option>\n                        <option value=\"fast\">Fast</option>\n                      </select>\n                    </div>\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Polarity</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.polarity || \"neutral\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { polarity: e.target.value })}\n                        title=\"Affects narrative event types\"\n                      >\n                        <option value=\"positive\">Positive</option>\n                        <option value=\"neutral\">Neutral</option>\n                        <option value=\"negative\">Negative</option>\n                      </select>\n                    </div>\n                    <label className=\"rke-cullable-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={rel.cullable !== false}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { cullable: e.target.checked })}\n                        className=\"rke-checkbox\"\n                      />\n                      <span className=\"text-small\">Cullable</span>\n                    </label>\n                  </div>\n                </div>\n\n                {/* Narrative Verbs */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-verbs-label\">\n                    Narrative Verbs\n                  </div>\n                  <div className=\"text-muted text-small rke-verbs-hint\">\n                    Verbs used in narrative event descriptions when this relationship is formed or\n                    ended.\n                  </div>\n                  <div className=\"rke-verbs-row\">\n                    <FormGroup label=\"Formed\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.formed || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n                          updateRel(rel.kind, {\n                            verbs: { ...rel.verbs, formed: e.target.value },\n                          })\n                        }\n                        placeholder=\"e.g., joined, allied with\"\n                      />\n                    </FormGroup>\n                    <FormGroup label=\"Ended\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.ended || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n// ... (truncated)", "parameters": [{"name": "{\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}", "type": "{ relationshipKinds: any; entityKinds: any; onChange: any; schemaUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableCard", "FormGroup", "SectionHeader", "EmptyState"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ToolUsageBadges as UsageBadges", "getRelationshipKindUsageSummary"], "category": "external"}, {"source": "./RelationshipKindEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx", "sourceCode": "export default function RelationshipKindMatrix({\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}) {\n  // Build rows from relationship kinds\n  const rows = useMemo(() => {\n    return relationshipKinds.map((rel) => ({\n      id: rel.kind,\n      label: rel.description || rel.kind,\n      // Store original data for getCellValue\n      srcKinds: rel.srcKinds || [],\n      dstKinds: rel.dstKinds || [],\n      // Status badges\n      statusBadges: getStatusBadges(rel),\n    }));\n  }, [relationshipKinds]);\n\n  // Build columns from entity kinds\n  const columns = useMemo(() => {\n    return entityKinds.map((ek) => ({\n      id: ek.kind,\n      label: ek.description || ek.kind,\n    }));\n  }, [entityKinds]);\n\n  // Calculate coverage stats\n  const stats = useMemo(() => {\n    const totalRels = relationshipKinds.length;\n    const totalEntityKinds = entityKinds.length;\n\n    // Count relationships that have explicit constraints\n    const constrainedRels = relationshipKinds.filter(\n      (r) => r.srcKinds?.length > 0 || r.dstKinds?.length > 0\n    ).length;\n\n    // Count relationships with no constraints (wildcard)\n    const wildcardRels = totalRels - constrainedRels;\n\n    // Find entity kinds that are never used as source or destination\n    const usedAsSource = new Set();\n    const usedAsDestination = new Set();\n    relationshipKinds.forEach((rel) => {\n      (rel.srcKinds || []).forEach((k) => usedAsSource.add(k));\n      (rel.dstKinds || []).forEach((k) => usedAsDestination.add(k));\n    });\n\n    const result = [\n      { label: \"Relationships\", value: totalRels },\n      { label: \"Entity Kinds\", value: totalEntityKinds },\n      { label: \"Constrained\", value: constrainedRels },\n    ];\n\n    if (wildcardRels > 0) {\n      result.push({ label: \"Wildcards\", value: wildcardRels, variant: \"warning\" });\n    }\n\n    return result;\n  }, [relationshipKinds, entityKinds]);\n\n  // Get cell value for a relationship \u00d7 entity kind intersection\n  const getCellValue = useCallback((rowId, columnId, row) => {\n    // Check if explicitly constrained vs wildcard\n    const srcExplicit = row.srcKinds.length > 0 && row.srcKinds.includes(columnId);\n    const dstExplicit = row.dstKinds.length > 0 && row.dstKinds.includes(columnId);\n    const srcWildcard = row.srcKinds.length === 0;\n    const dstWildcard = row.dstKinds.length === 0;\n\n    if (srcExplicit && dstExplicit) return \"both\";\n    if (srcExplicit) return \"primary\"; // explicitly source\n    if (dstExplicit) return \"secondary\"; // explicitly destination\n    if (srcWildcard && dstWildcard) return \"both\"; // wildcard both\n    if (srcWildcard) return \"primary\"; // wildcard source\n    if (dstWildcard) return \"secondary\"; // wildcard destination\n    return \"none\";\n  }, []);\n\n  // Custom cell display for relationship coverage\n  const getCellDisplay = useCallback((value) => {\n    switch (value) {\n      case \"both\":\n        return { icon: \"B\", className: \"both\", title: \"Both source and destination\" };\n      case \"primary\":\n        return { icon: \"S\", className: \"primary\", title: \"Source only\" };\n      case \"secondary\":\n        return { icon: \"D\", className: \"secondary\", title: \"Destination only\" };\n      case \"none\":\n      default:\n        return { icon: \"-\", className: \"none\", title: \"Not allowed\" };\n    }\n  }, []);\n\n  // Handle row click to navigate to relationship\n  const handleRowClick = useCallback(\n    (rowId) => {\n      if (onNavigateToRelationship) {\n        onNavigateToRelationship(rowId);\n      }\n    },\n    [onNavigateToRelationship]\n  );\n\n  // Filter options\n  const filterOptions = useMemo(\n    () => [\n      {\n        id: \"wildcards\",\n        label: \"Wildcards Only\",\n        filter: (row) => row.srcKinds.length === 0 || row.dstKinds.length === 0,\n      },\n      {\n        id: \"constrained\",\n        label: \"Constrained Only\",\n        filter: (row) => row.srcKinds.length > 0 && row.dstKinds.length > 0,\n      },\n    ],\n    []\n  );\n\n  // Legend items\n  const legend = useMemo(\n    () => [\n      { icon: \"S\", className: \"primary\", label: \"Can be source\" },\n      { icon: \"D\", className: \"secondary\", label: \"Can be destination\" },\n      { icon: \"B\", className: \"both\", label: \"Both source and destination\" },\n      { icon: \"-\", className: \"none\", label: \"Not allowed\" },\n    ],\n    []\n  );\n\n  return (\n    <CoverageMatrix\n      rows={rows}\n      columns={columns}\n      getCellValue={getCellValue}\n      getCellDisplay={getCellDisplay}\n      onRowClick={handleRowClick}\n      title=\"Relationship \u00d7 Entity Kind Matrix\"\n      subtitle=\"Shows which entity kinds can participate in each relationship as source (S), destination (D), or both (B). Click a row to navigate to that relationship.\"\n      stats={stats}\n      legend={legend}\n      searchPlaceholder=\"Search relationships...\"\n      groupByField={null}\n      emptyMessage=\"No relationship kinds defined.\"\n      filterOptions={filterOptions}\n    />\n  );\n}", "parameters": [{"name": "{\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}", "type": "{ relationshipKinds?: any[]; entityKinds?: any[]; onNavigateToRelationship: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["CoverageMatrix"], "category": "external"}]}, {"id": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx", "sourceCode": "export default function TagRegistryEditor({\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}) {\n  const [expandedTags, setExpandedTags] = useState({});\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [categoryFilter, setCategoryFilter] = useState(\"all\");\n  const [rarityFilter, setRarityFilter] = useState(\"all\");\n\n  // Compute stats\n  const stats = useMemo(() => {\n    const byCategory = {};\n    const byRarity = {};\n    CATEGORIES.forEach((c) => (byCategory[c] = 0));\n    RARITIES.forEach((r) => (byRarity[r] = 0));\n    tagRegistry.forEach((tag) => {\n      byCategory[tag.category] = (byCategory[tag.category] || 0) + 1;\n      byRarity[tag.rarity] = (byRarity[tag.rarity] || 0) + 1;\n    });\n    return { total: tagRegistry.length, byCategory, byRarity };\n  }, [tagRegistry]);\n\n  // Filter tags\n  const filteredTags = useMemo(() => {\n    return tagRegistry.filter((tag) => {\n      const matchesSearch =\n        !searchQuery ||\n        tag.tag.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        tag.description?.toLowerCase().includes(searchQuery.toLowerCase());\n      const matchesCategory = categoryFilter === \"all\" || tag.category === categoryFilter;\n      const matchesRarity = rarityFilter === \"all\" || tag.rarity === rarityFilter;\n      return matchesSearch && matchesCategory && matchesRarity;\n    });\n  }, [tagRegistry, searchQuery, categoryFilter, rarityFilter]);\n\n  const toggleTag = useCallback((tagId) => {\n    setExpandedTags((prev) => ({ ...prev, [tagId]: !prev[tagId] }));\n  }, []);\n\n  const addTag = () => {\n    const newTag = {\n      tag: `new_tag_${Date.now()}`,\n      category: \"trait\",\n      rarity: \"common\",\n      description: \"New tag description\",\n      usageCount: 0,\n      templates: [],\n      entityKinds: [],\n      minUsage: 1,\n      maxUsage: 50,\n      relatedTags: [],\n      conflictingTags: [],\n    };\n    onChange([newTag, ...tagRegistry]);\n    setExpandedTags((prev) => ({ ...prev, [newTag.tag]: true }));\n  };\n\n  const updateTag = (tagId, updates) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    onChange(tagRegistry.map((t) => (t.tag === tagId ? { ...t, ...updates } : t)));\n  };\n\n  const renderTagTitle = (tag) => <span className=\"tre-monospace\">{tag.tag}</span>;\n\n  const renderTagActions = (tag, catColor, rarColor, isFramework) => (\n    <>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': catColor.bg, '--tre-badge-color': catColor.color }}>\n        {tag.category}\n      </span>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': rarColor.bg, '--tre-badge-color': rarColor.color }}>\n        {tag.rarity}\n      </span>\n      {tag.isAxis && (\n        <span\n          className=\"badge tre-badge-dynamic\"\n          style={{ '--tre-badge-bg': 'rgba(34, 211, 238, 0.2)', '--tre-badge-color': '#22d3ee' }}\n        >\n          \u2194 axis\n        </span>\n      )}\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {tagUsage[tag.tag] && <UsageBadges usage={tagUsage[tag.tag]} compact />}\n      <span className=\"text-muted text-small\">\n        {tag.minUsage || 0}-{tag.maxUsage || \"\u221e\"} | {(tag.entityKinds || []).length} kinds\n      </span>\n    </>\n  );\n\n  const deleteTag = (tagId) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this tag? This cannot be undone.\")) {\n      onChange(tagRegistry.filter((t) => t.tag !== tagId));\n    }\n  };\n\n  // Related tags management\n  const removeRelatedTag = (tagId, relatedTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, { relatedTags: (tag.relatedTags || []).filter((r) => r !== relatedTag) });\n  };\n\n  // Conflicting tags management\n  const removeConflictingTag = (tagId, conflictingTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, {\n      conflictingTags: (tag.conflictingTags || []).filter((c) => c !== conflictingTag),\n    });\n  };\n\n  const allTagNames = useMemo(() => tagRegistry.map((t) => t.tag), [tagRegistry]);\n\n  const handleTagIdChange = (oldId, newId) => {\n    const updatedRegistry = tagRegistry.map((t) => {\n      if (t.tag === oldId) return { ...t, tag: newId };\n      const updated = { ...t };\n      if (t.relatedTags?.includes(oldId)) {\n        updated.relatedTags = t.relatedTags.map((r) =>\n          r === oldId ? newId : r\n        );\n      }\n      if (t.conflictingTags?.includes(oldId)) {\n        updated.conflictingTags = t.conflictingTags.map((c) =>\n          c === oldId ? newId : c\n        );\n      }\n      return updated;\n    });\n    setExpandedTags((prev) => {\n      const updated = { ...prev };\n      if (updated[oldId]) {\n        updated[newId] = updated[oldId];\n        delete updated[oldId];\n      }\n      return updated;\n    });\n    onChange(updatedRegistry);\n  };\n\n  const handleEntityKindToggle = (tag, ek, isFramework) => {\n    if (isFramework) return;\n    const isSelected = (tag.entityKinds || []).includes(ek.kind);\n    const current = tag.entityKinds || [];\n    const updated = isSelected\n      ? current.filter((k) => k !== ek.kind)\n      : [...current, ek.kind];\n    updateTag(tag.tag, { entityKinds: updated });\n  };\n\n  return (\n    <div className=\"editor-container tre-container\">\n      <SectionHeader\n        title=\"Tag Registry\"\n        description=\"Define tags that categorize entities. Tags provide governance through usage limits, relationships, and conflicts.\"\n      />\n\n      {/* Stats Bar - Compact */}\n      <div className=\"tre-stats-bar\">\n        <span className=\"text-small tre-stat-total\">\n          <strong>{stats.total}</strong> tags\n        </span>\n        {CATEGORIES.filter((cat) => stats.byCategory[cat] > 0).map((cat) => (\n          <span\n            key={cat}\n            className=\"text-small tre-stat-category\"\n            style={{\n              '--tre-stat-bg': CATEGORY_COLORS[cat].bg,\n              '--tre-stat-color': CATEGORY_COLORS[cat].color,\n            }}\n          >\n            {stats.byCategory[cat]} {cat}\n          </span>\n        ))}\n      </div>\n\n      {/* Toolbar */}\n      <div className=\"tre-toolbar\">\n        <input\n          className=\"input tre-search\"\n          type=\"text\"\n          placeholder=\"Search tags...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n        />\n        <select\n          className=\"input\"\n          value={categoryFilter}\n          onChange={(e) => setCategoryFilter(e.target.value)}\n        >\n          <option value=\"all\">All Categories</option>\n          {CATEGORIES.map((cat) => (\n            <option key={cat} value={cat}>\n              {cat}\n            </option>\n          ))}\n        </select>\n        <select\n          className=\"input\"\n          value={rarityFilter}\n          onChange={(e) => setRarityFilter(e.target.value)}\n        >\n          <option value=\"all\">All Rarities</option>\n          {RARITIES.map((r) => (\n            <option key={r} value={r}>\n              {r}\n            </option>\n          ))}\n        </select>\n        <span className=\"text-muted\">\n          {filteredTags.length} of {tagRegistry.length} tags\n        </span>\n        <button className=\"btn btn-primary\" onClick={addTag}>\n          + Add Tag\n        </button>\n      </div>\n\n      {tagRegistry.length === 0 && (\n        <EmptyState icon=\"\ud83c\udff7\ufe0f\" title=\"No tags defined\" description=\"Add one to get started.\" />\n      )}\n      {tagRegistry.length > 0 && filteredTags.length === 0 && (\n        <EmptyState icon=\"\ud83d\udd0d\" title=\"No matches\" description=\"No tags match your filters.\" />\n      )}\n      {filteredTags.length > 0 && (\n        <div className=\"list-stack\">\n          {filteredTags.map((tag) => {\n            const isExpanded = expandedTags[tag.tag];\n            const catColor = CATEGORY_COLORS[tag.category] || CATEGORY_COLORS.trait;\n            const rarColor = RARITY_COLORS[tag.rarity] || RARITY_COLORS.common;\n            const isFramework = Boolean(tag.isFramework);\n\n            return (\n              <ExpandableCard\n                key={tag.tag}\n                expanded={isExpanded}\n                onToggle={toggleTag}\n                toggleId={tag.tag}\n                title={renderTagTitle(tag)}\n                actions={renderTagActions(tag, catColor, rarColor, isFramework)}\n              >\n                {/* Basic Info Row */}\n                <div className=\"tre-basic-row\">\n                  <div className=\"tre-field-id\">\n                    <div className=\"label tre-label-gap\">\n                      Tag ID\n                    </div>\n                    <TagIdInput\n                      value={tag.tag}\n                      allTagIds={allTagNames.filter((t) => t !== tag.tag)}\n                      disabled={isFramework}\n                      onChange={(newId) => handleTagIdChange(tag.tag, newId)}\n                    />\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Category\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.category}\n                      onChange={(e) => updateTag(tag.tag, { category: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {CATEGORIES.map((cat) => (\n                        <option key={cat} value={cat}>\n                          {cat}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Rarity\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.rarity}\n                      onChange={(e) => updateTag(tag.tag, { rarity: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {RARITIES.map((r) => (\n                        <option key={r} value={r}>\n                          {r}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div className=\"tre-axis-group\">\n                    <label className=\"tre-axis-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={tag.isAxis || false}\n                        disabled={isFramework}\n                        onChange={(e) => updateTag(tag.tag, { isAxis: e.target.checked })}\n                        className=\"tre-checkbox\"\n                      />\n// ... (truncated)", "parameters": [{"name": "{\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}", "type": "{ tagRegistry?: any[]; entityKinds?: any[]; onChange: any; tagUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableCard", "SectionHeader", "EmptyState", "NumberInput"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ToolUsageBadges as UsageBadges"], "category": "external"}, {"source": "./TagRegistryEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/actions/ActionsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/ActionsEditor.jsx", "sourceCode": "export default function ActionsEditor({\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"actions:selected\");\n  const {\n    selectedItem: selectedAction,\n    handleItemChange: handleActionChange,\n    handleToggle,\n    handleDelete,\n    handleAdd: handleAddAction,\n    handleSelect,\n    handleClose,\n  } = useEditorState(actions, onChange, { createItem: createAction, persistKey: selectionKey });\n\n  // Collect unique pressures across all actions\n  const uniquePressures = new Set();\n  actions.forEach((action) => {\n    (action.probability?.pressureModifiers || []).forEach((mod) => {\n      if (mod.pressure) uniquePressures.add(mod.pressure);\n    });\n  });\n\n  return (\n    <div className=\"actions-editor\">\n      <div className=\"actions-header\">\n        <h1 className=\"actions-title\">Actions</h1>\n        <p className=\"actions-subtitle\">\n          Actions define what agents can do during the simulation via the universal catalyst system.\n          Click an action to edit.\n        </p>\n        <div className=\"actions-stats\">\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Total Actions</span>\n            <span className=\"actions-stat-value\">{actions.length}</span>\n          </div>\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Pressures Referenced</span>\n            <span className=\"actions-stat-value\">{uniquePressures.size}</span>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"actions-grid\">\n        {actions.map((action, index) => (\n          <ActionListCard\n            key={action.id}\n            action={action}\n            onClick={() => handleSelect(index)}\n            onToggle={() => handleToggle(action)}\n            usageMap={usageMap}\n          />\n        ))}\n\n        <div className=\"actions-add-card\" onClick={() => handleAddAction()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <span className=\"text-2xl\">+</span>\n          <span>Add Action</span>\n        </div>\n      </div>\n\n      {selectedAction && (\n        <ActionModal\n          action={selectedAction}\n          onChange={handleActionChange}\n          onClose={handleClose}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; actions?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../shared", "specifiers": ["useEditorState"], "category": "internal"}, {"source": "../../utils/persistence", "specifiers": ["buildStorageKey"], "category": "internal"}, {"source": "./cards", "specifiers": ["ActionListCard"], "category": "internal"}, {"source": "./modals", "specifiers": ["ActionModal"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/actions/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/index.js", "sourceCode": "export default function ActionsEditor({\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"actions:selected\");\n  const {\n    selectedItem: selectedAction,\n    handleItemChange: handleActionChange,\n    handleToggle,\n    handleDelete,\n    handleAdd: handleAddAction,\n    handleSelect,\n    handleClose,\n  } = useEditorState(actions, onChange, { createItem: createAction, persistKey: selectionKey });\n\n  // Collect unique pressures across all actions\n  const uniquePressures = new Set();\n  actions.forEach((action) => {\n    (action.probability?.pressureModifiers || []).forEach((mod) => {\n      if (mod.pressure) uniquePressures.add(mod.pressure);\n    });\n  });\n\n  return (\n    <div className=\"actions-editor\">\n      <div className=\"actions-header\">\n        <h1 className=\"actions-title\">Actions</h1>\n        <p className=\"actions-subtitle\">\n          Actions define what agents can do during the simulation via the universal catalyst system.\n          Click an action to edit.\n        </p>\n        <div className=\"actions-stats\">\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Total Actions</span>\n            <span className=\"actions-stat-value\">{actions.length}</span>\n          </div>\n          <div className=\"actions-stat\">\n            <span className=\"actions-stat-label\">Pressures Referenced</span>\n            <span className=\"actions-stat-value\">{uniquePressures.size}</span>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"actions-grid\">\n        {actions.map((action, index) => (\n          <ActionListCard\n            key={action.id}\n            action={action}\n            onClick={() => handleSelect(index)}\n            onToggle={() => handleToggle(action)}\n            usageMap={usageMap}\n          />\n        ))}\n\n        <div className=\"actions-add-card\" onClick={() => handleAddAction()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <span className=\"text-2xl\">+</span>\n          <span>Add Action</span>\n        </div>\n      </div>\n\n      {selectedAction && (\n        <ActionModal\n          action={selectedAction}\n          onChange={handleActionChange}\n          onClose={handleClose}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  actions = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; actions?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/causal-loop/CausalLoopEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/causal-loop/CausalLoopEditor.jsx", "sourceCode": "export default function CausalLoopEditor({\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}) {\n  const containerRef = useRef(null);\n  const graphRef = useRef(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [showLegend, setShowLegend] = useState(true);\n  const [showDisabled, setShowDisabled] = useState(true);\n  const [hoverNode, setHoverNode] = useState(null);\n\n  // Resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const updateDimensions = () => {\n      const rect = containerRef.current.getBoundingClientRect();\n      setDimensions({\n        width: rect.width || 800,\n        height: Math.max(500, window.innerHeight - rect.top - 100),\n      });\n    };\n\n    updateDimensions();\n    const observer = new ResizeObserver(updateDimensions);\n    observer.observe(containerRef.current);\n    window.addEventListener(\"resize\", updateDimensions);\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, []);\n\n  // Extract graph data\n  const {\n    nodes: graphNodes,\n    links: graphLinks,\n    warnings,\n  } = useMemo(\n    () =>\n      extractCausalGraph(pressures, generators, systems, actions, schema, showDisabled, usageMap),\n    [pressures, generators, systems, actions, schema, showDisabled, usageMap]\n  );\n  const graphData = useMemo(\n    () => ({ nodes: graphNodes, links: graphLinks }),\n    [graphNodes, graphLinks]\n  );\n\n  // Count disabled nodes for UI\n  const disabledCount = useMemo(() => {\n    const allNodes = extractCausalGraph(\n      pressures,\n      generators,\n      systems,\n      actions,\n      schema,\n      true,\n      usageMap\n    ).nodes;\n    return allNodes.filter((n) => n.isDisabled).length;\n  }, [pressures, generators, systems, actions, schema, usageMap]);\n\n  // Detect loops\n  const loops = useMemo(() => detectLoops(graphData.nodes, graphData.links), [graphData]);\n\n  const reinforcingLoops = loops.filter((l) => l.type === \"reinforcing\");\n  const balancingLoops = loops.filter((l) => l.type === \"balancing\");\n\n  // Node styling\n  const nodeCanvasObject = useCallback(\n    (node, ctx, globalScale) => {\n      const label = node.label;\n      const fontSize = Math.max(10 / globalScale, 3);\n      const abbrevFontSize = Math.max(8 / globalScale, 3);\n      const nodeRadius = Math.sqrt(node.val) * 3;\n      const isDisabled = node.isDisabled;\n\n      // Draw node circle with opacity for disabled\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = isDisabled ? `${node.color}60` : node.color;\n      ctx.fill();\n\n      // Strikethrough pattern for disabled nodes\n      if (isDisabled) {\n        ctx.strokeStyle = \"#64748b\";\n        ctx.lineWidth = 1 / globalScale;\n        ctx.setLineDash([2 / globalScale, 2 / globalScale]);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // Highlight selected/hovered\n      if (selectedNode === node.id || hoverNode === node.id) {\n        ctx.strokeStyle = \"#ffffff\";\n        ctx.lineWidth = 2 / globalScale;\n        ctx.stroke();\n      }\n\n      // Draw abbreviation inside node\n      ctx.font = `bold ${abbrevFontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#0a1929\";\n      ctx.fillText(node.abbrev || \"?\", node.x, node.y);\n\n      // Draw label below node\n      ctx.font = `${fontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"top\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#e2e8f0\";\n      const displayLabel = label.length > 15 ? label.slice(0, 13) + \"...\" : label;\n      ctx.fillText(displayLabel, node.x, node.y + nodeRadius + 2);\n    },\n    [selectedNode, hoverNode]\n  );\n\n  // Link styling\n  const linkColor = useCallback((link) => {\n    return EDGE_COLORS[link.polarity] || EDGE_COLORS.neutral;\n  }, []);\n\n  const linkWidth = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? 1 : 2;\n  }, []);\n\n  const linkLineDash = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? [4, 4] : [];\n  }, []);\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node) => {\n      setSelectedNode(selectedNode === node.id ? null : node.id);\n    },\n    [selectedNode]\n  );\n\n  // Zoom to fit on load\n  useEffect(() => {\n    if (graphRef.current && graphData.nodes.length > 0) {\n      setTimeout(() => {\n        graphRef.current.zoomToFit(400, 60);\n      }, 500);\n    }\n  }, [graphData.nodes.length]);\n\n  const selectedNodeData = selectedNode ? graphData.nodes.find((n) => n.id === selectedNode) : null;\n\n  // Get edges for selected node\n  const selectedNodeEdges = useMemo(() => {\n    if (!selectedNode) return { incoming: [], outgoing: [] };\n    return {\n      incoming: graphData.links.filter((l) => {\n        const targetId = typeof l.target === \"object\" ? l.target.id : l.target;\n        return targetId === selectedNode;\n      }),\n      outgoing: graphData.links.filter((l) => {\n        const sourceId = typeof l.source === \"object\" ? l.source.id : l.source;\n        return sourceId === selectedNode;\n      }),\n    };\n  }, [selectedNode, graphData.links]);\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Causal Loop Diagram</h1>\n        <p className=\"subtitle\">\n          Visualize feedback loops between pressures, generators, systems, and entity kinds.\n          {loops.length > 0 && (\n            <span className=\"cl-loop-count\">\n              <span className=\"cl-loop-reinforcing\">{reinforcingLoops.length} reinforcing</span>\n              {\" / \"}\n              <span className=\"cl-loop-balancing\">{balancingLoops.length} balancing</span>\n              {\" loops detected\"}\n            </span>\n          )}\n        </p>\n      </div>\n\n      <div className=\"cl-toolbar\">\n        <button className=\"button-secondary\" onClick={() => setShowLegend(!showLegend)}>\n          {showLegend ? \"Hide\" : \"Show\"} Legend\n        </button>\n        {disabledCount > 0 && (\n          <button\n            className=\"button-secondary\"\n            onClick={() => setShowDisabled(!showDisabled)}\n            // eslint-disable-next-line local/no-inline-styles -- dynamic opacity toggle\n            style={{ opacity: showDisabled ? 1 : 0.7 }}\n          >\n            {showDisabled ? \"Hide\" : \"Show\"} Disabled ({disabledCount})\n          </button>\n        )}\n        <button className=\"button-secondary\" onClick={() => graphRef.current?.zoomToFit(400, 60)}>\n          Fit to View\n        </button>\n        <div className=\"cl-stats\">\n          <span>{graphData.nodes.length} nodes</span>\n          <span>{graphData.links.length} edges</span>\n          {warnings.length > 0 && (\n            <span className=\"cl-stats-warning\">{warnings.length} warnings</span>\n          )}\n          <span className=\"cl-stats-hint\">Scroll to zoom, drag to pan</span>\n        </div>\n      </div>\n\n      {/* Warnings */}\n      {warnings.length > 0 && (\n        <div className=\"cl-warnings-box\">\n          <div className=\"cl-warnings-title\">\n            Referential Integrity Warnings\n          </div>\n          <div className=\"cl-warnings-list\">\n            {warnings.slice(0, 5).map((w, i) => (\n              <div key={i}>{w.message}</div>\n            ))}\n            {warnings.length > 5 && (\n              <div className=\"cl-warnings-more\">\n                ...and {warnings.length - 5} more warnings\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Legend */}\n      {showLegend && (\n        <div className=\"cl-legend\">\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Nodes:</span>\n            {Object.entries(NODE_TYPES).map(([type, config]) => (\n              <span key={type} className=\"cl-legend-item\">\n                <span\n                  className=\"cl-legend-node\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic color per node type\n                  style={{ '--cl-node-color': config.color, backgroundColor: 'var(--cl-node-color)' }}\n                >\n                  {config.abbrev}\n                </span>\n                <span className=\"cl-legend-node-label\">{config.label}</span>\n              </span>\n            ))}\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Edges:</span>\n            <span className=\"cl-legend-item cl-edge-positive\">+ Positive</span>\n            <span className=\"cl-legend-item cl-edge-negative\">- Negative</span>\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Loops:</span>\n            <span className=\"cl-legend-item cl-loop-reinforcing\">Reinforcing (unstable)</span>\n            <span className=\"cl-legend-item cl-loop-balancing\">Balancing (stable)</span>\n          </div>\n        </div>\n      )}\n\n      {/* Graph container */}\n      <div ref={containerRef} className=\"cl-graph-container\">\n        {graphData.nodes.length === 0 ? (\n          <div className=\"cl-empty-state\">\n            <div className=\"cl-empty-icon\">&#128260;</div>\n            <div className=\"cl-empty-title\">\n              No causal relationships found\n            </div>\n            <div className=\"cl-empty-desc\">\n              Add pressures with feedback factors, generators with state updates, or systems with\n              pressure changes to see the causal loop diagram.\n            </div>\n          </div>\n        ) : (\n          <ForceGraph2D\n            ref={graphRef}\n            graphData={graphData}\n            width={dimensions.width}\n            height={dimensions.height}\n            backgroundColor=\"#0f172a\"\n            nodeCanvasObject={nodeCanvasObject}\n            nodePointerAreaPaint={(node, color, ctx) => {\n              const nodeRadius = Math.sqrt(node.val) * 3;\n              ctx.beginPath();\n              ctx.arc(node.x, node.y, nodeRadius + 5, 0, 2 * Math.PI);\n              ctx.fillStyle = color;\n              ctx.fill();\n            }}\n            linkColor={linkColor}\n            linkWidth={linkWidth}\n            linkLineDash={linkLineDash}\n            linkDirectionalArrowLength={6}\n            linkDirectionalArrowRelPos={0.9}\n            linkCurvature={0.2}\n            onNodeClick={handleNodeClick}\n            onNodeHover={(node) => setHoverNode(node?.id || null)}\n// ... (truncated)", "parameters": [{"name": "{\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}", "type": "{ pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; schema?: {}; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useRef", "useCallback", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "react-force-graph-2d", "specifiers": ["ForceGraph2D"], "category": "external"}, {"source": "./CausalLoopEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/causal-loop/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/causal-loop/index.js", "sourceCode": "export default function CausalLoopEditor({\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}) {\n  const containerRef = useRef(null);\n  const graphRef = useRef(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [showLegend, setShowLegend] = useState(true);\n  const [showDisabled, setShowDisabled] = useState(true);\n  const [hoverNode, setHoverNode] = useState(null);\n\n  // Resize observer\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const updateDimensions = () => {\n      const rect = containerRef.current.getBoundingClientRect();\n      setDimensions({\n        width: rect.width || 800,\n        height: Math.max(500, window.innerHeight - rect.top - 100),\n      });\n    };\n\n    updateDimensions();\n    const observer = new ResizeObserver(updateDimensions);\n    observer.observe(containerRef.current);\n    window.addEventListener(\"resize\", updateDimensions);\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, []);\n\n  // Extract graph data\n  const {\n    nodes: graphNodes,\n    links: graphLinks,\n    warnings,\n  } = useMemo(\n    () =>\n      extractCausalGraph(pressures, generators, systems, actions, schema, showDisabled, usageMap),\n    [pressures, generators, systems, actions, schema, showDisabled, usageMap]\n  );\n  const graphData = useMemo(\n    () => ({ nodes: graphNodes, links: graphLinks }),\n    [graphNodes, graphLinks]\n  );\n\n  // Count disabled nodes for UI\n  const disabledCount = useMemo(() => {\n    const allNodes = extractCausalGraph(\n      pressures,\n      generators,\n      systems,\n      actions,\n      schema,\n      true,\n      usageMap\n    ).nodes;\n    return allNodes.filter((n) => n.isDisabled).length;\n  }, [pressures, generators, systems, actions, schema, usageMap]);\n\n  // Detect loops\n  const loops = useMemo(() => detectLoops(graphData.nodes, graphData.links), [graphData]);\n\n  const reinforcingLoops = loops.filter((l) => l.type === \"reinforcing\");\n  const balancingLoops = loops.filter((l) => l.type === \"balancing\");\n\n  // Node styling\n  const nodeCanvasObject = useCallback(\n    (node, ctx, globalScale) => {\n      const label = node.label;\n      const fontSize = Math.max(10 / globalScale, 3);\n      const abbrevFontSize = Math.max(8 / globalScale, 3);\n      const nodeRadius = Math.sqrt(node.val) * 3;\n      const isDisabled = node.isDisabled;\n\n      // Draw node circle with opacity for disabled\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);\n      ctx.fillStyle = isDisabled ? `${node.color}60` : node.color;\n      ctx.fill();\n\n      // Strikethrough pattern for disabled nodes\n      if (isDisabled) {\n        ctx.strokeStyle = \"#64748b\";\n        ctx.lineWidth = 1 / globalScale;\n        ctx.setLineDash([2 / globalScale, 2 / globalScale]);\n        ctx.stroke();\n        ctx.setLineDash([]);\n      }\n\n      // Highlight selected/hovered\n      if (selectedNode === node.id || hoverNode === node.id) {\n        ctx.strokeStyle = \"#ffffff\";\n        ctx.lineWidth = 2 / globalScale;\n        ctx.stroke();\n      }\n\n      // Draw abbreviation inside node\n      ctx.font = `bold ${abbrevFontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#0a1929\";\n      ctx.fillText(node.abbrev || \"?\", node.x, node.y);\n\n      // Draw label below node\n      ctx.font = `${fontSize}px Sans-Serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"top\";\n      ctx.fillStyle = isDisabled ? \"#64748b\" : \"#e2e8f0\";\n      const displayLabel = label.length > 15 ? label.slice(0, 13) + \"...\" : label;\n      ctx.fillText(displayLabel, node.x, node.y + nodeRadius + 2);\n    },\n    [selectedNode, hoverNode]\n  );\n\n  // Link styling\n  const linkColor = useCallback((link) => {\n    return EDGE_COLORS[link.polarity] || EDGE_COLORS.neutral;\n  }, []);\n\n  const linkWidth = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? 1 : 2;\n  }, []);\n\n  const linkLineDash = useCallback((link) => {\n    return link.edgeType === \"feedback\" ? [4, 4] : [];\n  }, []);\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node) => {\n      setSelectedNode(selectedNode === node.id ? null : node.id);\n    },\n    [selectedNode]\n  );\n\n  // Zoom to fit on load\n  useEffect(() => {\n    if (graphRef.current && graphData.nodes.length > 0) {\n      setTimeout(() => {\n        graphRef.current.zoomToFit(400, 60);\n      }, 500);\n    }\n  }, [graphData.nodes.length]);\n\n  const selectedNodeData = selectedNode ? graphData.nodes.find((n) => n.id === selectedNode) : null;\n\n  // Get edges for selected node\n  const selectedNodeEdges = useMemo(() => {\n    if (!selectedNode) return { incoming: [], outgoing: [] };\n    return {\n      incoming: graphData.links.filter((l) => {\n        const targetId = typeof l.target === \"object\" ? l.target.id : l.target;\n        return targetId === selectedNode;\n      }),\n      outgoing: graphData.links.filter((l) => {\n        const sourceId = typeof l.source === \"object\" ? l.source.id : l.source;\n        return sourceId === selectedNode;\n      }),\n    };\n  }, [selectedNode, graphData.links]);\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Causal Loop Diagram</h1>\n        <p className=\"subtitle\">\n          Visualize feedback loops between pressures, generators, systems, and entity kinds.\n          {loops.length > 0 && (\n            <span className=\"cl-loop-count\">\n              <span className=\"cl-loop-reinforcing\">{reinforcingLoops.length} reinforcing</span>\n              {\" / \"}\n              <span className=\"cl-loop-balancing\">{balancingLoops.length} balancing</span>\n              {\" loops detected\"}\n            </span>\n          )}\n        </p>\n      </div>\n\n      <div className=\"cl-toolbar\">\n        <button className=\"button-secondary\" onClick={() => setShowLegend(!showLegend)}>\n          {showLegend ? \"Hide\" : \"Show\"} Legend\n        </button>\n        {disabledCount > 0 && (\n          <button\n            className=\"button-secondary\"\n            onClick={() => setShowDisabled(!showDisabled)}\n            // eslint-disable-next-line local/no-inline-styles -- dynamic opacity toggle\n            style={{ opacity: showDisabled ? 1 : 0.7 }}\n          >\n            {showDisabled ? \"Hide\" : \"Show\"} Disabled ({disabledCount})\n          </button>\n        )}\n        <button className=\"button-secondary\" onClick={() => graphRef.current?.zoomToFit(400, 60)}>\n          Fit to View\n        </button>\n        <div className=\"cl-stats\">\n          <span>{graphData.nodes.length} nodes</span>\n          <span>{graphData.links.length} edges</span>\n          {warnings.length > 0 && (\n            <span className=\"cl-stats-warning\">{warnings.length} warnings</span>\n          )}\n          <span className=\"cl-stats-hint\">Scroll to zoom, drag to pan</span>\n        </div>\n      </div>\n\n      {/* Warnings */}\n      {warnings.length > 0 && (\n        <div className=\"cl-warnings-box\">\n          <div className=\"cl-warnings-title\">\n            Referential Integrity Warnings\n          </div>\n          <div className=\"cl-warnings-list\">\n            {warnings.slice(0, 5).map((w, i) => (\n              <div key={i}>{w.message}</div>\n            ))}\n            {warnings.length > 5 && (\n              <div className=\"cl-warnings-more\">\n                ...and {warnings.length - 5} more warnings\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Legend */}\n      {showLegend && (\n        <div className=\"cl-legend\">\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Nodes:</span>\n            {Object.entries(NODE_TYPES).map(([type, config]) => (\n              <span key={type} className=\"cl-legend-item\">\n                <span\n                  className=\"cl-legend-node\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic color per node type\n                  style={{ '--cl-node-color': config.color, backgroundColor: 'var(--cl-node-color)' }}\n                >\n                  {config.abbrev}\n                </span>\n                <span className=\"cl-legend-node-label\">{config.label}</span>\n              </span>\n            ))}\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Edges:</span>\n            <span className=\"cl-legend-item cl-edge-positive\">+ Positive</span>\n            <span className=\"cl-legend-item cl-edge-negative\">- Negative</span>\n          </div>\n          <div className=\"cl-legend-group\">\n            <span className=\"cl-legend-label\">Loops:</span>\n            <span className=\"cl-legend-item cl-loop-reinforcing\">Reinforcing (unstable)</span>\n            <span className=\"cl-legend-item cl-loop-balancing\">Balancing (stable)</span>\n          </div>\n        </div>\n      )}\n\n      {/* Graph container */}\n      <div ref={containerRef} className=\"cl-graph-container\">\n        {graphData.nodes.length === 0 ? (\n          <div className=\"cl-empty-state\">\n            <div className=\"cl-empty-icon\">&#128260;</div>\n            <div className=\"cl-empty-title\">\n              No causal relationships found\n            </div>\n            <div className=\"cl-empty-desc\">\n              Add pressures with feedback factors, generators with state updates, or systems with\n              pressure changes to see the causal loop diagram.\n            </div>\n          </div>\n        ) : (\n          <ForceGraph2D\n            ref={graphRef}\n            graphData={graphData}\n            width={dimensions.width}\n            height={dimensions.height}\n            backgroundColor=\"#0f172a\"\n            nodeCanvasObject={nodeCanvasObject}\n            nodePointerAreaPaint={(node, color, ctx) => {\n              const nodeRadius = Math.sqrt(node.val) * 3;\n              ctx.beginPath();\n              ctx.arc(node.x, node.y, nodeRadius + 5, 0, 2 * Math.PI);\n              ctx.fillStyle = color;\n              ctx.fill();\n            }}\n            linkColor={linkColor}\n            linkWidth={linkWidth}\n            linkLineDash={linkLineDash}\n            linkDirectionalArrowLength={6}\n            linkDirectionalArrowRelPos={0.9}\n            linkCurvature={0.2}\n            onNodeClick={handleNodeClick}\n            onNodeHover={(node) => setHoverNode(node?.id || null)}\n// ... (truncated)", "parameters": [{"name": "{\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  schema = {},\n  usageMap,\n}", "type": "{ pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; schema?: {}; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/dependency-viewer/DependencyViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/dependency-viewer/DependencyViewer.jsx", "sourceCode": "export default function DependencyViewer({ usageMap }) {\n  // Prepare entity kinds data\n  const entityKindsData = useMemo(() => {\n    if (!usageMap?.entityKinds) return [];\n    return Object.entries(usageMap.entityKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare relationship kinds data\n  const relationshipKindsData = useMemo(() => {\n    if (!usageMap?.relationshipKinds) return [];\n    return Object.entries(usageMap.relationshipKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare pressures data\n  const pressuresData = useMemo(() => {\n    if (!usageMap?.pressures) return [];\n    return Object.entries(usageMap.pressures)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare generators data\n  const generatorsData = useMemo(() => {\n    if (!usageMap?.generators) return [];\n    return Object.entries(usageMap.generators)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare systems data\n  const systemsData = useMemo(() => {\n    if (!usageMap?.systems) return [];\n    return Object.entries(usageMap.systems)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare tags data\n  const tagsData = useMemo(() => {\n    if (!usageMap?.tags) return [];\n    return Object.entries(usageMap.tags)\n      .map(([tag, usage]) => ({\n        id: tag,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  if (!usageMap) {\n    return (\n      <div className=\"dependency-viewer-container\">\n        <div className=\"dependency-empty-state\">Loading dependency data...</div>\n      </div>\n    );\n  }\n\n  const renderSchemaItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      <UsageBadges usage={item.usage} />\n    </div>\n  );\n\n  const renderEraItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      {item.eraCount > 0 ? (\n        <div className=\"dependency-used-by-list\">\n          <span className=\"dependency-badge dependency-badge-era\">\n            {item.eraCount} era{item.eraCount !== 1 ? \"s\" : \"\"}\n          </span>\n        </div>\n      ) : (\n        <span className=\"dependency-orphan-badge\">Not in any era</span>\n      )}\n    </div>\n  );\n\n  return (\n    <div className=\"dependency-viewer-container\">\n      <div className=\"dependency-viewer-header\">\n        <div className=\"dependency-viewer-title\">\n          <span>\ud83d\udd17</span>\n          <span>Dependencies</span>\n        </div>\n        <div className=\"dependency-viewer-legend\">\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-generators\" />\n            <span>Generators</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-systems\" />\n            <span>Systems</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-actions\" />\n            <span>Actions</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-eras\" />\n            <span>Eras</span>\n          </div>\n        </div>\n      </div>\n\n      <DependencySection\n        title=\"Entity Kinds\"\n        icon=\"\ud83d\udce6\"\n        items={entityKindsData}\n        renderItem={renderSchemaItem}\n        defaultExpanded={true}\n      />\n\n      <DependencySection\n        title=\"Relationship Kinds\"\n        icon=\"\ud83d\udd17\"\n        items={relationshipKindsData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection title=\"Tags\" icon=\"\ud83c\udff7\ufe0f\" items={tagsData} renderItem={renderSchemaItem} />\n\n      <DependencySection\n        title=\"Pressures\"\n        icon=\"\ud83d\udcca\"\n        items={pressuresData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection\n        title=\"Generators \u2192 Eras\"\n        icon=\"\u2728\"\n        items={generatorsData}\n        renderItem={renderEraItem}\n      />\n\n      <DependencySection\n        title=\"Systems \u2192 Eras\"\n        icon=\"\u2699\ufe0f\"\n        items={systemsData}\n        renderItem={renderEraItem}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ usageMap }", "type": "{ usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./dependency-viewer.css", "specifiers": [], "category": "internal"}, {"source": "./components", "specifiers": ["DependencySection", "UsageBadges"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/dependency-viewer/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/dependency-viewer/index.js", "sourceCode": "export default function DependencyViewer({ usageMap }) {\n  // Prepare entity kinds data\n  const entityKindsData = useMemo(() => {\n    if (!usageMap?.entityKinds) return [];\n    return Object.entries(usageMap.entityKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare relationship kinds data\n  const relationshipKindsData = useMemo(() => {\n    if (!usageMap?.relationshipKinds) return [];\n    return Object.entries(usageMap.relationshipKinds)\n      .map(([kind, usage]) => ({\n        id: kind,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare pressures data\n  const pressuresData = useMemo(() => {\n    if (!usageMap?.pressures) return [];\n    return Object.entries(usageMap.pressures)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  // Prepare generators data\n  const generatorsData = useMemo(() => {\n    if (!usageMap?.generators) return [];\n    return Object.entries(usageMap.generators)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare systems data\n  const systemsData = useMemo(() => {\n    if (!usageMap?.systems) return [];\n    return Object.entries(usageMap.systems)\n      .map(([id, usage]) => ({\n        id,\n        usage,\n        eraCount: usage.eras?.length || 0,\n      }))\n      .sort((a, b) => b.eraCount - a.eraCount);\n  }, [usageMap]);\n\n  // Prepare tags data\n  const tagsData = useMemo(() => {\n    if (!usageMap?.tags) return [];\n    return Object.entries(usageMap.tags)\n      .map(([tag, usage]) => ({\n        id: tag,\n        usage,\n        totalUsage:\n          (usage.generators?.length || 0) +\n          (usage.systems?.length || 0) +\n          (usage.actions?.length || 0) +\n          (usage.pressures?.length || 0),\n      }))\n      .sort((a, b) => b.totalUsage - a.totalUsage);\n  }, [usageMap]);\n\n  if (!usageMap) {\n    return (\n      <div className=\"dependency-viewer-container\">\n        <div className=\"dependency-empty-state\">Loading dependency data...</div>\n      </div>\n    );\n  }\n\n  const renderSchemaItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      <UsageBadges usage={item.usage} />\n    </div>\n  );\n\n  const renderEraItem = (item) => (\n    <div key={item.id} className=\"dependency-item-row\">\n      <span className=\"dependency-item-name\">{item.id}</span>\n      {item.eraCount > 0 ? (\n        <div className=\"dependency-used-by-list\">\n          <span className=\"dependency-badge dependency-badge-era\">\n            {item.eraCount} era{item.eraCount !== 1 ? \"s\" : \"\"}\n          </span>\n        </div>\n      ) : (\n        <span className=\"dependency-orphan-badge\">Not in any era</span>\n      )}\n    </div>\n  );\n\n  return (\n    <div className=\"dependency-viewer-container\">\n      <div className=\"dependency-viewer-header\">\n        <div className=\"dependency-viewer-title\">\n          <span>\ud83d\udd17</span>\n          <span>Dependencies</span>\n        </div>\n        <div className=\"dependency-viewer-legend\">\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-generators\" />\n            <span>Generators</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-systems\" />\n            <span>Systems</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-actions\" />\n            <span>Actions</span>\n          </div>\n          <div className=\"dependency-legend-item\">\n            <div className=\"dependency-legend-dot dependency-legend-dot-eras\" />\n            <span>Eras</span>\n          </div>\n        </div>\n      </div>\n\n      <DependencySection\n        title=\"Entity Kinds\"\n        icon=\"\ud83d\udce6\"\n        items={entityKindsData}\n        renderItem={renderSchemaItem}\n        defaultExpanded={true}\n      />\n\n      <DependencySection\n        title=\"Relationship Kinds\"\n        icon=\"\ud83d\udd17\"\n        items={relationshipKindsData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection title=\"Tags\" icon=\"\ud83c\udff7\ufe0f\" items={tagsData} renderItem={renderSchemaItem} />\n\n      <DependencySection\n        title=\"Pressures\"\n        icon=\"\ud83d\udcca\"\n        items={pressuresData}\n        renderItem={renderSchemaItem}\n      />\n\n      <DependencySection\n        title=\"Generators \u2192 Eras\"\n        icon=\"\u2728\"\n        items={generatorsData}\n        renderItem={renderEraItem}\n      />\n\n      <DependencySection\n        title=\"Systems \u2192 Eras\"\n        icon=\"\u2699\ufe0f\"\n        items={systemsData}\n        renderItem={renderEraItem}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ usageMap }", "type": "{ usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/eras/ErasEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/eras/ErasEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.eras - Array of era objects\n * @param {Function} props.onChange - Called when eras change\n * @param {Array} props.pressures - Available pressures\n * @param {Object} props.schema - Domain schema\n */\nexport default function ErasEditor({ eras = [], onChange, pressures = [], schema }) {\n  const [expandedEra, setExpandedEra] = useState(null);\n\n  const handleEraChange = useCallback(\n    (index, updatedEra) => {\n      const newEras = [...eras];\n      newEras[index] = updatedEra;\n      onChange(newEras);\n    },\n    [eras, onChange]\n  );\n\n  const handleDeleteEra = useCallback(\n    (index) => {\n      if (confirm(`Delete era \"${eras[index].name}\"?`)) {\n        const newEras = eras.filter((_, i) => i !== index);\n        onChange(newEras);\n        if (expandedEra === index) {\n          setExpandedEra(null);\n        }\n      }\n    },\n    [eras, onChange, expandedEra]\n  );\n\n  const handleAddEra = useCallback(() => {\n    const newEra = {\n      id: `era_${Date.now()}`,\n      name: \"New Era\",\n      description: \"A new period in world history\",\n      templateWeights: {},\n      systemModifiers: {},\n      entryConditions: [],\n      entryEffects: { mutations: [] },\n      exitConditions: [{ type: \"growth_phases_complete\", minPhases: 2 }],\n      exitEffects: { mutations: [] },\n    };\n    onChange([...eras, newEra]);\n    setExpandedEra(eras.length);\n  }, [eras, onChange]);\n\n  if (eras.length === 0) {\n    return (\n      <div className=\"editor-container\">\n        <div className=\"header\">\n          <h1 className=\"title\">Eras</h1>\n          <p className=\"subtitle\">Define historical eras that structure world generation</p>\n        </div>\n        <div className=\"empty-state\">\n          <div className=\"empty-state-icon\">\ud83d\udd70\ufe0f</div>\n          <div className=\"empty-state-title\">No eras defined</div>\n          <div className=\"empty-state-desc\">\n            Eras control which generators and systems are active during different phases of world\n            history.\n          </div>\n          <button\n            className=\"btn btn-primary ee-create-btn\"\n            onClick={handleAddEra}\n          >\n            + Create First Era\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Eras</h1>\n        <p className=\"subtitle\">\n          Define historical eras that structure world generation. Each era controls which generators\n          and systems are active and at what strength.\n        </p>\n      </div>\n\n      <div className=\"list-stack\">\n        {eras.map((era, index) => (\n          <EraCard\n            key={era.id}\n            era={era}\n            expanded={expandedEra === index}\n            onToggle={() => setExpandedEra(expandedEra === index ? null : index)}\n            onChange={(updatedEra) => handleEraChange(index, updatedEra)}\n            onDelete={() => handleDeleteEra(index)}\n            pressures={pressures}\n            schema={schema}\n            allEras={eras}\n          />\n        ))}\n\n        <button className=\"btn btn-add\" onClick={handleAddEra}>\n          + Add Era\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ eras = [], onChange, pressures = [], schema }", "type": "{ eras: any[]; onChange: Function; pressures: any[]; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./EraCard", "specifiers": ["EraCard"], "category": "internal"}, {"source": "./ErasEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/GeneratorModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/GeneratorModal.jsx", "sourceCode": "export function GeneratorModal({\n  generator,\n  onChange,\n  onClose,\n  onDelete,\n  onDuplicate,\n  schema,\n  pressures,\n  eras,\n  usageMap,\n  tagRegistry = [],\n}) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n\n  const tabValidation = useMemo(\n    () => computeTabValidation(generator, usageMap),\n    [generator, usageMap]\n  );\n\n  const renderTabBadge = useCallback(\n    (tabId) => {\n      return <TabValidationBadge count={tabValidation.tabErrors[tabId]} />;\n    },\n    [tabValidation.tabErrors]\n  );\n\n  const sidebarFooter = tabValidation.isOrphan ? (\n    <div className=\"orphan-badge-container\">\n      <OrphanBadge isOrphan={true} />\n    </div>\n  ) : null;\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"overview\":\n        return (\n          <OverviewTab\n            generator={generator}\n            onChange={onChange}\n            onDelete={onDelete}\n            onDuplicate={onDuplicate}\n          />\n        );\n      case \"applicability\":\n        return (\n          <ApplicabilityTab\n            generator={generator}\n            onChange={onChange}\n            schema={schema}\n            pressures={pressures}\n            eras={eras}\n          />\n        );\n      case \"target\":\n        return <TargetTab generator={generator} onChange={onChange} schema={schema} />;\n      case \"variables\":\n        return <VariablesTab generator={generator} onChange={onChange} schema={schema} />;\n      case \"creation\":\n        return (\n          <CreationTab\n            generator={generator}\n            onChange={onChange}\n            schema={schema}\n            tagRegistry={tagRegistry}\n            pressures={pressures}\n          />\n        );\n      case \"relationships\":\n        return <RelationshipsTab generator={generator} onChange={onChange} schema={schema} />;\n      case \"effects\":\n        return (\n          <EffectsTab\n            generator={generator}\n            onChange={onChange}\n            pressures={pressures}\n            schema={schema}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <ModalShell\n      onClose={onClose}\n      icon=\"\u2699\ufe0f\"\n      title={generator.name || generator.id}\n      disabled={generator.enabled === false}\n      tabs={TABS}\n      activeTab={activeTab}\n      onTabChange={setActiveTab}\n      renderTabBadge={renderTabBadge}\n      sidebarFooter={sidebarFooter}\n    >\n      {renderTabContent()}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  generator,\n  onChange,\n  onClose,\n  onDelete,\n  onDuplicate,\n  schema,\n  pressures,\n  eras,\n  usageMap,\n  tagRegistry = [],\n}", "type": "{ generator: any; onChange: any; onClose: any; onDelete: any; onDuplicate: any; schema: any; pressures: any; eras: any; usageMap: any; tagRegistry?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["getElementValidation"], "category": "external"}, {"source": "./constants", "specifiers": ["TABS"], "category": "internal"}, {"source": "../shared", "specifiers": ["ModalShell", "TabValidationBadge", "OrphanBadge"], "category": "internal"}, {"source": "./tabs", "specifiers": ["OverviewTab", "TargetTab", "VariablesTab", "CreationTab", "RelationshipsTab", "EffectsTab", "ApplicabilityTab"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/GeneratorsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/GeneratorsEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.generators - Array of generator configurations\n * @param {Function} props.onChange - Callback when generators change\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport default function GeneratorsEditor({\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"generators:selected\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [expandedCategories, setExpandedCategories] = useState({});\n\n  // Derive selected generator from index - this ensures we always have the latest data\n  const resolvedIndex = selectedId ? generators.findIndex((g) => g.id === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedGenerator = selectedIndex !== null ? generators[selectedIndex] : null;\n\n  // Build entity kind info map for icons and labels\n  const entityKindInfo = useMemo(() => {\n    const info = {};\n    (schema?.entityKinds || []).forEach((ek) => {\n      info[ek.kind] = {\n        label: ek.description || ek.name || ek.kind,\n        icon: ek.icon || DEFAULT_KIND_ICONS[ek.kind] || \"\ud83d\udce6\",\n      };\n    });\n    return info;\n  }, [schema]);\n\n  // Group generators by the primary entity kind they create\n  const groupedGenerators = useMemo(() => {\n    const groups = {};\n\n    generators.forEach((generator) => {\n      // Get primary creation kind (first entity created, or target kind if no creation)\n      const createdKinds = (generator.creation || []).map((c) => c.kind).filter(Boolean);\n      const primaryKind = createdKinds[0] || generator.selection?.kind || \"uncategorized\";\n\n      if (!groups[primaryKind]) {\n        groups[primaryKind] = [];\n      }\n      groups[primaryKind].push(generator);\n    });\n\n    return groups;\n  }, [generators]);\n\n  // Get ordered list of categories\n  const categories = useMemo(() => {\n    // Order by schema entity kinds first, then any uncategorized\n    const schemaKinds = (schema?.entityKinds || []).map((ek) => ek.kind);\n    const usedKinds = Object.keys(groupedGenerators);\n\n    // Sort: schema kinds in order, then others alphabetically\n    return usedKinds.sort((a, b) => {\n      const aIdx = schemaKinds.indexOf(a);\n      const bIdx = schemaKinds.indexOf(b);\n      if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;\n      if (aIdx >= 0) return -1;\n      if (bIdx >= 0) return 1;\n      return a.localeCompare(b);\n    });\n  }, [groupedGenerators, schema]);\n\n  // Initialize expanded state for new categories\n  useEffect(() => {\n    const needsUpdate = categories.some((cat) => expandedCategories[cat] === undefined);\n    if (!needsUpdate) return;\n    const updated = { ...expandedCategories };\n    categories.forEach((cat) => {\n      if (updated[cat] === undefined) {\n        updated[cat] = true;\n      }\n    });\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync category expansion defaults when categories change\n    setExpandedCategories(updated);\n  }, [categories, expandedCategories]);\n\n  // Restore selectedId from storage when selectionKey changes\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!selectionKey) return;\n    if (selectedId) {\n      saveStoredValue(selectionKey, selectedId);\n    } else {\n      clearStoredValue(selectionKey);\n    }\n  }, [selectionKey, selectedId]);\n\n  // Clear invalid selectedId (during render)\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n    clearStoredValue(selectionKey);\n  }\n\n  const handleGeneratorChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex < generators.length) {\n        const newGenerators = [...generators];\n        newGenerators[selectedIndex] = updated;\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (generator) => {\n      const index = generators.findIndex((g) => g.id === generator.id);\n      if (index >= 0) {\n        const newGenerators = [...generators];\n        newGenerators[index] = {\n          ...generator,\n          enabled: generator.enabled === false ? true : false,\n        };\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedGenerator &&\n      confirm(`Delete generator \"${selectedGenerator.name || selectedGenerator.id}\"?`)\n    ) {\n      const newGenerators = [...generators];\n      newGenerators.splice(selectedIndex, 1);\n      onChange(newGenerators);\n      setSelectedId(null);\n    }\n  }, [generators, onChange, selectedIndex, selectedGenerator]);\n\n  const handleAdd = useCallback(() => {\n    const newGenerator = {\n      id: `generator_${Date.now()}`,\n      name: \"New Generator\",\n      applicability: [],\n      selection: { strategy: \"by_kind\", kind: \"location\", pickStrategy: \"random\" },\n      creation: [],\n      relationships: [],\n      stateUpdates: [],\n      variables: {},\n    };\n    onChange([...generators, newGenerator]);\n    setSelectedId(newGenerator.id);\n  }, [generators, onChange]);\n\n  const handleDuplicate = useCallback(() => {\n    if (!selectedGenerator) return;\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(selectedGenerator)), // Deep clone\n      id: `${selectedGenerator.id}_copy_${Date.now()}`,\n      name: `${selectedGenerator.name || selectedGenerator.id} (Copy)`,\n    };\n    onChange([...generators, duplicated]);\n    setSelectedId(duplicated.id);\n  }, [generators, onChange, selectedGenerator]);\n\n  const toggleCategoryExpand = useCallback((kind) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [kind]: !prev[kind],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (kind) => {\n      const categoryItems = groupedGenerators[kind] || [];\n      const allEnabled = categoryItems.every((g) => g.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of generators in this category\n      const categoryIds = new Set(categoryItems.map((g) => g.id));\n\n      const newGenerators = generators.map((g) => {\n        if (categoryIds.has(g.id)) {\n          return { ...g, enabled: newEnabled };\n        }\n        return g;\n      });\n      onChange(newGenerators);\n    },\n    [generators, groupedGenerators, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Generators</h1>\n        <p className=\"subtitle\">\n          Configure entity generators that populate your world. Click a generator to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((kind) => {\n        const kindInfo = entityKindInfo[kind] || {\n          label: kind.charAt(0).toUpperCase() + kind.slice(1),\n          icon: DEFAULT_KIND_ICONS[kind] || \"\ud83d\udce6\",\n        };\n        const categoryItems = groupedGenerators[kind] || [];\n        const allEnabled = categoryItems.every((g) => g.enabled !== false);\n\n        return (\n          <CategorySection\n            key={kind}\n            id={kind}\n            icon={kindInfo.icon}\n            label={`${kindInfo.label} Generators`}\n            items={categoryItems}\n            expanded={expandedCategories[kind] !== false}\n            onToggleExpand={() => toggleCategoryExpand(kind)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(kind)}\n            renderItem={(generator) => (\n              <GeneratorListCard\n                key={generator.id}\n                generator={generator}\n                onClick={() => setSelectedId(generator.id)}\n                onToggle={() => handleToggle(generator)}\n                usageMap={usageMap}\n              />\n            )}\n          />\n        );\n      })}\n\n      {/* Add Generator button */}\n      <div className=\"mt-lg\">\n        <AddCard onClick={handleAdd} label=\"Add Generator\" />\n      </div>\n\n      {selectedGenerator && (\n        <GeneratorModal\n          generator={selectedGenerator}\n          onChange={handleGeneratorChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          schema={schema}\n          pressures={pressures}\n          eras={eras}\n          usageMap={usageMap}\n          tagRegistry={schema.tagRegistry || []}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}", "type": "{ generators: any[]; onChange: Function; schema: any; pressures: any[]; eras: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../shared", "specifiers": ["CategorySection", "AddCard"], "category": "internal"}, {"source": "./GeneratorModal", "specifiers": ["GeneratorModal"], "category": "internal"}, {"source": "./cards", "specifiers": ["GeneratorListCard"], "category": "internal"}, {"source": "../../utils/persistence", "specifiers": ["buildStorageKey", "clearStoredValue", "loadStoredValue", "saveStoredValue"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.generators - Array of generator configurations\n * @param {Function} props.onChange - Callback when generators change\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport default function GeneratorsEditor({\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"generators:selected\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [expandedCategories, setExpandedCategories] = useState({});\n\n  // Derive selected generator from index - this ensures we always have the latest data\n  const resolvedIndex = selectedId ? generators.findIndex((g) => g.id === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedGenerator = selectedIndex !== null ? generators[selectedIndex] : null;\n\n  // Build entity kind info map for icons and labels\n  const entityKindInfo = useMemo(() => {\n    const info = {};\n    (schema?.entityKinds || []).forEach((ek) => {\n      info[ek.kind] = {\n        label: ek.description || ek.name || ek.kind,\n        icon: ek.icon || DEFAULT_KIND_ICONS[ek.kind] || \"\ud83d\udce6\",\n      };\n    });\n    return info;\n  }, [schema]);\n\n  // Group generators by the primary entity kind they create\n  const groupedGenerators = useMemo(() => {\n    const groups = {};\n\n    generators.forEach((generator) => {\n      // Get primary creation kind (first entity created, or target kind if no creation)\n      const createdKinds = (generator.creation || []).map((c) => c.kind).filter(Boolean);\n      const primaryKind = createdKinds[0] || generator.selection?.kind || \"uncategorized\";\n\n      if (!groups[primaryKind]) {\n        groups[primaryKind] = [];\n      }\n      groups[primaryKind].push(generator);\n    });\n\n    return groups;\n  }, [generators]);\n\n  // Get ordered list of categories\n  const categories = useMemo(() => {\n    // Order by schema entity kinds first, then any uncategorized\n    const schemaKinds = (schema?.entityKinds || []).map((ek) => ek.kind);\n    const usedKinds = Object.keys(groupedGenerators);\n\n    // Sort: schema kinds in order, then others alphabetically\n    return usedKinds.sort((a, b) => {\n      const aIdx = schemaKinds.indexOf(a);\n      const bIdx = schemaKinds.indexOf(b);\n      if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;\n      if (aIdx >= 0) return -1;\n      if (bIdx >= 0) return 1;\n      return a.localeCompare(b);\n    });\n  }, [groupedGenerators, schema]);\n\n  // Initialize expanded state for new categories\n  useEffect(() => {\n    const needsUpdate = categories.some((cat) => expandedCategories[cat] === undefined);\n    if (!needsUpdate) return;\n    const updated = { ...expandedCategories };\n    categories.forEach((cat) => {\n      if (updated[cat] === undefined) {\n        updated[cat] = true;\n      }\n    });\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync category expansion defaults when categories change\n    setExpandedCategories(updated);\n  }, [categories, expandedCategories]);\n\n  // Restore selectedId from storage when selectionKey changes\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!selectionKey) return;\n    if (selectedId) {\n      saveStoredValue(selectionKey, selectedId);\n    } else {\n      clearStoredValue(selectionKey);\n    }\n  }, [selectionKey, selectedId]);\n\n  // Clear invalid selectedId (during render)\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n    clearStoredValue(selectionKey);\n  }\n\n  const handleGeneratorChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex < generators.length) {\n        const newGenerators = [...generators];\n        newGenerators[selectedIndex] = updated;\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (generator) => {\n      const index = generators.findIndex((g) => g.id === generator.id);\n      if (index >= 0) {\n        const newGenerators = [...generators];\n        newGenerators[index] = {\n          ...generator,\n          enabled: generator.enabled === false ? true : false,\n        };\n        onChange(newGenerators);\n      }\n    },\n    [generators, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedGenerator &&\n      confirm(`Delete generator \"${selectedGenerator.name || selectedGenerator.id}\"?`)\n    ) {\n      const newGenerators = [...generators];\n      newGenerators.splice(selectedIndex, 1);\n      onChange(newGenerators);\n      setSelectedId(null);\n    }\n  }, [generators, onChange, selectedIndex, selectedGenerator]);\n\n  const handleAdd = useCallback(() => {\n    const newGenerator = {\n      id: `generator_${Date.now()}`,\n      name: \"New Generator\",\n      applicability: [],\n      selection: { strategy: \"by_kind\", kind: \"location\", pickStrategy: \"random\" },\n      creation: [],\n      relationships: [],\n      stateUpdates: [],\n      variables: {},\n    };\n    onChange([...generators, newGenerator]);\n    setSelectedId(newGenerator.id);\n  }, [generators, onChange]);\n\n  const handleDuplicate = useCallback(() => {\n    if (!selectedGenerator) return;\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(selectedGenerator)), // Deep clone\n      id: `${selectedGenerator.id}_copy_${Date.now()}`,\n      name: `${selectedGenerator.name || selectedGenerator.id} (Copy)`,\n    };\n    onChange([...generators, duplicated]);\n    setSelectedId(duplicated.id);\n  }, [generators, onChange, selectedGenerator]);\n\n  const toggleCategoryExpand = useCallback((kind) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [kind]: !prev[kind],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (kind) => {\n      const categoryItems = groupedGenerators[kind] || [];\n      const allEnabled = categoryItems.every((g) => g.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of generators in this category\n      const categoryIds = new Set(categoryItems.map((g) => g.id));\n\n      const newGenerators = generators.map((g) => {\n        if (categoryIds.has(g.id)) {\n          return { ...g, enabled: newEnabled };\n        }\n        return g;\n      });\n      onChange(newGenerators);\n    },\n    [generators, groupedGenerators, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Generators</h1>\n        <p className=\"subtitle\">\n          Configure entity generators that populate your world. Click a generator to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((kind) => {\n        const kindInfo = entityKindInfo[kind] || {\n          label: kind.charAt(0).toUpperCase() + kind.slice(1),\n          icon: DEFAULT_KIND_ICONS[kind] || \"\ud83d\udce6\",\n        };\n        const categoryItems = groupedGenerators[kind] || [];\n        const allEnabled = categoryItems.every((g) => g.enabled !== false);\n\n        return (\n          <CategorySection\n            key={kind}\n            id={kind}\n            icon={kindInfo.icon}\n            label={`${kindInfo.label} Generators`}\n            items={categoryItems}\n            expanded={expandedCategories[kind] !== false}\n            onToggleExpand={() => toggleCategoryExpand(kind)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(kind)}\n            renderItem={(generator) => (\n              <GeneratorListCard\n                key={generator.id}\n                generator={generator}\n                onClick={() => setSelectedId(generator.id)}\n                onToggle={() => handleToggle(generator)}\n                usageMap={usageMap}\n              />\n            )}\n          />\n        );\n      })}\n\n      {/* Add Generator button */}\n      <div className=\"mt-lg\">\n        <AddCard onClick={handleAdd} label=\"Add Generator\" />\n      </div>\n\n      {selectedGenerator && (\n        <GeneratorModal\n          generator={selectedGenerator}\n          onChange={handleGeneratorChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          schema={schema}\n          pressures={pressures}\n          eras={eras}\n          usageMap={usageMap}\n          tagRegistry={schema.tagRegistry || []}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  generators = [],\n  onChange,\n  schema,\n  pressures = [],\n  eras = [],\n  usageMap,\n}", "type": "{ generators: any[]; onChange: Function; schema: any; pressures: any[]; eras: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/index.js::createNewRule", "name": "createNewRule", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/index.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/index.js", "sourceCode": "export default function NamingProfileMappingViewer({ generators = [], schema = {} }) {\n  const [showInherited, setShowInherited] = useState(false);\n\n  const { mappings, warnings } = useMemo(\n    () => analyzeNamingMappings(generators, schema),\n    [generators, schema]\n  );\n\n  // Group by generator for display\n  const groupedMappings = useMemo(() => {\n    const groups = {};\n    for (const m of mappings) {\n      if (!groups[m.generatorId]) {\n        groups[m.generatorId] = {\n          generatorId: m.generatorId,\n          generatorName: m.generatorName,\n          items: [],\n        };\n      }\n      groups[m.generatorId].items.push(m);\n    }\n    return Object.values(groups);\n  }, [mappings]);\n\n  // Filter warnings - show all by default, but can filter to just explicit cultures\n  const displayWarnings = showInherited\n    ? warnings\n    : warnings.filter(\n        (w) => w.cultureSource === \"explicit\" || w.reason === \"No matching strategy group\"\n      );\n\n  const successCount = mappings.filter((m) => m.match).length;\n  const warningCount = warnings.filter((w) => w.reason === \"No matching strategy group\").length;\n\n  if (mappings.length === 0) {\n    return (\n      <div className=\"naming-profile-container\">\n        <div className=\"naming-profile-header\">\n          <div className=\"naming-profile-title\">\n            <span>Naming Profile Mappings</span>\n          </div>\n        </div>\n        <div className=\"naming-profile-empty-state\">\n          No generators with entity creation defined. Add generators to see naming profile mappings.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"naming-profile-container\">\n      <div className=\"naming-profile-header\">\n        <div className=\"naming-profile-title\">\n          <span>Naming Profile Mappings</span>\n        </div>\n        <div className=\"naming-profile-stats\">\n          <div className=\"naming-profile-stat-item\">\n            <span className=\"naming-profile-stat-value text-success\">{successCount}</span>\n            <span>matched</span>\n          </div>\n          <div className=\"naming-profile-stat-item\">\n            <span\n              className={`naming-profile-stat-value ${warningCount > 0 ? \"text-danger\" : \"text-muted\"}`}\n            >\n              {warningCount}\n            </span>\n            <span>missing</span>\n          </div>\n          <label className=\"cursor-pointer flex items-center gap-xs\">\n            <input\n              type=\"checkbox\"\n              checked={showInherited}\n              onChange={(e) => setShowInherited(e.target.checked)}\n            />\n            <span>Show inherited cultures</span>\n          </label>\n        </div>\n      </div>\n\n      <div className=\"naming-profile-content\">\n        {/* Warnings section */}\n        {displayWarnings.length > 0 && (\n          <div className=\"naming-profile-section\">\n            <div className=\"naming-profile-section-title\">\n              <span className=\"naming-profile-warning-icon\">Warning</span>\n              <span>Naming May Fail ({displayWarnings.length})</span>\n            </div>\n            <div className=\"naming-profile-warning-list\">\n              {displayWarnings.slice(0, 10).map((w, i) => (\n                <div\n                  key={`${w.generatorId}-${w.cultureId}-${i}`}\n                  className=\"naming-profile-warning-item\"\n                >\n                  <span className=\"naming-profile-warning-icon\">!</span>\n                  <span>\n                    <strong>{w.generatorName}</strong> creates <strong>{w.entityKind}</strong>\n                    {w.subtype && `:${w.subtype}`} for culture <strong>{w.cultureName}</strong> -{\" \"}\n                    {w.reason}\n                  </span>\n                </div>\n              ))}\n              {displayWarnings.length > 10 && (\n                <div\n                  className=\"text-muted py-md px-lg\"\n                >\n                  ... and {displayWarnings.length - 10} more\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Mappings table */}\n        <div className=\"naming-profile-section\">\n          <div className=\"naming-profile-section-title\">\n            <span>Entity Creation to Naming Profile</span>\n          </div>\n          <table className=\"naming-profile-mapping-table\">\n            <thead>\n              <tr>\n                <th className=\"naming-profile-table-header\">Generator</th>\n                <th className=\"naming-profile-table-header\">Entity Kind</th>\n                <th className=\"naming-profile-table-header\">Culture</th>\n                <th className=\"naming-profile-table-header\">Naming Profile</th>\n              </tr>\n            </thead>\n            <tbody>\n              {groupedMappings.slice(0, 20).flatMap((group) => {\n                // Filter items based on showInherited toggle\n                const filteredItems = showInherited\n                  ? group.items\n                  : group.items.filter(\n                      (m) => m.cultureSource === \"explicit\" || m.cultureSource === \"any\"\n                    );\n                // If no explicit cultures, show first inherited one as representative\n                const displayItems =\n                  filteredItems.length > 0 ? filteredItems : group.items.slice(0, 1);\n                return displayItems.map((m, idx) => (\n                  <tr\n                    key={`${m.generatorId}-${m.cultureId}-${m.entityKind}-${idx}`}\n                    className={`naming-profile-table-row ${!m.match && m.hasNamingProfile ? \"naming-profile-warning-row\" : \"\"}`}\n                  >\n                    <td className=\"naming-profile-table-cell naming-profile-generator-cell\">\n                      {idx === 0 ? m.generatorName : \"\"}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <span className=\"naming-profile-kind-badge\">{m.entityKind}</span>\n                      {m.subtype && (\n                        <span\n                          className=\"naming-profile-kind-badge naming-profile-kind-badge-transparent\"\n                        >\n                          {m.subtype}\n                        </span>\n                      )}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <div className=\"naming-profile-culture-cell\">\n                        {/* eslint-disable-next-line local/no-inline-styles -- dynamic culture color */}\n                        <span\n                          className=\"naming-profile-culture-dot\"\n                          style={{ '--npm-culture-color': m.cultureColor, backgroundColor: 'var(--npm-culture-color)' }}\n                        />\n                        <span>{m.cultureName}</span>\n                        {m.cultureSource === \"inherited\" && (\n                          <span className=\"naming-profile-badge naming-profile-badge-inherited\">\n                            inherited\n                          </span>\n                        )}\n                      </div>\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      {m.match && (\n                        <span className=\"naming-profile-badge naming-profile-badge-match\">\n                          {m.match.profileName || m.match.profileId}\n                          {m.match.groupName && ` / ${m.match.groupName}`}\n                        </span>\n                      )}\n                      {!m.match && !m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No profiles configured\n                        </span>\n                      )}\n                      {!m.match && m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No matching group\n                        </span>\n                      )}\n                    </td>\n                  </tr>\n                ));\n              })}\n            </tbody>\n          </table>\n          {groupedMappings.length > 20 && (\n            <div className=\"text-muted text-center text-xs p-md\">\n              Showing first 20 generators. Total: {groupedMappings.length}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generators = [], schema = {} }", "type": "{ generators?: any[]; schema?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/NamingProfileMappingViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/NamingProfileMappingViewer.jsx", "sourceCode": "export default function NamingProfileMappingViewer({ generators = [], schema = {} }) {\n  const [showInherited, setShowInherited] = useState(false);\n\n  const { mappings, warnings } = useMemo(\n    () => analyzeNamingMappings(generators, schema),\n    [generators, schema]\n  );\n\n  // Group by generator for display\n  const groupedMappings = useMemo(() => {\n    const groups = {};\n    for (const m of mappings) {\n      if (!groups[m.generatorId]) {\n        groups[m.generatorId] = {\n          generatorId: m.generatorId,\n          generatorName: m.generatorName,\n          items: [],\n        };\n      }\n      groups[m.generatorId].items.push(m);\n    }\n    return Object.values(groups);\n  }, [mappings]);\n\n  // Filter warnings - show all by default, but can filter to just explicit cultures\n  const displayWarnings = showInherited\n    ? warnings\n    : warnings.filter(\n        (w) => w.cultureSource === \"explicit\" || w.reason === \"No matching strategy group\"\n      );\n\n  const successCount = mappings.filter((m) => m.match).length;\n  const warningCount = warnings.filter((w) => w.reason === \"No matching strategy group\").length;\n\n  if (mappings.length === 0) {\n    return (\n      <div className=\"naming-profile-container\">\n        <div className=\"naming-profile-header\">\n          <div className=\"naming-profile-title\">\n            <span>Naming Profile Mappings</span>\n          </div>\n        </div>\n        <div className=\"naming-profile-empty-state\">\n          No generators with entity creation defined. Add generators to see naming profile mappings.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"naming-profile-container\">\n      <div className=\"naming-profile-header\">\n        <div className=\"naming-profile-title\">\n          <span>Naming Profile Mappings</span>\n        </div>\n        <div className=\"naming-profile-stats\">\n          <div className=\"naming-profile-stat-item\">\n            <span className=\"naming-profile-stat-value text-success\">{successCount}</span>\n            <span>matched</span>\n          </div>\n          <div className=\"naming-profile-stat-item\">\n            <span\n              className={`naming-profile-stat-value ${warningCount > 0 ? \"text-danger\" : \"text-muted\"}`}\n            >\n              {warningCount}\n            </span>\n            <span>missing</span>\n          </div>\n          <label className=\"cursor-pointer flex items-center gap-xs\">\n            <input\n              type=\"checkbox\"\n              checked={showInherited}\n              onChange={(e) => setShowInherited(e.target.checked)}\n            />\n            <span>Show inherited cultures</span>\n          </label>\n        </div>\n      </div>\n\n      <div className=\"naming-profile-content\">\n        {/* Warnings section */}\n        {displayWarnings.length > 0 && (\n          <div className=\"naming-profile-section\">\n            <div className=\"naming-profile-section-title\">\n              <span className=\"naming-profile-warning-icon\">Warning</span>\n              <span>Naming May Fail ({displayWarnings.length})</span>\n            </div>\n            <div className=\"naming-profile-warning-list\">\n              {displayWarnings.slice(0, 10).map((w, i) => (\n                <div\n                  key={`${w.generatorId}-${w.cultureId}-${i}`}\n                  className=\"naming-profile-warning-item\"\n                >\n                  <span className=\"naming-profile-warning-icon\">!</span>\n                  <span>\n                    <strong>{w.generatorName}</strong> creates <strong>{w.entityKind}</strong>\n                    {w.subtype && `:${w.subtype}`} for culture <strong>{w.cultureName}</strong> -{\" \"}\n                    {w.reason}\n                  </span>\n                </div>\n              ))}\n              {displayWarnings.length > 10 && (\n                <div\n                  className=\"text-muted py-md px-lg\"\n                >\n                  ... and {displayWarnings.length - 10} more\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Mappings table */}\n        <div className=\"naming-profile-section\">\n          <div className=\"naming-profile-section-title\">\n            <span>Entity Creation to Naming Profile</span>\n          </div>\n          <table className=\"naming-profile-mapping-table\">\n            <thead>\n              <tr>\n                <th className=\"naming-profile-table-header\">Generator</th>\n                <th className=\"naming-profile-table-header\">Entity Kind</th>\n                <th className=\"naming-profile-table-header\">Culture</th>\n                <th className=\"naming-profile-table-header\">Naming Profile</th>\n              </tr>\n            </thead>\n            <tbody>\n              {groupedMappings.slice(0, 20).flatMap((group) => {\n                // Filter items based on showInherited toggle\n                const filteredItems = showInherited\n                  ? group.items\n                  : group.items.filter(\n                      (m) => m.cultureSource === \"explicit\" || m.cultureSource === \"any\"\n                    );\n                // If no explicit cultures, show first inherited one as representative\n                const displayItems =\n                  filteredItems.length > 0 ? filteredItems : group.items.slice(0, 1);\n                return displayItems.map((m, idx) => (\n                  <tr\n                    key={`${m.generatorId}-${m.cultureId}-${m.entityKind}-${idx}`}\n                    className={`naming-profile-table-row ${!m.match && m.hasNamingProfile ? \"naming-profile-warning-row\" : \"\"}`}\n                  >\n                    <td className=\"naming-profile-table-cell naming-profile-generator-cell\">\n                      {idx === 0 ? m.generatorName : \"\"}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <span className=\"naming-profile-kind-badge\">{m.entityKind}</span>\n                      {m.subtype && (\n                        <span\n                          className=\"naming-profile-kind-badge naming-profile-kind-badge-transparent\"\n                        >\n                          {m.subtype}\n                        </span>\n                      )}\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      <div className=\"naming-profile-culture-cell\">\n                        {/* eslint-disable-next-line local/no-inline-styles -- dynamic culture color */}\n                        <span\n                          className=\"naming-profile-culture-dot\"\n                          style={{ '--npm-culture-color': m.cultureColor, backgroundColor: 'var(--npm-culture-color)' }}\n                        />\n                        <span>{m.cultureName}</span>\n                        {m.cultureSource === \"inherited\" && (\n                          <span className=\"naming-profile-badge naming-profile-badge-inherited\">\n                            inherited\n                          </span>\n                        )}\n                      </div>\n                    </td>\n                    <td className=\"naming-profile-table-cell\">\n                      {m.match && (\n                        <span className=\"naming-profile-badge naming-profile-badge-match\">\n                          {m.match.profileName || m.match.profileId}\n                          {m.match.groupName && ` / ${m.match.groupName}`}\n                        </span>\n                      )}\n                      {!m.match && !m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No profiles configured\n                        </span>\n                      )}\n                      {!m.match && m.hasNamingProfile && (\n                        <span className=\"naming-profile-badge naming-profile-badge-missing\">\n                          No matching group\n                        </span>\n                      )}\n                    </td>\n                  </tr>\n                ));\n              })}\n            </tbody>\n          </table>\n          {groupedMappings.length > 20 && (\n            <div className=\"text-muted text-center text-xs p-md\">\n              Showing first 20 generators. Total: {groupedMappings.length}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generators = [], schema = {} }", "type": "{ generators?: any[]; schema?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./naming-profile-viewer.css", "specifiers": [], "category": "internal"}, {"source": "./utils", "specifiers": ["analyzeNamingMappings"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/pressures/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/pressures/index.js", "sourceCode": "export default function PressuresEditor({ projectId, pressures = [], onChange, schema, usageMap }) {\n  const [expandedPressure, setExpandedPressure] = useState(null);\n  const factorModalKey = buildStorageKey(projectId, \"pressures:factorModal\");\n  const restoredRef = useRef(false);\n\n  useEffect(() => {\n    restoredRef.current = false;\n  }, [factorModalKey]);\n\n  // Restore expanded pressure from storage (one-time per modal key)\n  useEffect(() => {\n    if (restoredRef.current || !factorModalKey || pressures.length === 0) return;\n\n    const stored = loadStoredValue(factorModalKey);\n    if (stored?.pressureId) {\n      const index = pressures.findIndex((pressure) => pressure.id === stored.pressureId);\n      if (index >= 0) {\n        // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted UI expansion state\n        setExpandedPressure(index);\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    }\n    restoredRef.current = true;\n  }, [factorModalKey, pressures]);\n\n  const handlePressureChange = useCallback(\n    (index, updatedPressure) => {\n      const newPressures = [...pressures];\n      newPressures[index] = updatedPressure;\n      onChange(newPressures);\n    },\n    [pressures, onChange]\n  );\n\n  const handleDeletePressure = useCallback(\n    (index) => {\n      if (confirm(`Delete \"${pressures[index].name}\"?`)) {\n        const newPressures = pressures.filter((_, i) => i !== index);\n        onChange(newPressures);\n        if (expandedPressure === index) {\n          setExpandedPressure(null);\n        }\n      }\n    },\n    [pressures, onChange, expandedPressure]\n  );\n\n  const handleAddPressure = useCallback(() => {\n    const newPressure = {\n      id: `pressure_${Date.now()}`,\n      name: \"New Pressure\",\n      initialValue: 0,\n      homeostasis: 0.05,\n      description: \"\",\n      growth: {\n        positiveFeedback: [],\n        negativeFeedback: [],\n      },\n    };\n    onChange([...pressures, newPressure]);\n    setExpandedPressure(pressures.length);\n  }, [pressures, onChange]);\n\n  if (pressures.length === 0) {\n    return (\n      <div className=\"editor-container\">\n        <div className=\"header\">\n          <h1 className=\"title\">Pressures</h1>\n          <p className=\"subtitle\">\n            Configure environmental and social pressures that drive world evolution\n          </p>\n        </div>\n        <div className=\"empty-state\">\n          <div className=\"empty-state-icon\">\ud83c\udf21\ufe0f</div>\n          <div className=\"pe-empty-title\">\n            No pressures defined\n          </div>\n          <div className=\"pe-empty-desc\">\n            Pressures respond to world state with feedback and a pull toward equilibrium, driving\n            the narrative forward.\n          </div>\n          <button\n            className=\"btn btn-primary pe-create-btn\"\n            onClick={handleAddPressure}\n          >\n            + Create First Pressure\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Pressures</h1>\n        <p className=\"subtitle\">\n          Configure environmental and social pressures that drive world evolution. Each pressure has\n          feedback factors that make it grow or shrink based on world state plus a homeostatic pull\n          toward equilibrium.\n        </p>\n      </div>\n\n      <div className=\"list-stack\">\n        {pressures.map((pressure, index) => (\n          <PressureCard\n            key={index}\n            pressure={pressure}\n            expanded={expandedPressure === index}\n            onToggle={() => setExpandedPressure(expandedPressure === index ? null : index)}\n            onChange={(updatedPressure) => handlePressureChange(index, updatedPressure)}\n            onDelete={() => handleDeletePressure(index)}\n            schema={schema}\n            usageMap={usageMap}\n            projectId={projectId}\n          />\n        ))}\n\n        <button className=\"btn btn-add\" onClick={handleAddPressure}>\n          + Add Pressure\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, pressures = [], onChange, schema, usageMap }", "type": "{ projectId: any; pressures?: any[]; onChange: any; schema: any; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/pressures/PressuresEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/pressures/PressuresEditor.jsx", "sourceCode": "export default function PressuresEditor({ projectId, pressures = [], onChange, schema, usageMap }) {\n  const [expandedPressure, setExpandedPressure] = useState(null);\n  const factorModalKey = buildStorageKey(projectId, \"pressures:factorModal\");\n  const restoredRef = useRef(false);\n\n  useEffect(() => {\n    restoredRef.current = false;\n  }, [factorModalKey]);\n\n  // Restore expanded pressure from storage (one-time per modal key)\n  useEffect(() => {\n    if (restoredRef.current || !factorModalKey || pressures.length === 0) return;\n\n    const stored = loadStoredValue(factorModalKey);\n    if (stored?.pressureId) {\n      const index = pressures.findIndex((pressure) => pressure.id === stored.pressureId);\n      if (index >= 0) {\n        // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted UI expansion state\n        setExpandedPressure(index);\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    }\n    restoredRef.current = true;\n  }, [factorModalKey, pressures]);\n\n  const handlePressureChange = useCallback(\n    (index, updatedPressure) => {\n      const newPressures = [...pressures];\n      newPressures[index] = updatedPressure;\n      onChange(newPressures);\n    },\n    [pressures, onChange]\n  );\n\n  const handleDeletePressure = useCallback(\n    (index) => {\n      if (confirm(`Delete \"${pressures[index].name}\"?`)) {\n        const newPressures = pressures.filter((_, i) => i !== index);\n        onChange(newPressures);\n        if (expandedPressure === index) {\n          setExpandedPressure(null);\n        }\n      }\n    },\n    [pressures, onChange, expandedPressure]\n  );\n\n  const handleAddPressure = useCallback(() => {\n    const newPressure = {\n      id: `pressure_${Date.now()}`,\n      name: \"New Pressure\",\n      initialValue: 0,\n      homeostasis: 0.05,\n      description: \"\",\n      growth: {\n        positiveFeedback: [],\n        negativeFeedback: [],\n      },\n    };\n    onChange([...pressures, newPressure]);\n    setExpandedPressure(pressures.length);\n  }, [pressures, onChange]);\n\n  if (pressures.length === 0) {\n    return (\n      <div className=\"editor-container\">\n        <div className=\"header\">\n          <h1 className=\"title\">Pressures</h1>\n          <p className=\"subtitle\">\n            Configure environmental and social pressures that drive world evolution\n          </p>\n        </div>\n        <div className=\"empty-state\">\n          <div className=\"empty-state-icon\">\ud83c\udf21\ufe0f</div>\n          <div className=\"pe-empty-title\">\n            No pressures defined\n          </div>\n          <div className=\"pe-empty-desc\">\n            Pressures respond to world state with feedback and a pull toward equilibrium, driving\n            the narrative forward.\n          </div>\n          <button\n            className=\"btn btn-primary pe-create-btn\"\n            onClick={handleAddPressure}\n          >\n            + Create First Pressure\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Pressures</h1>\n        <p className=\"subtitle\">\n          Configure environmental and social pressures that drive world evolution. Each pressure has\n          feedback factors that make it grow or shrink based on world state plus a homeostatic pull\n          toward equilibrium.\n        </p>\n      </div>\n\n      <div className=\"list-stack\">\n        {pressures.map((pressure, index) => (\n          <PressureCard\n            key={index}\n            pressure={pressure}\n            expanded={expandedPressure === index}\n            onToggle={() => setExpandedPressure(expandedPressure === index ? null : index)}\n            onChange={(updatedPressure) => handlePressureChange(index, updatedPressure)}\n            onDelete={() => handleDeletePressure(index)}\n            schema={schema}\n            usageMap={usageMap}\n            projectId={projectId}\n          />\n        ))}\n\n        <button className=\"btn btn-add\" onClick={handleAddPressure}>\n          + Add Pressure\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, pressures = [], onChange, schema, usageMap }", "type": "{ projectId: any; pressures?: any[]; onChange: any; schema: any; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./cards", "specifiers": ["PressureCard"], "category": "internal"}, {"source": "../../utils/persistence", "specifiers": ["buildStorageKey", "clearStoredValue", "loadStoredValue"], "category": "internal"}, {"source": "./PressuresEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/shared/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/shared/MutationCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/shared/MutationCard.jsx", "sourceCode": "export function MutationCard({\n  mutation,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  entityOptions,\n  typeOptions,\n  createMutation,\n  titlePrefix,\n}) {\n  const [expanded, setExpanded] = useState(false);\n  const types = typeOptions || DEFAULT_MUTATION_TYPES;\n  const entityRefs = normalizeOptions(entityOptions);\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n  const pressureOptions = (pressures || []).map((p) => ({\n    value: p.id,\n    label: p.name || p.id,\n  }));\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const update = (field, value) => {\n    onChange({ ...mutation, [field]: value });\n  };\n\n  const updateType = (value) => {\n    if (createMutation) {\n      onChange(createMutation(value));\n      return;\n    }\n    update(\"type\", value);\n  };\n\n  const fallbackLabel =\n    types.find((t) => t.value === mutation.type)?.label ||\n    MUTATION_TYPE_META[mutation.type]?.label ||\n    mutation.type;\n  const typeMeta = MUTATION_TYPE_META[mutation.type] || { icon: \"?\", color: \"#6b7280\" };\n  const headerLabel = titlePrefix ? `${titlePrefix}: ${fallbackLabel}` : fallbackLabel;\n\n  const getSummary = () => {\n    switch (mutation.type) {\n      case \"modify_pressure\":\n        return `${mutation.pressureId || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"set_tag\": {\n        const value = mutation.value !== undefined ? ` = ${mutation.value}` : \"\";\n        return `${mutation.entity || \"?\"} tag ${mutation.tag || \"?\"}${value}`;\n      }\n      case \"remove_tag\":\n        return `${mutation.entity || \"?\"} remove ${mutation.tag || \"?\"}`;\n      case \"change_status\":\n        return `${mutation.entity || \"?\"} -> ${mutation.newStatus || \"?\"}`;\n      case \"adjust_prominence\":\n        return `${mutation.entity || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"archive_relationship\": {\n        return `${mutation.entity || \"?\"} ${mutation.relationshipKind || \"?\"} with ${mutation.with || \"?\"}`;\n      }\n      case \"archive_all_relationships\": {\n        const dirLabel =\n          mutation.direction && mutation.direction !== \"both\" ? ` (${mutation.direction})` : \"\";\n        return `${mutation.entity || \"?\"} all ${mutation.relationshipKind || \"?\"}${dirLabel}`;\n      }\n      case \"adjust_relationship_strength\":\n        return `${mutation.kind || \"?\"} ${mutation.src || \"?\"} -> ${mutation.dst || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"create_relationship\": {\n        const arrow = mutation.bidirectional ? \"<->\" : \"->\";\n        return `${mutation.kind || \"?\"} ${mutation.src || \"?\"} ${arrow} ${mutation.dst || \"?\"}`;\n      }\n      case \"update_rate_limit\":\n        return \"track execution\";\n      case \"transfer_relationship\":\n        return `${mutation.entity || \"?\"} ${mutation.relationshipKind || \"?\"} from ${mutation.from || \"?\"} to ${mutation.to || \"?\"}`;\n      case \"for_each_related\": {\n        const actionCount = (mutation.actions || []).length;\n        return `${mutation.relationship || \"?\"} (${actionCount} action${actionCount !== 1 ? \"s\" : \"\"})`;\n      }\n      case \"conditional\": {\n        const thenCount = (mutation.thenActions || []).length;\n        const elseCount = (mutation.elseActions || []).length;\n        return `then: ${thenCount}, else: ${elseCount}`;\n      }\n      default:\n        return \"\";\n    }\n  };\n\n  const summary = getSummary();\n\n  return (\n    <div className=\"condition-card\">\n      <div className={`condition-card-header ${expanded ? \"\" : \"mb-0\"}`}>\n        <div className=\"condition-card-type\">\n          {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color */}\n          <div className=\"condition-card-icon\" style={{ '--mc-icon-bg': `${typeMeta.color}20`, backgroundColor: 'var(--mc-icon-bg)' }}>\n            {typeMeta.icon}\n          </div>\n          <div>\n            <div className=\"condition-card-label\">{headerLabel}</div>\n            {summary && <div className=\"condition-card-summary\">{summary}</div>}\n          </div>\n        </div>\n        <div className=\"condition-card-actions\">\n          <button className=\"btn-icon\" onClick={() => setExpanded(!expanded)}>\n            {expanded ? \"^\" : \"v\"}\n          </button>\n          {onRemove && (\n            <button className=\"btn-icon btn-icon-danger\" onClick={onRemove}>\n              x\n            </button>\n          )}\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"condition-card-fields\">\n          <div className=\"form-grid mc-fields-full\">\n            <ReferenceDropdown\n              label=\"Type\"\n              value={mutation.type}\n              onChange={updateType}\n              options={types}\n            />\n\n            {mutation.type === \"modify_pressure\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure\"\n                  value={mutation.pressureId || \"\"}\n                  onChange={(v) => update(\"pressureId\", v)}\n                  options={pressureOptions}\n                  placeholder=\"Select pressure...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Delta\n                  <NumberInput value={mutation.delta} onChange={(v) => update(\"delta\", v ?? 0)} />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {(mutation.type === \"set_tag\" || mutation.type === \"remove_tag\") && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Tag\n                  <TagSelector\n                    value={mutation.tag ? [mutation.tag] : []}\n                    onChange={(tags) => update(\"tag\", tags[0] || \"\")}\n                    tagRegistry={tagRegistry}\n                    placeholder=\"Select tag...\"\n                    singleSelect\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"set_tag\" && (\n              <>\n                <div className=\"form-group\">\n                  <label htmlFor=\"value-optional\" className=\"label\">Value (optional)</label>\n                  <input id=\"value-optional\"\n                    type=\"text\"\n                    value={mutation.value !== undefined ? String(mutation.value) : \"\"}\n                    onChange={(e) => update(\"value\", parseTagValue(e.target.value))}\n                    className=\"input\"\n                    placeholder=\"true\"\n                    disabled={Boolean(mutation.valueFrom)}\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label htmlFor=\"value-source-optional\" className=\"label\">Value Source (optional)</label>\n                  <input id=\"value-source-optional\"\n                    type=\"text\"\n                    value={mutation.valueFrom || \"\"}\n                    onChange={(e) => update(\"valueFrom\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"e.g., cluster_id\"\n                  />\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"change_status\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label htmlFor=\"new-status\" className=\"label\">New Status</label>\n                  <input id=\"new-status\"\n                    type=\"text\"\n                    value={mutation.newStatus || \"\"}\n                    onChange={(e) => update(\"newStatus\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"e.g., active\"\n                  />\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"adjust_prominence\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Delta\n                  <NumberInput\n                    value={mutation.delta}\n                    onChange={(v) => update(\"delta\", v ?? 0)}\n                    placeholder=\"e.g., 0.25 or -0.15\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"create_relationship\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Relationship Kind\"\n                  value={mutation.kind || \"\"}\n                  onChange={(v) => update(\"kind\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship...\"\n                />\n                <ReferenceDropdown\n                  label=\"Source\"\n                  value={mutation.src || \"\"}\n                  onChange={(v) => update(\"src\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select source...\"\n                />\n                <ReferenceDropdown\n                  label=\"Destination\"\n                  value={mutation.dst || \"\"}\n                  onChange={(v) => update(\"dst\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select destination...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Strength\n                  <NumberInput\n                    value={mutation.strength}\n                    onChange={(v) => update(\"strength\", v)}\n                    min={0}\n                    max={1}\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label htmlFor=\"category-optional\" className=\"label\">Category (optional)</label>\n                  <input id=\"category-optional\"\n                    type=\"text\"\n                    value={mutation.category || \"\"}\n                    onChange={(e) => update(\"category\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"Optional\"\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"checkbox-label\">\n                    <input\n                      type=\"checkbox\"\n                      checked={mutation.bidirectional || false}\n                      onChange={(e) => update(\"bidirectional\", e.target.checked || undefined)}\n                      className=\"checkbox\"\n                    />\n                    Bidirectional\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"adjust_relationship_strength\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Relationship Kind\"\n                  value={mutation.kind || \"\"}\n                  onChange={(v) => update(\"kind\", v)}\n                  options={relationshipKindOptions}\n// ... (truncated)", "parameters": [{"name": "{\n  mutation,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  entityOptions,\n  typeOptions,\n  createMutation,\n  titlePrefix,\n}", "type": "{ mutation: any; onChange: any; onRemove: any; schema: any; pressures: any; entityOptions: any; typeOptions: any; createMutation: any; titlePrefix: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "../actions/constants", "specifiers": ["MUTATION_TYPE_META", "MUTATION_TYPE_ORDER"], "category": "internal"}, {"source": "./MutationCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/shared/SelectionRuleEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/shared/SelectionRuleEditor.jsx", "sourceCode": "export function SelectionRuleEditor({\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  showFilters = true,\n  allowAnyKind = false,\n  showExcludeSubtypes = false,\n}) {\n  const selection = value || { strategy: \"by_kind\" };\n\n  const baseKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n  const entityKindOptions = allowAnyKind\n    ? [{ value: \"any\", label: \"Any kind\" }, ...baseKindOptions]\n    : baseKindOptions;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateSelection = (field, fieldValue) => {\n    onChange({ ...selection, [field]: fieldValue });\n  };\n\n  const updateSelectionMultiple = (updates) => {\n    onChange({ ...selection, ...updates });\n  };\n\n  const referenceOptions = (availableRefs.length > 0 ? availableRefs : [\"$target\"]).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  return (\n    <div>\n      <div className=\"form-grid\">\n        <ReferenceDropdown\n          label=\"Selection Strategy\"\n          value={selection.strategy || \"by_kind\"}\n          onChange={(v) => updateSelection(\"strategy\", v)}\n          options={[\n            { value: \"by_kind\", label: \"By Entity Kind\" },\n            { value: \"by_preference_order\", label: \"By Subtype Preference\" },\n            { value: \"by_relationship\", label: \"By Relationship Presence\" },\n            { value: \"by_proximity\", label: \"By Proximity\" },\n            { value: \"by_prominence\", label: \"By Prominence\" },\n          ]}\n        />\n\n        {showPickStrategy && (\n          <ReferenceDropdown\n            label=\"Pick Strategy\"\n            value={selection.pickStrategy || \"random\"}\n            onChange={(v) => updateSelection(\"pickStrategy\", v)}\n            options={PICK_STRATEGIES}\n          />\n        )}\n\n        {showMaxResults && (\n          <div className=\"form-group\">\n            <label className=\"label\">Max Results\n            <NumberInput\n              value={selection.maxResults}\n              onChange={(v) => updateSelection(\"maxResults\", v)}\n              min={1}\n              integer\n              allowEmpty\n              placeholder=\"1\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      <div className=\"form-grid mt-xl\">\n        <ReferenceDropdown\n          label=\"Entity Kind\"\n          value={selection.kind || \"\"}\n          onChange={(v) =>\n            updateSelectionMultiple({\n              kind: v || undefined,\n              subtypes: undefined,\n              excludeSubtypes: undefined,\n            })\n          }\n          options={entityKindOptions}\n          placeholder=\"Any kind\"\n        />\n        <div className=\"form-group\">\n          <label htmlFor=\"status-optional\" className=\"label\">Status (optional)</label>\n          <input id=\"status-optional\"\n            type=\"text\"\n            value={selection.status || \"\"}\n            onChange={(e) => updateSelection(\"status\", e.target.value || undefined)}\n            className=\"input\"\n            placeholder=\"e.g., active\"\n          />\n        </div>\n        <div className=\"form-group\">\n          <label htmlFor=\"not-status-optional\" className=\"label\">Not Status (optional)</label>\n          <input id=\"not-status-optional\"\n            type=\"text\"\n            value={selection.notStatus || \"\"}\n            onChange={(e) => updateSelection(\"notStatus\", e.target.value || undefined)}\n            className=\"input\"\n            placeholder=\"e.g., dead\"\n          />\n        </div>\n      </div>\n\n      {selection.kind && selection.kind !== \"any\" && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Subtypes (optional)\"\n            value={selection.subtypes || []}\n            onChange={(v) => updateSelection(\"subtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(selection.kind)}\n            placeholder=\"Any subtype\"\n          />\n        </div>\n      )}\n\n      {selection.kind && selection.kind !== \"any\" && showExcludeSubtypes && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Exclude Subtypes (optional)\"\n            value={selection.excludeSubtypes || []}\n            onChange={(v) => updateSelection(\"excludeSubtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(selection.kind)}\n            placeholder=\"None\"\n          />\n        </div>\n      )}\n\n      {selection.strategy === \"by_preference_order\" && (\n        <div className=\"mt-xl\">\n          <label htmlFor=\"subtype-preferences-comma-separated\" className=\"label\">Subtype Preferences (comma-separated)</label>\n          <input id=\"subtype-preferences-comma-separated\"\n            type=\"text\"\n            value={(selection.subtypePreferences || []).join(\", \")}\n            onChange={(e) => {\n              const prefs = e.target.value\n                .split(\",\")\n                .map((s) => s.trim())\n                .filter(Boolean);\n              updateSelection(\"subtypePreferences\", prefs.length > 0 ? prefs : undefined);\n            }}\n            className=\"input\"\n            placeholder=\"e.g., noble, commoner\"\n          />\n        </div>\n      )}\n\n      {selection.strategy === \"by_relationship\" && (\n        <div className=\"form-grid mt-xl\">\n          <ReferenceDropdown\n            label=\"Relationship Kind\"\n            value={selection.relationshipKind || \"\"}\n            onChange={(v) => updateSelection(\"relationshipKind\", v)}\n            options={relationshipKindOptions}\n            placeholder=\"Select relationship...\"\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={selection.direction || \"both\"}\n            onChange={(v) => updateSelection(\"direction\", v)}\n            options={[\n              { value: \"both\", label: \"Both\" },\n              { value: \"src\", label: \"Source (outgoing)\" },\n              { value: \"dst\", label: \"Destination (incoming)\" },\n            ]}\n          />\n          <div className=\"form-group\">\n            <label className=\"checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={selection.mustHave !== false}\n                onChange={(e) => updateSelection(\"mustHave\", e.target.checked)}\n                className=\"checkbox\"\n              />\n              Must Have Relationship\n            </label>\n          </div>\n        </div>\n      )}\n\n      {selection.strategy === \"by_proximity\" && (\n        <div className=\"form-grid mt-xl\">\n          <ReferenceDropdown\n            label=\"Reference Entity\"\n            value={selection.referenceEntity || \"\"}\n            onChange={(v) => updateSelection(\"referenceEntity\", v || undefined)}\n            options={referenceOptions}\n            placeholder={referenceOptions[0]?.value || \"\"}\n          />\n          <div className=\"form-group\">\n            <label className=\"label\">Max Distance\n            <NumberInput\n              value={selection.maxDistance}\n              onChange={(v) => updateSelection(\"maxDistance\", v)}\n              min={0}\n              allowEmpty\n              placeholder=\"50\"\n            />\n            </label>\n          </div>\n        </div>\n      )}\n\n      {selection.strategy === \"by_prominence\" && (\n        <div className=\"mt-xl\">\n          <ReferenceDropdown\n            label=\"Minimum Prominence\"\n            value={selection.minProminence || \"\"}\n            onChange={(v) => updateSelection(\"minProminence\", v || undefined)}\n            options={PROMINENCE_LEVELS.map((p) => ({ value: p.value, label: p.label }))}\n            placeholder=\"Any\"\n          />\n        </div>\n      )}\n\n      {showFilters && (\n        <div className=\"mt-2xl\">\n          <span className=\"label\">Selection Filters</span>\n          <div className=\"info-box-text mb-lg text-sm\">\n            Optional filters to narrow down which entities can be selected. All filters must pass.\n          </div>\n          <SelectionFiltersEditor\n            filters={selection.filters}\n            onChange={(filters) =>\n              updateSelection(\"filters\", filters.length > 0 ? filters : undefined)\n            }\n            schema={schema}\n            availableRefs={availableRefs}\n          />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  showFilters = true,\n  allowAnyKind = false,\n  showExcludeSubtypes = false,\n}", "type": "{ value: any; onChange: any; schema: any; availableRefs?: any[]; showPickStrategy?: boolean; showMaxResults?: boolean; showFilters?: boolean; allowAnyKind?: boolean; showExcludeSubtypes?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput", "PROMINENCE_LEVELS"], "category": "internal"}, {"source": "../generators/constants", "specifiers": ["PICK_STRATEGIES"], "category": "internal"}, {"source": "../generators/filters", "specifiers": ["SelectionFiltersEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/shared/VariableSelectionEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/shared/VariableSelectionEditor.jsx", "sourceCode": "export function VariableSelectionEditor({\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  allowPreferFilters = true,\n}) {\n  const select = value || {};\n  const selectionMode = getSelectionMode(select);\n  const isRelatedMode = selectionMode === \"related\";\n  const isPathMode = selectionMode === \"path\";\n  const fromSpec = isRelatedMode ? select.from : null;\n  const pathSpec = isPathMode ? select.from : null;\n\n  const entityKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateSelect = (field, fieldValue) => {\n    onChange({ ...select, [field]: fieldValue });\n  };\n\n  const updateSelectMultiple = (updates) => {\n    onChange({ ...select, ...updates });\n  };\n\n  const setMode = (mode) => {\n    if (mode === \"graph\") {\n      onChange({ ...select, from: \"graph\" });\n      return;\n    }\n    if (mode === \"path\") {\n      const startRef = availableRefs[0] || \"$self\";\n      onChange({\n        ...select,\n        from: {\n          path: [{ from: startRef, via: \"\", direction: \"both\" }],\n        },\n      });\n      return;\n    }\n    const relatedTo = availableRefs[0] || \"$target\";\n    onChange({\n      ...select,\n      from: { relatedTo, relationshipKind: \"\", direction: \"both\" },\n    });\n  };\n\n  const updatePathStep = (index, step) => {\n    const path = [...(pathSpec?.path || [])];\n    path[index] = step;\n    updateSelect(\"from\", { path });\n  };\n\n  const addPathStep = () => {\n    const path = [...(pathSpec?.path || [])];\n    path.push({ via: \"\", direction: \"both\" });\n    updateSelect(\"from\", { path });\n  };\n\n  const removePathStep = (index) => {\n    const path = (pathSpec?.path || []).filter((_, i) => i !== index);\n    if (path.length === 0) {\n      // Switch back to graph mode if no steps left\n      setMode(\"graph\");\n    } else {\n      updateSelect(\"from\", { path });\n    }\n  };\n\n  const updateFrom = (field, fieldValue) => {\n    const nextFrom = {\n      ...(fromSpec || {\n        relatedTo: availableRefs[0] || \"$target\",\n        relationshipKind: \"\",\n        direction: \"both\",\n      }),\n      [field]: fieldValue,\n    };\n    updateSelect(\"from\", nextFrom);\n  };\n\n  return (\n    <div>\n      <div className=\"form-grid\">\n        <ReferenceDropdown\n          label=\"Select From\"\n          value={selectionMode}\n          onChange={(v) => setMode(v)}\n          options={[\n            { value: \"graph\", label: \"Graph (by entity kind)\" },\n            { value: \"related\", label: \"Related Entities (single hop)\" },\n            { value: \"path\", label: \"Path Traversal (multi-hop)\" },\n          ]}\n        />\n\n        {selectionMode === \"graph\" && (\n          <ReferenceDropdown\n            label=\"Entity Kind\"\n            value={select.kind || \"\"}\n            onChange={(v) => updateSelectMultiple({ kind: v || undefined, subtypes: undefined })}\n            options={entityKindOptions}\n            placeholder=\"Any kind\"\n          />\n        )}\n\n        {isRelatedMode && (\n          <>\n            <ReferenceDropdown\n              label=\"Related To\"\n              value={fromSpec?.relatedTo || availableRefs[0] || \"$target\"}\n              onChange={(v) => updateFrom(\"relatedTo\", v)}\n              options={availableRefs.map((r) => ({ value: r, label: r }))}\n              placeholder=\"Select entity...\"\n            />\n            <ReferenceDropdown\n              label=\"Relationship Kind\"\n              value={fromSpec?.relationshipKind || \"\"}\n              onChange={(v) => updateFrom(\"relationshipKind\", v)}\n              options={relationshipKindOptions}\n              placeholder=\"Select relationship...\"\n            />\n            <ReferenceDropdown\n              label=\"Direction\"\n              value={fromSpec?.direction || \"both\"}\n              onChange={(v) => updateFrom(\"direction\", v)}\n              options={[\n                { value: \"both\", label: \"Both\" },\n                { value: \"src\", label: \"Source (outgoing)\" },\n                { value: \"dst\", label: \"Destination (incoming)\" },\n              ]}\n            />\n          </>\n        )}\n\n        {isPathMode && (\n          <div className=\"grid-col-full\">\n            <span className=\"label\">Path Steps</span>\n            <div className=\"info-box-text mb-lg text-sm\">\n              Multi-hop traversal from the starting entity through relationships.\n            </div>\n          </div>\n        )}\n\n        {showPickStrategy && (\n          <ReferenceDropdown\n            label=\"Pick Strategy\"\n            value={select.pickStrategy || \"\"}\n            onChange={(v) => updateSelect(\"pickStrategy\", v || undefined)}\n            options={VARIABLE_PICK_STRATEGIES}\n            placeholder=\"Select...\"\n          />\n        )}\n\n        {showMaxResults && (\n          <div className=\"form-group\">\n            <label className=\"label\">Max Results\n            <NumberInput\n              value={select.maxResults}\n              onChange={(v) => updateSelect(\"maxResults\", v)}\n              min={1}\n              integer\n              allowEmpty\n              placeholder=\"1\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      {isPathMode && (\n        <div className=\"mt-xl\">\n          {(pathSpec?.path || []).map((step, index) => (\n            <div key={index} className=\"item-card mb-lg\">\n              <div className=\"item-card-header p-lg\">\n                <div className=\"item-card-icon\">\ud83d\udd17</div>\n                <div className=\"item-card-info\">\n                  <div className=\"item-card-title\">Step {index + 1}</div>\n                </div>\n                <button\n                  className=\"btn-icon btn-icon-danger\"\n                  onClick={() => removePathStep(index)}\n                  title=\"Remove step\"\n                >\n                  \u00d7\n                </button>\n              </div>\n              <div className=\"item-card-body\">\n                <div className=\"form-grid\">\n                  {index === 0 && (\n                    <ReferenceDropdown\n                      label=\"Start From\"\n                      value={step.from || availableRefs[0] || \"$self\"}\n                      onChange={(v) => updatePathStep(index, { ...step, from: v })}\n                      options={availableRefs.map((r) => ({ value: r, label: r }))}\n                      placeholder=\"Select entity...\"\n                    />\n                  )}\n                  <ReferenceDropdown\n                    label=\"Via Relationship\"\n                    value={step.via || \"\"}\n                    onChange={(v) => updatePathStep(index, { ...step, via: v })}\n                    options={relationshipKindOptions}\n                    placeholder=\"Select relationship...\"\n                  />\n                  <ReferenceDropdown\n                    label=\"Direction\"\n                    value={step.direction || \"both\"}\n                    onChange={(v) => updatePathStep(index, { ...step, direction: v })}\n                    options={[\n                      { value: \"both\", label: \"Both\" },\n                      { value: \"src\", label: \"Source (outgoing)\" },\n                      { value: \"dst\", label: \"Destination (incoming)\" },\n                    ]}\n                  />\n                  <ReferenceDropdown\n                    label=\"Target Kind (optional)\"\n                    value={step.targetKind || \"\"}\n                    onChange={(v) => updatePathStep(index, { ...step, targetKind: v || undefined })}\n                    options={entityKindOptions}\n                    placeholder=\"Any kind\"\n                  />\n                </div>\n              </div>\n            </div>\n          ))}\n          <button className=\"btn-add\" onClick={addPathStep}>\n            + Add Step\n          </button>\n        </div>\n      )}\n\n      {(isRelatedMode || isPathMode) && (\n        <div className=\"mt-xl\">\n          <ReferenceDropdown\n            label=\"Filter by Entity Kind (optional)\"\n            value={select.kind || \"\"}\n            onChange={(v) => updateSelectMultiple({ kind: v || undefined, subtypes: undefined })}\n            options={entityKindOptions}\n            placeholder=\"Any kind\"\n          />\n        </div>\n      )}\n\n      {select.kind && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Subtypes (optional)\"\n            value={select.subtypes || []}\n            onChange={(v) => updateSelect(\"subtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(select.kind)}\n            placeholder=\"Any subtype\"\n          />\n        </div>\n      )}\n\n      <div className=\"mt-xl\">\n        <label htmlFor=\"status-filter-optional\" className=\"label\">Status Filter (optional)</label>\n        <input id=\"status-filter-optional\"\n          type=\"text\"\n          value={select.status || \"\"}\n          onChange={(e) => updateSelect(\"status\", e.target.value || undefined)}\n          className=\"input\"\n          placeholder=\"e.g., active\"\n        />\n      </div>\n\n      <div className=\"mt-xl\">\n        <label htmlFor=\"not-status-optional\" className=\"label\">Not Status (optional)</label>\n        <input id=\"not-status-optional\"\n          type=\"text\"\n          value={select.notStatus || \"\"}\n          onChange={(e) => updateSelect(\"notStatus\", e.target.value || undefined)}\n          className=\"input\"\n          placeholder=\"e.g., dead\"\n        />\n      </div>\n\n      <div className=\"mt-2xl\">\n        <span className=\"label\">Selection Filters</span>\n        <div className=\"info-box-text mb-lg text-sm\">\n          Optional filters to narrow down which entities can be selected. All filters must pass.\n        </div>\n        <SelectionFiltersEditor\n          filters={select.filters}\n          onChange={(filters) => updateSelect(\"filters\", filters.length > 0 ? filters : undefined)}\n// ... (truncated)", "parameters": [{"name": "{\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  allowPreferFilters = true,\n}", "type": "{ value: any; onChange: any; schema: any; availableRefs?: any[]; showPickStrategy?: boolean; showMaxResults?: boolean; allowPreferFilters?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput"], "category": "internal"}, {"source": "../generators/constants", "specifiers": ["VARIABLE_PICK_STRATEGIES"], "category": "internal"}, {"source": "../generators/filters", "specifiers": ["SelectionFiltersEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/constants.js::getSystemCategory", "name": "getSystemCategory", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/systems/constants.js", "sourceCode": "/**\n * Get the category for a system type\n * @param {string} systemType - The system type\n * @returns {string} The category name\n */\nexport function getSystemCategory(systemType) {\n  if (FRAMEWORK_SYSTEM_TYPES.has(systemType)) {\n    return \"framework\";\n  }\n  return systemType;\n}", "parameters": [{"name": "systemType", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/systems/index.js", "sourceCode": "export default function SystemsEditor({\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"systems:selected\");\n  const typePickerKey = buildStorageKey(projectId, \"systems:typePicker\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [showTypePicker, setShowTypePicker] = useState(\n    () => loadStoredValue(typePickerKey) === true\n  );\n\n  // Derive selectedSystem from index\n  const resolvedIndex = selectedId\n    ? systems.findIndex((system) => system.config?.id === selectedId)\n    : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedSystem = selectedIndex !== null ? systems[selectedIndex] : null;\n  const [expandedCategories, setExpandedCategories] = useState(() => {\n    // Start with all categories expanded\n    return Object.keys(SYSTEM_CATEGORIES).reduce((acc, cat) => {\n      acc[cat] = true;\n      return acc;\n    }, {});\n  });\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowTypePicker(false);\n    }\n  }, []);\n\n  // Group systems by category (framework systems grouped together)\n  const groupedSystems = useMemo(() => {\n    const groups = {};\n    systems.forEach((system) => {\n      const category = getSystemCategory(system.systemType || \"unknown\");\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(system);\n    });\n    return groups;\n  }, [systems]);\n\n  // Get ordered list of categories that have systems\n  const categories = useMemo(() => {\n    const usedCategories = Object.keys(groupedSystems);\n    // Sort by defined order in SYSTEM_CATEGORIES\n    return usedCategories.sort((a, b) => {\n      const orderA = SYSTEM_CATEGORIES[a]?.order ?? 999;\n      const orderB = SYSTEM_CATEGORIES[b]?.order ?? 999;\n      return orderA - orderB;\n    });\n  }, [groupedSystems]);\n\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  useEffect(() => {\n    setShowTypePicker(loadStoredValue(typePickerKey) === true);\n  }, [typePickerKey]);\n\n  useEffect(() => {\n    if (selectionKey) {\n      if (selectedId) {\n        saveStoredValue(selectionKey, selectedId);\n      } else {\n        clearStoredValue(selectionKey);\n      }\n    }\n  }, [selectionKey, selectedId]);\n\n  useEffect(() => {\n    if (typePickerKey) {\n      if (showTypePicker) {\n        saveStoredValue(typePickerKey, true);\n      } else {\n        clearStoredValue(typePickerKey);\n      }\n    }\n  }, [typePickerKey, showTypePicker]);\n\n  useEffect(() => {\n    if (selectedId && selectedIndex === null) {\n      setSelectedId(null);\n      clearStoredValue(selectionKey);\n    }\n  }, [selectedId, selectedIndex, selectionKey]);\n\n  const handleSystemChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex >= 0 && selectedIndex < systems.length) {\n        const newSystems = [...systems];\n        newSystems[selectedIndex] = updated;\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (system) => {\n      const index = systems.findIndex((s) => s.config?.id === system.config?.id);\n      if (index >= 0) {\n        const newSystems = [...systems];\n        newSystems[index] = { ...system, enabled: system.enabled === false ? true : false };\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedSystem &&\n      confirm(`Delete system \"${selectedSystem.config?.name || selectedSystem.config?.id}\"?`)\n    ) {\n      const newSystems = systems.filter((_, i) => i !== selectedIndex);\n      onChange(newSystems);\n      setSelectedId(null);\n    }\n  }, [systems, onChange, selectedIndex, selectedSystem]);\n\n  const handleAddSystem = useCallback(\n    (type) => {\n      const needsSelection = [\n        \"graphContagion\",\n        \"connectionEvolution\",\n        \"thresholdTrigger\",\n        \"clusterFormation\",\n        \"tagDiffusion\",\n        \"planeDiffusion\",\n      ].includes(type);\n      const newSystem = {\n        systemType: type,\n        config: {\n          id: `system_${Date.now()}`,\n          name: `New ${SYSTEM_TYPES[type]?.label || type}`,\n          description: \"\",\n          ...(needsSelection ? { selection: { strategy: \"by_kind\", kind: \"any\" } } : {}),\n        },\n      };\n      onChange([...systems, newSystem]);\n      setSelectedId(newSystem.config.id);\n      setShowTypePicker(false);\n    },\n    [systems, onChange]\n  );\n\n  const toggleCategoryExpand = useCallback((type) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [type]: !prev[type],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (category) => {\n      const categoryItems = groupedSystems[category] || [];\n      const allEnabled = categoryItems.every((s) => s.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of systems in this category\n      const categoryIds = new Set(categoryItems.map((s) => s.config?.id));\n\n      const newSystems = systems.map((s) => {\n        if (categoryIds.has(s.config?.id)) {\n          return { ...s, enabled: newEnabled };\n        }\n        return s;\n      });\n      onChange(newSystems);\n    },\n    [systems, groupedSystems, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Systems</h1>\n        <p className=\"subtitle\">\n          Configure simulation systems that run during the simulation phase. Click a system to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((category) => {\n        const categoryConfig = SYSTEM_CATEGORIES[category] || { icon: \"\u2699\ufe0f\", label: category };\n        const categoryItems = groupedSystems[category] || [];\n        const allEnabled = categoryItems.every((s) => s.enabled !== false);\n\n        return (\n          <CategorySection\n            key={category}\n            id={category}\n            icon={categoryConfig.icon}\n            label={categoryConfig.label}\n            items={categoryItems}\n            expanded={expandedCategories[category] !== false}\n            onToggleExpand={() => toggleCategoryExpand(category)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(category)}\n            gridClassName=\"list-grid\"\n            renderItem={(system) => {\n              const flatIndex = systems.findIndex((s) => s.config?.id === system.config?.id);\n              return (\n                <SystemListCard\n                  key={flatIndex}\n                  system={system}\n                  onClick={() => setSelectedId(system.config.id)}\n                  onToggle={() => handleToggle(system)}\n                  usageMap={usageMap}\n                />\n              );\n            }}\n          />\n        );\n      })}\n\n      {/* Add System button */}\n      <div className=\"mt-xl\">\n        <div\n          className=\"add-card se-add-card-wrap\"\n          onClick={() => setShowTypePicker(true)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"se-add-icon\">+</span>\n          <span>Add System</span>\n        </div>\n      </div>\n\n      {showTypePicker && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal se-type-picker-modal\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Choose System Type</div>\n              <button className=\"close-btn\" onClick={() => setShowTypePicker(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"se-type-picker-content\">\n              <div className=\"type-picker\">\n                {Object.entries(SYSTEM_TYPES).map(([type, config]) => (\n                  <div\n                    key={type}\n                    className=\"se-type-option type-option\"\n                    onClick={() => handleAddSystem(type)}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <div className=\"type-option-icon\">{config.icon}</div>\n                    <div className=\"type-option-label\">{config.label}</div>\n                    <div className=\"type-option-desc\">{config.desc}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {selectedSystem && (\n        <SystemModal\n          system={selectedSystem}\n          onChange={handleSystemChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; systems?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/SystemsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/systems/SystemsEditor.jsx", "sourceCode": "export default function SystemsEditor({\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"systems:selected\");\n  const typePickerKey = buildStorageKey(projectId, \"systems:typePicker\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [showTypePicker, setShowTypePicker] = useState(\n    () => loadStoredValue(typePickerKey) === true\n  );\n\n  // Derive selectedSystem from index\n  const resolvedIndex = selectedId\n    ? systems.findIndex((system) => system.config?.id === selectedId)\n    : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedSystem = selectedIndex !== null ? systems[selectedIndex] : null;\n  const [expandedCategories, setExpandedCategories] = useState(() => {\n    // Start with all categories expanded\n    return Object.keys(SYSTEM_CATEGORIES).reduce((acc, cat) => {\n      acc[cat] = true;\n      return acc;\n    }, {});\n  });\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowTypePicker(false);\n    }\n  }, []);\n\n  // Group systems by category (framework systems grouped together)\n  const groupedSystems = useMemo(() => {\n    const groups = {};\n    systems.forEach((system) => {\n      const category = getSystemCategory(system.systemType || \"unknown\");\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(system);\n    });\n    return groups;\n  }, [systems]);\n\n  // Get ordered list of categories that have systems\n  const categories = useMemo(() => {\n    const usedCategories = Object.keys(groupedSystems);\n    // Sort by defined order in SYSTEM_CATEGORIES\n    return usedCategories.sort((a, b) => {\n      const orderA = SYSTEM_CATEGORIES[a]?.order ?? 999;\n      const orderB = SYSTEM_CATEGORIES[b]?.order ?? 999;\n      return orderA - orderB;\n    });\n  }, [groupedSystems]);\n\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  useEffect(() => {\n    setShowTypePicker(loadStoredValue(typePickerKey) === true);\n  }, [typePickerKey]);\n\n  useEffect(() => {\n    if (selectionKey) {\n      if (selectedId) {\n        saveStoredValue(selectionKey, selectedId);\n      } else {\n        clearStoredValue(selectionKey);\n      }\n    }\n  }, [selectionKey, selectedId]);\n\n  useEffect(() => {\n    if (typePickerKey) {\n      if (showTypePicker) {\n        saveStoredValue(typePickerKey, true);\n      } else {\n        clearStoredValue(typePickerKey);\n      }\n    }\n  }, [typePickerKey, showTypePicker]);\n\n  useEffect(() => {\n    if (selectedId && selectedIndex === null) {\n      setSelectedId(null);\n      clearStoredValue(selectionKey);\n    }\n  }, [selectedId, selectedIndex, selectionKey]);\n\n  const handleSystemChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex >= 0 && selectedIndex < systems.length) {\n        const newSystems = [...systems];\n        newSystems[selectedIndex] = updated;\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (system) => {\n      const index = systems.findIndex((s) => s.config?.id === system.config?.id);\n      if (index >= 0) {\n        const newSystems = [...systems];\n        newSystems[index] = { ...system, enabled: system.enabled === false ? true : false };\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedSystem &&\n      confirm(`Delete system \"${selectedSystem.config?.name || selectedSystem.config?.id}\"?`)\n    ) {\n      const newSystems = systems.filter((_, i) => i !== selectedIndex);\n      onChange(newSystems);\n      setSelectedId(null);\n    }\n  }, [systems, onChange, selectedIndex, selectedSystem]);\n\n  const handleAddSystem = useCallback(\n    (type) => {\n      const needsSelection = [\n        \"graphContagion\",\n        \"connectionEvolution\",\n        \"thresholdTrigger\",\n        \"clusterFormation\",\n        \"tagDiffusion\",\n        \"planeDiffusion\",\n      ].includes(type);\n      const newSystem = {\n        systemType: type,\n        config: {\n          id: `system_${Date.now()}`,\n          name: `New ${SYSTEM_TYPES[type]?.label || type}`,\n          description: \"\",\n          ...(needsSelection ? { selection: { strategy: \"by_kind\", kind: \"any\" } } : {}),\n        },\n      };\n      onChange([...systems, newSystem]);\n      setSelectedId(newSystem.config.id);\n      setShowTypePicker(false);\n    },\n    [systems, onChange]\n  );\n\n  const toggleCategoryExpand = useCallback((type) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [type]: !prev[type],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (category) => {\n      const categoryItems = groupedSystems[category] || [];\n      const allEnabled = categoryItems.every((s) => s.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of systems in this category\n      const categoryIds = new Set(categoryItems.map((s) => s.config?.id));\n\n      const newSystems = systems.map((s) => {\n        if (categoryIds.has(s.config?.id)) {\n          return { ...s, enabled: newEnabled };\n        }\n        return s;\n      });\n      onChange(newSystems);\n    },\n    [systems, groupedSystems, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Systems</h1>\n        <p className=\"subtitle\">\n          Configure simulation systems that run during the simulation phase. Click a system to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((category) => {\n        const categoryConfig = SYSTEM_CATEGORIES[category] || { icon: \"\u2699\ufe0f\", label: category };\n        const categoryItems = groupedSystems[category] || [];\n        const allEnabled = categoryItems.every((s) => s.enabled !== false);\n\n        return (\n          <CategorySection\n            key={category}\n            id={category}\n            icon={categoryConfig.icon}\n            label={categoryConfig.label}\n            items={categoryItems}\n            expanded={expandedCategories[category] !== false}\n            onToggleExpand={() => toggleCategoryExpand(category)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(category)}\n            gridClassName=\"list-grid\"\n            renderItem={(system) => {\n              const flatIndex = systems.findIndex((s) => s.config?.id === system.config?.id);\n              return (\n                <SystemListCard\n                  key={flatIndex}\n                  system={system}\n                  onClick={() => setSelectedId(system.config.id)}\n                  onToggle={() => handleToggle(system)}\n                  usageMap={usageMap}\n                />\n              );\n            }}\n          />\n        );\n      })}\n\n      {/* Add System button */}\n      <div className=\"mt-xl\">\n        <div\n          className=\"add-card se-add-card-wrap\"\n          onClick={() => setShowTypePicker(true)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"se-add-icon\">+</span>\n          <span>Add System</span>\n        </div>\n      </div>\n\n      {showTypePicker && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal se-type-picker-modal\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Choose System Type</div>\n              <button className=\"close-btn\" onClick={() => setShowTypePicker(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"se-type-picker-content\">\n              <div className=\"type-picker\">\n                {Object.entries(SYSTEM_TYPES).map(([type, config]) => (\n                  <div\n                    key={type}\n                    className=\"se-type-option type-option\"\n                    onClick={() => handleAddSystem(type)}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <div className=\"type-option-icon\">{config.icon}</div>\n                    <div className=\"type-option-label\">{config.label}</div>\n                    <div className=\"type-option-desc\">{config.desc}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {selectedSystem && (\n        <SystemModal\n          system={selectedSystem}\n          onChange={handleSystemChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; systems?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./constants", "specifiers": ["SYSTEM_TYPES", "SYSTEM_CATEGORIES", "getSystemCategory"], "category": "internal"}, {"source": "../shared", "specifiers": ["CategorySection"], "category": "internal"}, {"source": "./cards/SystemListCard", "specifiers": ["SystemListCard"], "category": "internal"}, {"source": "./SystemModal", "specifiers": ["SystemModal"], "category": "internal"}, {"source": "../../utils/persistence", "specifiers": ["buildStorageKey", "clearStoredValue", "loadStoredValue", "saveStoredValue"], "category": "internal"}, {"source": "./SystemsEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/validation/index.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/index.js", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/index.js::getValidationStatus", "name": "getValidationStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/index.js", "sourceCode": "/**\n * Export validation status calculation for use by parent\n */\nexport function getValidationStatus(usageMap, schema, eras, pressures, generators, systems) {\n  const results = runValidations(\n    usageMap,\n    schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    eras || [],\n    pressures || [],\n    generators || [],\n    systems || []\n  );\n  return {\n    status: getOverallStatus(results),\n    errorCount: results.errors.length,\n    warningCount: results.warnings.length,\n    totalIssues: results.errors.length + results.warnings.length,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}], "returnType": "{ status: string; errorCount: number; warningCount: number; totalIssues: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../DependencyViewer", "specifiers": ["DependencyViewer"], "category": "internal"}, {"source": "../NamingProfileMappingViewer", "specifiers": ["NamingProfileMappingViewer"], "category": "internal"}, {"source": "./validation.css", "specifiers": [], "category": "internal"}, {"source": "./utils", "specifiers": ["exportAsJson", "exportAsCsv", "runValidations", "getOverallStatus", "validationRules"], "category": "internal"}, {"source": "./cards", "specifiers": ["IssueCard"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx::getValidationStatus", "name": "getValidationStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx", "sourceCode": "/**\n * Export validation status calculation for use by parent\n */\nexport function getValidationStatus(usageMap, schema, eras, pressures, generators, systems) {\n  const results = runValidations(\n    usageMap,\n    schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    eras || [],\n    pressures || [],\n    generators || [],\n    systems || []\n  );\n  return {\n    status: getOverallStatus(results),\n    errorCount: results.errors.length,\n    warningCount: results.warnings.length,\n    totalIssues: results.errors.length + results.warnings.length,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}], "returnType": "{ status: string; errorCount: number; warningCount: number; totalIssues: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../DependencyViewer", "specifiers": ["DependencyViewer"], "category": "internal"}, {"source": "../NamingProfileMappingViewer", "specifiers": ["NamingProfileMappingViewer"], "category": "internal"}, {"source": "./validation.css", "specifiers": [], "category": "internal"}, {"source": "./utils", "specifiers": ["exportAsJson", "exportAsCsv", "runValidations", "getOverallStatus", "validationRules"], "category": "internal"}, {"source": "./cards", "specifiers": ["IssueCard"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/weight-matrix/WeightMatrixEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/weight-matrix/WeightMatrixEditor.jsx", "sourceCode": "export default function WeightMatrixEditor({\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}) {\n  const [viewMode, setViewMode] = useState(\"generators\"); // 'generators' | 'systems'\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [editingCell, setEditingCell] = useState(null); // shape: rowId + eraId\n  const [editValue, setEditValue] = useState(\"\");\n  const [selectedRows, setSelectedRows] = useState(new Set());\n  const [copiedRow, setCopiedRow] = useState(null); // { id, weights: { eraId: value } }\n  const inputRef = useRef(null);\n\n  // Get current items based on view mode\n  const items = useMemo(() => {\n    const source = viewMode === \"generators\" ? generators : systems;\n    return source.map(item => ({\n      id: viewMode === \"generators\" ? item.id : item.config.id,\n      name: viewMode === \"generators\" ? item.name || item.id : item.config.name || item.config.id,\n      type: viewMode === \"generators\" ? \"generator\" : item.systemType\n    }));\n  }, [viewMode, generators, systems]);\n\n  // Detect orphaned references - IDs in eras that don't exist in generators/systems\n  const orphanedReferences = useMemo(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const orphanedGenerators = [];\n    const orphanedSystems = [];\n    eras.forEach(era => {\n      // Check template weights\n      Object.keys(era.templateWeights || {}).forEach(id => {\n        if (!generatorIds.has(id)) {\n          orphanedGenerators.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n\n      // Check system modifiers\n      Object.keys(era.systemModifiers || {}).forEach(id => {\n        if (!systemIds.has(id)) {\n          orphanedSystems.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n    });\n    return {\n      generators: orphanedGenerators,\n      systems: orphanedSystems\n    };\n  }, [eras, generators, systems]);\n\n  // Count total orphans\n  const totalOrphans = orphanedReferences.generators.length + orphanedReferences.systems.length;\n\n  // Clean up all orphaned references\n  const cleanupOrphanedReferences = useCallback(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const newEras = eras.map(era => {\n      const newTemplateWeights = {\n        ...era.templateWeights\n      };\n      const newSystemModifiers = {\n        ...era.systemModifiers\n      };\n\n      // Remove orphaned generator references\n      Object.keys(newTemplateWeights).forEach(id => {\n        if (!generatorIds.has(id)) {\n          delete newTemplateWeights[id];\n        }\n      });\n\n      // Remove orphaned system references\n      Object.keys(newSystemModifiers).forEach(id => {\n        if (!systemIds.has(id)) {\n          delete newSystemModifiers[id];\n        }\n      });\n      return {\n        ...era,\n        templateWeights: newTemplateWeights,\n        systemModifiers: newSystemModifiers\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, generators, systems, onErasChange]);\n\n  // Filter items by search\n  const filteredItems = useMemo(() => {\n    if (!searchQuery) return items;\n    const query = searchQuery.toLowerCase();\n    return items.filter(item => item.id.toLowerCase().includes(query) || item.name.toLowerCase().includes(query));\n  }, [items, searchQuery]);\n\n  // Get weight for an item in an era\n  const getWeight = useCallback((itemId, eraId) => {\n    const era = eras.find(e => e.id === eraId);\n    if (!era) return null;\n    const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n    return weights?.[itemId] ?? null;\n  }, [eras, viewMode]);\n\n  // Set weight for an item in an era\n  const setWeight = useCallback((itemId, eraId, value) => {\n    const newEras = eras.map(era => {\n      if (era.id !== eraId) return era;\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === \"\" || value === undefined) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = parseFloat(value) || 0;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, viewMode, onErasChange]);\n\n  // Handle cell click to start editing\n  const handleCellClick = (rowId, eraId) => {\n    const currentValue = getWeight(rowId, eraId);\n    setEditingCell({\n      rowId,\n      eraId\n    });\n    setEditValue(currentValue !== null ? String(currentValue) : \"\");\n    setTimeout(() => inputRef.current?.select(), 0);\n  };\n\n  // Handle cell edit completion\n  const handleCellBlur = () => {\n    if (editingCell) {\n      const value = editValue.trim();\n      if (value === \"\") {\n        setWeight(editingCell.rowId, editingCell.eraId, null);\n      } else {\n        const numValue = parseFloat(value);\n        if (!isNaN(numValue)) {\n          setWeight(editingCell.rowId, editingCell.eraId, numValue);\n        }\n      }\n      setEditingCell(null);\n    }\n  };\n\n  // Handle keyboard navigation\n  const handleKeyDown = e => {\n    if (e.key === \"Enter\" || e.key === \"Tab\") {\n      e.preventDefault();\n      handleCellBlur();\n    } else if (e.key === \"Escape\") {\n      setEditingCell(null);\n    }\n  };\n\n  // Apply weight to all eras for a row\n  const applyToAllEras = (itemId, value) => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === 0) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = value;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Copy row weights\n  const copyRow = itemId => {\n    const weights = {};\n    eras.forEach(era => {\n      const value = getWeight(itemId, era.id);\n      if (value !== null) {\n        weights[era.id] = value;\n      }\n    });\n    setCopiedRow({\n      id: itemId,\n      weights\n    });\n  };\n\n  // Paste row weights\n  const pasteRow = targetItemId => {\n    if (!copiedRow) return;\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (copiedRow.weights[era.id] !== undefined) {\n        weights[targetItemId] = copiedRow.weights[era.id];\n      } else {\n        delete weights[targetItemId];\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Remove from all eras\n  const removeFromAllEras = itemId => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      delete weights[itemId];\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Check if item is used in any era\n  const isUsedInAnyEra = itemId => {\n    return eras.some(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] !== undefined && weights[itemId] !== null;\n    });\n  };\n\n  // Count eras where item is active\n  const countActiveEras = itemId => {\n    return eras.filter(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] > 0;\n    }).length;\n  };\n\n  // Quick set weight for bulk operations\n  const [quickSetValue, setQuickSetValue] = useState(1);\n  const handleQuickSetSelected = () => {\n    const value = quickSetValue ?? 0;\n    selectedRows.forEach(itemId => {\n      applyToAllEras(itemId, value);\n    });\n    setSelectedRows(new Set());\n  };\n  const toggleRowSelection = itemId => {\n    const newSelection = new Set(selectedRows);\n    if (newSelection.has(itemId)) {\n      newSelection.delete(itemId);\n    } else {\n      newSelection.add(itemId);\n    }\n    setSelectedRows(newSelection);\n  };\n  const selectAllRows = () => {\n    if (selectedRows.size === filteredItems.length) {\n      setSelectedRows(new Set());\n    } else {\n      setSelectedRows(new Set(filteredItems.map(i => i.id)));\n    }\n  };\n  return <div className=\"weight-matrix-editor\">\n      <div className=\"header\">\n        <h1 className=\"title\">Weight Matrix</h1>\n        <p className=\"subtitle\">\n          Manage {viewMode} weights across all eras in a spreadsheet view. Click any cell to edit,\n          or use row actions for bulk operations.\n        </p>\n      </div>\n\n      {/* Orphaned References Warning */}\n      {totalOrphans > 0 && <div className=\"orphan-warning\">\n          <div className=\"orphan-warning-content\">\n            <span className=\"orphan-warning-icon\">\u26a0\ufe0f</span>\n            <div className=\"orphan-warning-text\">\n              <strong>\n                {totalOrphans} orphaned reference{totalOrphans !== 1 ? \"s\" : \"\"} detected\n              </strong>\n              <span className=\"orphan-warning-details\">\n// ... (truncated)", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}", "type": "{ generators?: any[]; systems?: any[]; eras?: any[]; onErasChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../shared", "specifiers": ["NumberInput"], "category": "internal"}, {"source": "./WeightMatrixEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx", "sourceCode": "export default function AxisRegistryEditor({\n  axisDefinitions = [],\n  entityKinds = [],\n  tagRegistry = [],\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n}) {\n  const [showModal, setShowModal] = useState(false);\n  const [editingAxis, setEditingAxis] = useState(null);\n  const [formData, setFormData] = useState({\n    id: \"\",\n    name: \"\",\n    description: \"\",\n    lowTag: \"\",\n    highTag: \"\",\n  });\n\n  // Compute which entity kinds use each axis\n  const axisUsage = useMemo(() => {\n    const usage = {};\n    for (const axis of axisDefinitions) {\n      usage[axis.id] = [];\n    }\n\n    for (const ek of entityKinds) {\n      const axes = ek.semanticPlane?.axes || {};\n      for (const [axisKey, axisConfig] of Object.entries(axes)) {\n        if (axisConfig.axisId && usage[axisConfig.axisId]) {\n          usage[axisConfig.axisId].push({\n            kind: ek.kind,\n            description: ek.description,\n            axis: axisKey.toUpperCase(),\n          });\n        }\n      }\n    }\n\n    return usage;\n  }, [axisDefinitions, entityKinds]);\n\n  const openNewModal = () => {\n    setEditingAxis(null);\n    setFormData({\n      id: \"\",\n      name: \"\",\n      description: \"\",\n      lowTag: \"\",\n      highTag: \"\",\n    });\n    setShowModal(true);\n  };\n\n  const openEditModal = (axis) => {\n    setEditingAxis(axis);\n    setFormData({\n      id: axis.id,\n      name: axis.name,\n      description: axis.description || \"\",\n      lowTag: axis.lowTag,\n      highTag: axis.highTag,\n    });\n    setShowModal(true);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setEditingAxis(null);\n  };\n\n  const generateId = (name) => {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"_\")\n      .replace(/^_|_$/g, \"\");\n  };\n\n  const handleNameChange = (name) => {\n    setFormData((prev) => ({\n      ...prev,\n      name,\n      // Auto-generate ID only if creating new or ID hasn't been manually edited\n      id: !editingAxis ? generateId(name) : prev.id,\n    }));\n  };\n\n  const ensureTagExists = (tagId, isAxis = true) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing) {\n      // Update existing tag to be an axis tag\n      if (!existing.isAxis) {\n        return { ...existing, isAxis: true };\n      }\n      return existing;\n    }\n    // Create new tag\n    return {\n      tag: tagId,\n      description: \"\",\n      category: \"trait\",\n      isAxis: true,\n    };\n  };\n\n  const saveAxis = () => {\n    if (!formData.name.trim() || !formData.lowTag.trim() || !formData.highTag.trim()) {\n      return;\n    }\n\n    if (!onAxisDefinitionsChange) {\n      return;\n    }\n\n    const axisId = formData.id || generateId(formData.name);\n    const newAxis = {\n      id: axisId,\n      name: formData.name.trim(),\n      description: formData.description.trim(),\n      lowTag: formData.lowTag.trim(),\n      highTag: formData.highTag.trim(),\n    };\n\n    // Update axis definitions\n    let newDefinitions;\n    if (editingAxis) {\n      newDefinitions = axisDefinitions.map((a) => (a.id === editingAxis.id ? newAxis : a));\n    } else {\n      newDefinitions = [...axisDefinitions, newAxis];\n    }\n\n    onAxisDefinitionsChange(newDefinitions);\n\n    // Auto-manage tags if callback is provided\n    if (onTagRegistryChange) {\n      const lowTagEntry = ensureTagExists(newAxis.lowTag);\n      const highTagEntry = ensureTagExists(newAxis.highTag);\n\n      // Set mutual exclusivity between the tags\n      const lowWithExclusive = {\n        ...lowTagEntry,\n        mutuallyExclusiveWith: [\n          ...new Set([...(lowTagEntry.mutuallyExclusiveWith || []), newAxis.highTag]),\n        ],\n      };\n      const highWithExclusive = {\n        ...highTagEntry,\n        mutuallyExclusiveWith: [\n          ...new Set([...(highTagEntry.mutuallyExclusiveWith || []), newAxis.lowTag]),\n        ],\n      };\n\n      // Update tag registry\n      let newRegistry = [...tagRegistry];\n\n      // Update or add low tag\n      const lowIdx = newRegistry.findIndex((t) => t.tag === newAxis.lowTag);\n      if (lowIdx >= 0) {\n        newRegistry[lowIdx] = lowWithExclusive;\n      } else {\n        newRegistry.push(lowWithExclusive);\n      }\n\n      // Update or add high tag\n      const highIdx = newRegistry.findIndex((t) => t.tag === newAxis.highTag);\n      if (highIdx >= 0) {\n        newRegistry[highIdx] = highWithExclusive;\n      } else {\n        newRegistry.push(highWithExclusive);\n      }\n\n      onTagRegistryChange(newRegistry);\n    }\n\n    closeModal();\n  };\n\n  const deleteAxis = (axisId) => {\n    const usage = axisUsage[axisId] || [];\n    if (usage.length > 0) {\n      const kindList = usage.map((u) => u.description || u.kind).join(\", \");\n      if (!window.confirm(`This axis is used by: ${kindList}. Delete anyway?`)) {\n        return;\n      }\n    }\n\n    const newDefinitions = axisDefinitions.filter((a) => a.id !== axisId);\n    onAxisDefinitionsChange(newDefinitions);\n  };\n\n  return (\n    <div className=\"axr-container\">\n      <div className=\"axr-header\">\n        <div className=\"axr-title\">Axis Registry</div>\n        <div className=\"axr-subtitle\">\n          Define reusable semantic axes. Tags are auto-configured when you save.\n        </div>\n      </div>\n\n      <div className=\"axr-toolbar\">\n        <span className=\"axr-count\">\n          {axisDefinitions.length} {axisDefinitions.length === 1 ? \"axis\" : \"axes\"} defined\n        </span>\n        <button className=\"axr-add-button\" onClick={openNewModal}>\n          + New Axis\n        </button>\n      </div>\n\n      {axisDefinitions.length === 0 ? (\n        <div className=\"axr-empty-state\">\n          No axes defined yet. Create your first axis to start building semantic planes.\n        </div>\n      ) : (\n        <div className=\"axr-axis-list\">\n          {axisDefinitions.map((axis) => {\n            const usage = axisUsage[axis.id] || [];\n            return (\n              <div key={axis.id} className=\"axr-axis-card\">\n                <div className=\"axr-axis-header\">\n                  <div>\n                    <div className=\"axr-axis-name\">{axis.name}</div>\n                    {axis.description && (\n                      <div className=\"axr-axis-description\">{axis.description}</div>\n                    )}\n                  </div>\n                  <div className=\"axr-actions\">\n                    <button className=\"axr-edit-button\" onClick={() => openEditModal(axis)}>\n                      Edit\n                    </button>\n                    <button className=\"axr-delete-button\" onClick={() => deleteAxis(axis.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"axr-axis-range\">\n                  <span className=\"axr-tag\">{axis.lowTag}</span>\n                  <span className=\"axr-arrow\">\u2190\u2015\u2015\u2015\u2192</span>\n                  <span className=\"axr-tag\">{axis.highTag}</span>\n                </div>\n\n                {usage.length > 0 && (\n                  <div className=\"axr-usage-info\">\n                    Used in:{\" \"}\n                    {usage.map((u, i) => (\n                      <span key={u.kind}>\n                        {i > 0 && \", \"}\n                        <span className=\"axr-usage-kind\">\n                          {u.description || u.kind} ({u.axis})\n                        </span>\n                      </span>\n                    ))}\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Create/Edit Modal */}\n      {showModal && (\n        <div className=\"axr-modal\" onClick={closeModal} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") closeModal(); }} >\n          <div className=\"axr-modal-content\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n            <div className=\"axr-modal-title\">\n              {editingAxis ? `Edit Axis: ${editingAxis.name}` : \"New Axis Definition\"}\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"name\" className=\"axr-label\">Name</label>\n              <input id=\"name\"\n                className=\"axr-input\"\n                placeholder=\"e.g., Power, Alignment, Element\"\n                value={formData.name}\n                onChange={(e) => handleNameChange(e.target.value)}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"id\" className=\"axr-label\">ID</label>\n              <input id=\"id\"\n                className=\"axr-input\"\n                placeholder=\"e.g., power, alignment, element\"\n                value={formData.id}\n                onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n                disabled={!!editingAxis}\n              />\n              <div className=\"axr-hint\">\n                {editingAxis ? \"ID cannot be changed\" : \"Auto-generated from name\"}\n              </div>\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"description-optional\" className=\"axr-label\">Description (optional)</label>\n              <input id=\"description-optional\"\n                className=\"axr-input\"\n                placeholder=\"Brief description of this axis\"\n                value={formData.description}\n                onChange={(e) => setFormData({ ...formData, description: e.target.value })}\n              />\n// ... (truncated)", "parameters": [{"name": "{\n  axisDefinitions = [],\n  entityKinds = [],\n  tagRegistry = [],\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n}", "type": "{ axisDefinitions?: any[]; entityKinds?: any[]; tagRegistry?: any[]; onAxisDefinitionsChange: any; onTagRegistryChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector"], "category": "external"}, {"source": "./AxisRegistry.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/CultureEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/CultureEditor/index.jsx", "sourceCode": "export default function CultureEditor({ project, onSave }) {\n  const [expandedCultures, setExpandedCultures] = useState({});\n  // Track local slider value during drag to avoid expensive state updates\n  const [localSliderValue, setLocalSliderValue] = useState(null);\n  const draggingRef = useRef(null); // tracks cultureId, kindId, axis\n\n  const cultures = project?.cultures || [];\n  const entityKinds = project?.entityKinds || [];\n  const axisDefinitions = useMemo(() => project?.axisDefinitions || [], [project?.axisDefinitions]);\n  const axisById = useMemo(() => {\n    return new Map(axisDefinitions.map((axis) => [axis.id, axis]));\n  }, [axisDefinitions]);\n\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => ({ ...prev, [cultureId]: !prev[cultureId] }));\n  };\n\n  const updateCultures = (newCultures) => {\n    onSave({ cultures: newCultures });\n  };\n\n  const updateCulture = (cultureId, updates) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    updateCultures(cultures.map((c) => (c.id === cultureId ? { ...c, ...updates } : c)));\n  };\n\n  const commitAxisBias = (cultureId, kindId, axis, value) => {\n    const culture = cultures.find((c) => c.id === cultureId);\n    if (!culture) return;\n\n    const kindBiases = culture.axisBiases?.[kindId] || { x: 50, y: 50, z: 50 };\n\n    updateCulture(cultureId, {\n      axisBiases: {\n        ...culture.axisBiases,\n        [kindId]: {\n          ...kindBiases,\n          [axis]: parseInt(value, 10),\n        },\n      },\n    });\n  };\n\n  const handleSliderStart = (cultureId, kindId, axis, value) => {\n    draggingRef.current = { cultureId, kindId, axis };\n    setLocalSliderValue(parseInt(value, 10));\n  };\n\n  const handleSliderChange = (value) => {\n    if (draggingRef.current) {\n      setLocalSliderValue(parseInt(value, 10));\n    }\n  };\n\n  const handleSliderEnd = () => {\n    if (draggingRef.current && localSliderValue !== null) {\n      const { cultureId, kindId, axis } = draggingRef.current;\n      commitAxisBias(cultureId, kindId, axis, localSliderValue);\n    }\n    draggingRef.current = null;\n    setLocalSliderValue(null);\n  };\n\n  const getDisplayValue = (cultureId, kindId, axis, storedValue) => {\n    if (\n      draggingRef.current &&\n      draggingRef.current.cultureId === cultureId &&\n      draggingRef.current.kindId === kindId &&\n      draggingRef.current.axis === axis &&\n      localSliderValue !== null\n    ) {\n      return localSliderValue;\n    }\n    return storedValue;\n  };\n\n  const getBiasSummary = (culture) => {\n    const biasCount = Object.keys(culture.axisBiases || {}).length;\n    return `${biasCount} kind${biasCount !== 1 ? \"s\" : \"\"} configured`;\n  };\n\n  return (\n    <div className=\"cued-container\">\n      <div className=\"cued-header\">\n        <div className=\"cued-title\">Culture Biases</div>\n        <div className=\"cued-subtitle\">\n          Configure axis biases for each culture on each entity kind&apos;s semantic plane.\n        </div>\n      </div>\n\n      {cultures.length === 0 ? (\n        <div className=\"cued-empty-state\">\n          No cultures defined yet. Add cultures in the Enumerist tab first.\n        </div>\n      ) : (\n        <div className=\"cued-culture-list\">\n          {cultures.map((culture) => {\n            const isExpanded = expandedCultures[culture.id];\n            const isFramework = Boolean(culture.isFramework);\n\n            return (\n              <div key={culture.id} className=\"cued-culture-card\">\n                <div className=\"cued-culture-header\" onClick={() => toggleCulture(culture.id)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  <div className=\"cued-culture-header-left\">\n                    <span\n                      className=\"cued-expand-icon\"\n                      style={{ '--cued-expand-rotation': isExpanded ? \"rotate(90deg)\" : \"rotate(0deg)\" }}\n                    >\n                      \u25b6\n                    </span>\n                    <div className=\"cued-color-dot\" style={{ '--cued-color-dot-bg': culture.color }} />\n                    <span className=\"cued-culture-name\">{culture.name}</span>\n                    <span className=\"cued-culture-id\">({culture.id})</span>\n                    {isFramework && (\n                      <span className=\"cued-framework-badge\">framework</span>\n                    )}\n                  </div>\n                  <div className=\"cued-culture-summary\">{getBiasSummary(culture)}</div>\n                </div>\n\n                {isExpanded && (\n                  <div className=\"cued-culture-body\">\n                    {entityKinds.length === 0 ? (\n                      <div className=\"cued-no-kinds-warning\">\n                        Define entity kinds in the Enumerist tab first to configure axis biases.\n                      </div>\n                    ) : (\n                      <div className=\"cued-kinds-grid\">\n                        {entityKinds.map((kind) => (\n                          <KindBiasCard\n                            key={kind.kind}\n                            culture={culture}\n                            kind={kind}\n                            axisById={axisById}\n                            isFramework={isFramework}\n                            handleSliderStart={handleSliderStart}\n                            handleSliderChange={handleSliderChange}\n                            handleSliderEnd={handleSliderEnd}\n                            getDisplayValue={getDisplayValue}\n                            draggingRef={draggingRef}\n                          />\n                        ))}\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ project, onSave }", "type": "{ project: any; onSave: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CultureEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/EntityEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/EntityEditor/index.jsx", "sourceCode": "export default function EntityEditor({ project, onSave, onAddTag, schemaUsage = {} }) {\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [filterKind, setFilterKind] = useState(\"\");\n  const [generating, setGenerating] = useState(false);\n  const [generateError, setGenerateError] = useState(null);\n\n  const entities = project?.seedEntities || [];\n  // Schema v2: entityKinds at project root\n  const entityKinds = project?.entityKinds || [];\n  const cultures = project?.cultures || [];\n  const tagRegistry = project?.tagRegistry || [];\n\n  const filteredEntities = filterKind ? entities.filter((e) => e.kind === filterKind) : entities;\n\n  const selectedEntity = entities.find((e) => e.id === selectedEntityId);\n  const selectedKindDef = entityKinds.find((k) => k.kind === selectedEntity?.kind);\n\n  const updateEntities = (newEntities) => {\n    onSave({ seedEntities: newEntities });\n  };\n\n  const addEntity = () => {\n    const defaultKind = entityKinds[0];\n    if (!defaultKind) {\n      alert(\"Define entity kinds in Schema first\");\n      return;\n    }\n\n    const newEntity = {\n      id: `entity_${Date.now()}`,\n      kind: defaultKind.kind,\n      subtype: defaultKind.subtypes[0]?.id || \"\",\n      name: \"New Entity\",\n      summary: \"\",\n      narrativeHint: \"\",\n      description: \"\",\n      status: defaultKind.statuses[0]?.id || \"active\",\n      prominence: \"recognized\",\n      culture: cultures[0]?.id || \"\",\n      tags: {}, // Key-value pairs for semantic tagging\n      links: [], // Relationships are stored separately, populated at load time\n      coordinates: { x: 50, y: 50, z: 50 },\n      createdAt: 0,\n      updatedAt: 0,\n    };\n\n    updateEntities([...entities, newEntity]);\n    setSelectedEntityId(newEntity.id);\n  };\n\n  const updateEntity = (updates) => {\n    if (!selectedEntity) return;\n\n    // If kind changed, reset subtype and status\n    if (updates.kind && updates.kind !== selectedEntity.kind) {\n      const newKind = entityKinds.find((k) => k.kind === updates.kind);\n      updates.subtype = newKind?.subtypes[0]?.id || \"\";\n      updates.status = newKind?.statuses[0]?.id || \"active\";\n    }\n\n    updateEntities(entities.map((e) => (e.id === selectedEntityId ? { ...e, ...updates } : e)));\n  };\n\n  const deleteEntity = () => {\n    if (!selectedEntity) return;\n    if (!confirm(`Delete \"${selectedEntity.name}\"?`)) return;\n\n    updateEntities(entities.filter((e) => e.id !== selectedEntityId));\n    setSelectedEntityId(null);\n  };\n\n  const getCultureColor = (cultureId) => {\n    return cultures.find((c) => c.id === cultureId)?.color || \"#707080\";\n  };\n\n  const handleGenerateName = async () => {\n    if (!selectedEntity) return;\n\n    const culture = cultures.find((c) => c.id === selectedEntity.culture);\n    if (!culture) {\n      setGenerateError(\"Select a culture first\");\n      return;\n    }\n\n    // Check if culture has naming profiles\n    if (!culture.naming?.profiles || culture.naming.profiles.length === 0) {\n      setGenerateError(\n        `Culture \"${culture.name || culture.id}\" has no naming profiles. Configure naming in Name Forge first.`\n      );\n      return;\n    }\n\n    setGenerating(true);\n    setGenerateError(null);\n\n    try {\n      const name = await generateEntityName(culture, {\n        kind: selectedEntity.kind,\n        subtype: selectedEntity.subtype,\n        prominence: selectedEntity.prominence,\n        tags: Object.keys(selectedEntity.tags || {}),\n      });\n      updateEntity({ name });\n    } catch (err) {\n      console.error(\"Name generation error:\", err);\n      setGenerateError(err.message || \"Failed to generate name\");\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  // Check if current entity can have names generated\n  const canGenerateName = () => {\n    if (!selectedEntity) return false;\n    const culture = cultures.find((c) => c.id === selectedEntity.culture);\n    return culture && culture.naming?.profiles && culture.naming.profiles.length > 0;\n  };\n\n  // Convert tags from object format { tag: true } to array format ['tag']\n  const getTagsAsArray = () => {\n    const tags = selectedEntity?.tags || {};\n    return Object.keys(tags);\n  };\n\n  // Update tags from array format back to object format\n  const handleTagsChange = (tagArray) => {\n    if (!selectedEntity) return;\n    const tagsObj = {};\n    tagArray.forEach((tag) => {\n      tagsObj[tag] = true;\n    });\n    updateEntity({ tags: tagsObj });\n  };\n\n  return (\n    <div className=\"ee-container\">\n      <div className=\"ee-list-panel\">\n        <div className=\"ee-header\">\n          <div className=\"ee-title\">Entities</div>\n          <div className=\"ee-subtitle\">Create seed entities to populate your world.</div>\n        </div>\n\n        <div className=\"ee-toolbar\">\n          <select\n            className=\"ee-filter-select\"\n            value={filterKind}\n            onChange={(e) => setFilterKind(e.target.value)}\n          >\n            <option value=\"\">All kinds ({entities.length})</option>\n            {entityKinds.map((k) => (\n              <option key={k.kind} value={k.kind}>\n                {k.description || k.kind} ({entities.filter((e) => e.kind === k.kind).length})\n              </option>\n            ))}\n          </select>\n          <button className=\"ee-add-button\" onClick={addEntity}>\n            + Add\n          </button>\n        </div>\n\n        <div className=\"ee-entity-list\">\n          {filteredEntities.length === 0 ? (\n            <div className=\"ee-empty-state\">\n              {entities.length === 0\n                ? \"No entities yet. Create one to get started.\"\n                : \"No entities match the filter.\"}\n            </div>\n          ) : (\n            filteredEntities.map((entity) => (\n              <div\n                key={entity.id}\n                className={`ee-entity-item${selectedEntityId === entity.id ? \" ee-entity-item-selected\" : \"\"}`}\n                onClick={() => setSelectedEntityId(entity.id)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div\n                  className=\"ee-entity-color\"\n                  style={{ '--ee-entity-color-bg': getCultureColor(entity.culture) }}\n                />\n                <div className=\"ee-entity-info\">\n                  <div className=\"ee-entity-name\">{entity.name}</div>\n                  <div className=\"ee-entity-meta-row\">\n                    <span className=\"ee-entity-meta\">\n                      {entity.kind} / {entity.subtype || \"no subtype\"}\n                    </span>\n                    <UsageBadges\n                      usage={getEntityKindUsageSummary(schemaUsage, entity.kind)}\n                      compact\n                    />\n                  </div>\n                </div>\n              </div>\n            ))\n          )}\n        </div>\n      </div>\n\n      <div className=\"ee-form-panel\">\n        {!selectedEntity ? (\n          <div className=\"ee-empty-form\">Select an entity to edit, or create a new one.</div>\n        ) : (\n          <>\n            <div className=\"ee-form-title\">Edit Entity</div>\n\n            <div className=\"ee-form-group\">\n              <span className=\"ee-label\">Name</span>\n              <div className=\"ee-name-row\">\n                <input\n                  className=\"ee-input ee-name-input\"\n                  value={selectedEntity.name}\n                  onChange={(e) => updateEntity({ name: e.target.value })}\n                />\n                <button\n                  className={`ee-generate-button${!canGenerateName() || generating ? \" ee-generate-button-disabled\" : \"\"}`}\n                  onClick={handleGenerateName}\n                  disabled={!canGenerateName() || generating}\n                  title={(() => {\n                    if (!selectedEntity.culture) return \"Select a culture first\";\n                    if (!canGenerateName()) return \"Configure naming in Name Forge first\";\n                    return \"Generate a culturally-appropriate name\";\n                  })()}\n                >\n                  {generating ? \"Generating...\" : \"Generate\"}\n                </button>\n              </div>\n              {generateError && (\n                <div className=\"ee-generate-error\">\n                  {generateError}\n                </div>\n              )}\n            </div>\n\n            <div className=\"ee-row\">\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"kind\" className=\"ee-label\">Kind</label>\n                <select id=\"kind\"\n                  className=\"ee-select\"\n                  value={selectedEntity.kind}\n                  onChange={(e) => updateEntity({ kind: e.target.value })}\n                >\n                  {entityKinds.map((k) => (\n                    <option key={k.kind} value={k.kind}>\n                      {k.description || k.kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"subtype\" className=\"ee-label\">Subtype</label>\n                <select id=\"subtype\"\n                  className=\"ee-select\"\n                  value={selectedEntity.subtype || \"\"}\n                  onChange={(e) => updateEntity({ subtype: e.target.value })}\n                >\n                  <option value=\"\">None</option>\n                  {selectedKindDef?.subtypes?.map((s) => (\n                    <option key={s.id} value={s.id}>\n                      {s.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            <div className=\"ee-row\">\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"status\" className=\"ee-label\">Status</label>\n                <select id=\"status\"\n                  className=\"ee-select\"\n                  value={selectedEntity.status}\n                  onChange={(e) => updateEntity({ status: e.target.value })}\n                >\n                  {selectedKindDef?.statuses?.map((s) => (\n                    <option key={s.id} value={s.id}>\n                      {s.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"culture\" className=\"ee-label\">Culture</label>\n                <select id=\"culture\"\n                  className=\"ee-select\"\n                  value={selectedEntity.culture || \"\"}\n                  onChange={(e) => updateEntity({ culture: e.target.value })}\n                >\n                  <option value=\"\">None</option>\n                  {cultures.map((c) => (\n                    <option key={c.id} value={c.id}>\n                      {c.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n// ... (truncated)", "parameters": [{"name": "{ project, onSave, onAddTag, schemaUsage = {} }", "type": "{ project: any; onSave: any; onAddTag: any; schemaUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../lib/name-generator.js", "specifiers": ["generateEntityName"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector", "ToolUsageBadges as UsageBadges", "getEntityKindUsageSummary"], "category": "external"}, {"source": "./EntityEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/RelationshipEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/RelationshipEditor/index.jsx", "sourceCode": "export default function RelationshipEditor({ project, onSave }) {\n  const [showModal, setShowModal] = useState(false);\n  const [filterKind, setFilterKind] = useState(\"\");\n  const [newRel, setNewRel] = useState({ kind: \"\", src: \"\", dst: \"\", strength: 1 });\n\n  const relationships = project?.seedRelationships || [];\n  const entities = project?.seedEntities || [];\n  // Schema v2: relationshipKinds at project root\n  const relationshipKinds = project?.relationshipKinds || [];\n\n  const filteredRels = filterKind\n    ? relationships.filter((r) => r.kind === filterKind)\n    : relationships;\n\n  const updateRelationships = (newRels) => {\n    onSave({ seedRelationships: newRels });\n  };\n\n  const addRelationship = () => {\n    if (!newRel.kind || !newRel.src || !newRel.dst) {\n      alert(\"Please fill all required fields\");\n      return;\n    }\n\n    if (newRel.src === newRel.dst) {\n      alert(\"Source and destination must be different\");\n      return;\n    }\n\n    const rel = {\n      kind: newRel.kind,\n      src: newRel.src,\n      dst: newRel.dst,\n      strength: parseFloat(newRel.strength) || 1,\n    };\n\n    updateRelationships([...relationships, rel]);\n    setShowModal(false);\n    setNewRel({ kind: \"\", src: \"\", dst: \"\", strength: 1 });\n  };\n\n  const deleteRelationship = (rel) => {\n    if (!confirm(\"Delete this relationship?\")) return;\n    updateRelationships(\n      relationships.filter((r) => !(r.kind === rel.kind && r.src === rel.src && r.dst === rel.dst))\n    );\n  };\n\n  const getEntityName = (entityId) => {\n    const entity = entities.find((e) => e.id === entityId);\n    return entity?.name || entityId;\n  };\n\n  const getRelKindName = (kindId) => {\n    const kind = relationshipKinds.find((k) => k.kind === kindId);\n    return kind?.description || kind?.kind || kindId;\n  };\n\n  // Filter entities by allowed source/dest kinds for the selected relationship\n  const selectedRelKind = relationshipKinds.find((k) => k.kind === newRel.kind);\n  const allowedSrcEntities = selectedRelKind?.srcKinds?.length\n    ? entities.filter((e) => selectedRelKind.srcKinds.includes(e.kind))\n    : entities;\n  const allowedDstEntities = selectedRelKind?.dstKinds?.length\n    ? entities.filter((e) => selectedRelKind.dstKinds.includes(e.kind))\n    : entities;\n\n  return (\n    <div className=\"re-container\">\n      <div className=\"re-header\">\n        <div className=\"re-title\">Relationships</div>\n        <div className=\"re-subtitle\">Define connections between seed entities.</div>\n      </div>\n\n      <div className=\"re-toolbar\">\n        <select\n          className=\"re-filter-select\"\n          value={filterKind}\n          onChange={(e) => setFilterKind(e.target.value)}\n        >\n          <option value=\"\">All kinds ({relationships.length})</option>\n          {relationshipKinds.map((k) => (\n            <option key={k.kind} value={k.kind}>\n              {k.description || k.kind} ({relationships.filter((r) => r.kind === k.kind).length})\n            </option>\n          ))}\n        </select>\n        <button\n          className=\"re-add-button\"\n          onClick={() => setShowModal(true)}\n          disabled={entities.length < 2 || relationshipKinds.length === 0}\n        >\n          + Add Relationship\n        </button>\n        {entities.length < 2 && (\n          <span className=\"re-hint\">Need at least 2 entities</span>\n        )}\n        {relationshipKinds.length === 0 && (\n          <span className=\"re-hint\">\n            Define relationship kinds in Schema first\n          </span>\n        )}\n      </div>\n\n      {filteredRels.length === 0 ? (\n        <div className=\"re-empty-state\">\n          {relationships.length === 0\n            ? \"No relationships yet. Create one to connect entities.\"\n            : \"No relationships match the filter.\"}\n        </div>\n      ) : (\n        <table className=\"re-table\">\n          <thead>\n            <tr>\n              <th className=\"re-th\">Kind</th>\n              <th className=\"re-th\">Source</th>\n              <th className=\"re-th\"></th>\n              <th className=\"re-th\">Destination</th>\n              <th className=\"re-th\">Strength</th>\n              <th className=\"re-th\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {filteredRels.map((rel, idx) => (\n              <tr key={`${rel.kind}-${rel.src}-${rel.dst}-${idx}`}>\n                <td className=\"re-td\">\n                  <span className=\"re-kind-badge\">{getRelKindName(rel.kind)}</span>\n                </td>\n                <td className=\"re-td\">\n                  <span className=\"re-entity-link\">{getEntityName(rel.src)}</span>\n                </td>\n                <td className=\"re-td-arrow\">\n                  <span className=\"re-arrow\">\u2192</span>\n                </td>\n                <td className=\"re-td\">\n                  <span className=\"re-entity-link\">{getEntityName(rel.dst)}</span>\n                </td>\n                <td className=\"re-td\">{rel.strength}</td>\n                <td className=\"re-td-actions\">\n                  <button className=\"re-delete-button\" onClick={() => deleteRelationship(rel)}>\n                    Delete\n                  </button>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n\n      {/* Add Relationship Modal */}\n      {showModal && (\n        <div className=\"re-modal\" onClick={() => setShowModal(false)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <div className=\"re-modal-content\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n            <div className=\"re-modal-title\">Add Relationship</div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"relationship-kind\" className=\"re-label\">Relationship Kind</label>\n              <select id=\"relationship-kind\"\n                className=\"re-select\"\n                value={newRel.kind}\n                onChange={(e) => setNewRel({ ...newRel, kind: e.target.value, src: \"\", dst: \"\" })}\n              >\n                <option value=\"\">Select kind...</option>\n                {relationshipKinds.map((k) => (\n                  <option key={k.kind} value={k.kind}>\n                    {k.description || k.kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"source-entity\" className=\"re-label\">Source Entity</label>\n              <select id=\"source-entity\"\n                className=\"re-select\"\n                value={newRel.src}\n                onChange={(e) => setNewRel({ ...newRel, src: e.target.value })}\n                disabled={!newRel.kind}\n              >\n                <option value=\"\">Select source...</option>\n                {allowedSrcEntities.map((e) => (\n                  <option key={e.id} value={e.id}>\n                    {e.name} ({e.kind})\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"destination-entity\" className=\"re-label\">Destination Entity</label>\n              <select id=\"destination-entity\"\n                className=\"re-select\"\n                value={newRel.dst}\n                onChange={(e) => setNewRel({ ...newRel, dst: e.target.value })}\n                disabled={!newRel.kind}\n              >\n                <option value=\"\">Select destination...</option>\n                {allowedDstEntities\n                  .filter((e) => e.id !== newRel.src)\n                  .map((e) => (\n                    <option key={e.id} value={e.id}>\n                      {e.name} ({e.kind})\n                    </option>\n                  ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label className=\"re-label\">Strength (0-1)\n              <NumberInput\n                className=\"re-input\"\n                min={0}\n                max={1}\n                step={0.1}\n                value={newRel.strength}\n                onChange={(v) => setNewRel({ ...newRel, strength: v ?? 0.5 })}\n              />\n              </label>\n            </div>\n\n            <div className=\"re-modal-actions\">\n              <button className=\"re-button\" onClick={() => setShowModal(false)}>\n                Cancel\n              </button>\n              <button className=\"re-add-button\" onClick={addRelationship}>\n                Add Relationship\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ project, onSave }", "type": "{ project: any; onSave: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["NumberInput"], "category": "external"}, {"source": "./RelationshipEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/SemanticPlane/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/SemanticPlane/index.jsx", "sourceCode": "export default function SemanticPlaneEditor({ project, onSave, axisDefinitions = [] }) {\n  const [selectedKindId, setSelectedKindId] = useState(null);\n  const [showNewRegionModal, setShowNewRegionModal] = useState(false);\n  const [showAxisModal, setShowAxisModal] = useState(false);\n  const [showRegionModal, setShowRegionModal] = useState(false);\n  const [editingAxis, setEditingAxis] = useState(null);\n  const [editingRegion, setEditingRegion] = useState(null);\n  const [newRegion, setNewRegion] = useState({\n    label: \"\",\n    x: 50,\n    y: 50,\n    radius: 15,\n    culture: \"\",\n    tags: [],\n  });\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [selectedRegionId, setSelectedRegionId] = useState(null);\n\n  // Schema v2: entityKinds at project root\n  const entityKinds = project?.entityKinds || [];\n  const cultures = project?.cultures || [];\n  const tagRegistry = project?.tagRegistry || [];\n  const seedEntities = project?.seedEntities || [];\n\n  // Helper to resolve axis config - looks up from registry by axisId\n  const resolveAxis = (axisConfig) => {\n    if (!axisConfig?.axisId) return null;\n    const registeredAxis = axisDefinitions.find((a) => a.id === axisConfig.axisId);\n    if (!registeredAxis) return null;\n    return {\n      axisId: registeredAxis.id,\n      name: registeredAxis.name,\n      lowTag: registeredAxis.lowTag,\n      highTag: registeredAxis.highTag,\n    };\n  };\n\n  // Select first kind by default\n  const selectedKind = entityKinds.find((k) => k.kind === selectedKindId) || entityKinds[0];\n  const semanticPlane = selectedKind?.semanticPlane || {\n    axes: {},\n    regions: [],\n  };\n  const planeEntities = seedEntities.filter((e) => e.kind === selectedKind?.kind);\n  const isFrameworkKind = Boolean(selectedKind?.isFramework);\n\n  const updateEntityKind = (kindId, updates) => {\n    const target = entityKinds.find((k) => k.kind === kindId);\n    if (target?.isFramework) return;\n    const newKinds = entityKinds.map((k) => (k.kind === kindId ? { ...k, ...updates } : k));\n    onSave({ entityKinds: newKinds });\n  };\n\n  const addRegion = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !newRegion.label.trim()) return;\n\n    // Use culture color if culture is selected, otherwise random color\n    const selectedCulture = cultures.find((c) => c.id === newRegion.culture);\n    const regionColor =\n      selectedCulture?.color ||\n      \"#\" +\n        // eslint-disable-next-line sonarjs/pseudo-random -- non-security random color fallback\n        Math.floor(Math.random() * 16777215)\n          .toString(16)\n          .padStart(6, \"0\");\n\n    const region = {\n      id: `region_${Date.now()}`,\n      label: newRegion.label.trim(),\n      color: regionColor,\n      culture: newRegion.culture || null,\n      tags: newRegion.tags || [],\n      bounds: {\n        shape: \"circle\",\n        center: { x: parseFloat(newRegion.x), y: parseFloat(newRegion.y) },\n        radius: parseFloat(newRegion.radius),\n      },\n    };\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: [...(semanticPlane.regions || []), region],\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowNewRegionModal(false);\n    setNewRegion({ label: \"\", x: 50, y: 50, radius: 15, culture: \"\" });\n  };\n\n  const deleteRegion = (regionId) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: (semanticPlane.regions || []).filter((r) => r.id !== regionId),\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const handleMoveEntity = (entityId, coords) => {\n    const entities = project?.seedEntities || [];\n    const updated = entities.map((e) =>\n      e.id === entityId\n        ? {\n            ...e,\n            coordinates: {\n              x: Math.round(coords.x),\n              y: Math.round(coords.y),\n              z: e.coordinates?.z || 50,\n            },\n          }\n        : e\n    );\n    onSave({ seedEntities: updated });\n  };\n\n  const handleMoveRegion = (regionId, coords) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === regionId\n        ? {\n            ...r,\n            bounds: {\n              ...r.bounds,\n              center: { x: Math.round(coords.x), y: Math.round(coords.y) },\n            },\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const handleResizeRegion = (regionId, newRadius) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === regionId\n        ? {\n            ...r,\n            bounds: {\n              ...r.bounds,\n              radius: Math.round(newRadius),\n            },\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const getCultureColor = (cultureId) => {\n    return cultures.find((c) => c.id === cultureId)?.color || \"#888\";\n  };\n\n  const openRegionEditor = (region) => {\n    if (isFrameworkKind) return;\n    setEditingRegion({\n      ...region,\n      tags: region.tags || [],\n    });\n    setShowRegionModal(true);\n  };\n\n  const saveRegionConfig = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !editingRegion) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === editingRegion.id\n        ? {\n            ...r,\n            label: editingRegion.label,\n            culture: editingRegion.culture || null,\n            tags: editingRegion.tags || [],\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowRegionModal(false);\n    setEditingRegion(null);\n  };\n\n  const openAxisEditor = (axisKey) => {\n    if (isFrameworkKind) return;\n    const rawAxisConfig = semanticPlane.axes?.[axisKey];\n    const resolved = resolveAxis(rawAxisConfig);\n    setEditingAxis({\n      key: axisKey,\n      axisId: rawAxisConfig?.axisId || \"\",\n      name: resolved?.name || \"\",\n      lowTag: resolved?.lowTag || \"\",\n      highTag: resolved?.highTag || \"\",\n    });\n    setShowAxisModal(true);\n  };\n\n  const handleAxisSelect = (axisId) => {\n    const axis = axisDefinitions.find((a) => a.id === axisId);\n    if (axis) {\n      setEditingAxis({\n        ...editingAxis,\n        axisId: axis.id,\n        name: axis.name,\n        lowTag: axis.lowTag,\n        highTag: axis.highTag,\n      });\n    }\n  };\n\n  const saveAxisConfig = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !editingAxis?.axisId) return;\n\n    const updatedAxes = {\n      ...semanticPlane.axes,\n      [editingAxis.key]: { axisId: editingAxis.axisId },\n    };\n\n    const updatedPlane = {\n      ...semanticPlane,\n      axes: updatedAxes,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowAxisModal(false);\n    setEditingAxis(null);\n  };\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"sp-container\">\n        <div className=\"sp-header\">\n          <div className=\"sp-title\">Semantic Planes</div>\n          <div className=\"sp-subtitle\">\n            View and edit the coordinate space for each entity kind.\n          </div>\n        </div>\n        <div className=\"sp-empty-state\">\n          Define entity kinds in the Enumerist tab first to view their semantic planes.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"sp-container\">\n      <div className=\"sp-header\">\n        <div className=\"sp-title\">Semantic Planes</div>\n        <div className=\"sp-subtitle\">\n          Drag entities to reposition. Scroll to zoom, drag background to pan.\n        </div>\n      </div>\n\n      <div className=\"sp-toolbar\">\n        <select\n          className=\"sp-select\"\n          value={selectedKind?.kind || \"\"}\n          onChange={(e) => {\n            setSelectedKindId(e.target.value);\n            setSelectedEntityId(null);\n            setSelectedRegionId(null);\n          }}\n        >\n          {entityKinds.map((k) => (\n            <option key={k.kind} value={k.kind}>\n              {k.description || k.kind} ({seedEntities.filter((e) => e.kind === k.kind).length}{\" \"}\n              entities)\n            </option>\n          ))}\n        </select>\n        <button\n          className={`sp-add-button${isFrameworkKind ? \" sp-add-button-disabled\" : \"\"}`}\n          onClick={() => setShowNewRegionModal(true)}\n          disabled={isFrameworkKind}\n        >\n          + Add Region\n        </button>\n// ... (truncated)", "parameters": [{"name": "{ project, onSave, axisDefinitions = [] }", "type": "{ project: any; onSave: any; axisDefinitions?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./PlaneCanvas.jsx", "specifiers": ["PlaneCanvas"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector", "NumberInput"], "category": "external"}, {"source": "./SemanticPlane.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/cosmographer/webui/src/components/SemanticPlane/PlaneCanvas.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/SemanticPlane/PlaneCanvas.jsx", "sourceCode": "export default function PlaneCanvas({\n  plane,\n  regions = [],\n  entities = [],\n  cultures = [],\n  axisDefinitions = [],\n  selectedEntityId,\n  selectedRegionId,\n  onSelectEntity,\n  onSelectRegion,\n  onMoveEntity,\n  onMoveRegion,\n  onResizeRegion,\n}) {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [size, setSize] = useState({ width: 600, height: 400 });\n  const [camera, setCamera] = useState({ x: 0, y: 0, zoom: 1 });\n  const [interaction, setInteraction] = useState({\n    type: null,\n    startX: 0,\n    startY: 0,\n    startCamera: null,\n  });\n\n  // Track dragged positions locally to avoid expensive React state updates during drag\n  const dragPositionRef = useRef(null);\n  const [renderTrigger, setRenderTrigger] = useState(0); // Force canvas redraw without parent re-render\n\n  // Resize observer to fill container\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const observer = new ResizeObserver((entries) => {\n      const { width, height } = entries[0].contentRect;\n      setSize({ width: Math.floor(width), height: Math.floor(height) });\n    });\n\n    observer.observe(container);\n    return () => observer.disconnect();\n  }, []);\n\n  // Calculate the drawable area (inside padding)\n  const drawArea = useMemo(() => ({\n    left: PADDING,\n    top: PADDING,\n    width: size.width - PADDING * 2,\n    height: size.height - PADDING * 2,\n  }), [size.width, size.height]);\n\n  // Base scale to fit world in draw area (maintaining aspect ratio)\n  const baseScale = Math.min(drawArea.width / WORLD_SIZE, drawArea.height / WORLD_SIZE);\n\n  // Convert world coordinates (0-100) to canvas pixel coordinates\n  const worldToCanvas = useCallback(\n    (wx, wy) => {\n      const scale = baseScale * camera.zoom;\n      // Center the world in the draw area\n      const worldPixelSize = WORLD_SIZE * scale;\n      const offsetX = drawArea.left + (drawArea.width - worldPixelSize) / 2;\n      const offsetY = drawArea.top + (drawArea.height - worldPixelSize) / 2;\n\n      return {\n        x: offsetX + (wx - WORLD_MIN) * scale + camera.x,\n        // Flip Y so 0 is at bottom\n        y: offsetY + (WORLD_MAX - wy) * scale + camera.y,\n      };\n    },\n    [baseScale, camera, drawArea]\n  );\n\n  // Convert canvas pixel coordinates to world coordinates\n  const canvasToWorld = useCallback(\n    (cx, cy) => {\n      const scale = baseScale * camera.zoom;\n      const worldPixelSize = WORLD_SIZE * scale;\n      const offsetX = drawArea.left + (drawArea.width - worldPixelSize) / 2;\n      const offsetY = drawArea.top + (drawArea.height - worldPixelSize) / 2;\n\n      return {\n        x: (cx - camera.x - offsetX) / scale + WORLD_MIN,\n        // Flip Y so 0 is at bottom\n        y: WORLD_MAX - (cy - camera.y - offsetY) / scale,\n      };\n    },\n    [baseScale, camera, drawArea]\n  );\n\n  // Draw the canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    const { width, height } = size;\n\n    // Clear\n    ctx.fillStyle = \"#0a0e14\";\n    ctx.fillRect(0, 0, width, height);\n\n    const scale = baseScale * camera.zoom;\n\n    // Get world corners in canvas space\n    const topLeft = worldToCanvas(WORLD_MIN, WORLD_MAX);\n    const bottomRight = worldToCanvas(WORLD_MAX, WORLD_MIN);\n    const worldWidth = bottomRight.x - topLeft.x;\n    const worldHeight = bottomRight.y - topLeft.y;\n\n    // Draw world background\n    ctx.fillStyle = \"#0d1117\";\n    ctx.fillRect(topLeft.x, topLeft.y, worldWidth, worldHeight);\n\n    // Draw grid\n    ctx.strokeStyle = \"#1a2332\";\n    ctx.lineWidth = 1;\n    const gridStep = 10;\n\n    for (let x = WORLD_MIN; x <= WORLD_MAX; x += gridStep) {\n      const { x: cx } = worldToCanvas(x, 0);\n      ctx.beginPath();\n      ctx.moveTo(cx, topLeft.y);\n      ctx.lineTo(cx, bottomRight.y);\n      ctx.stroke();\n    }\n    for (let y = WORLD_MIN; y <= WORLD_MAX; y += gridStep) {\n      const { y: cy } = worldToCanvas(0, y);\n      ctx.beginPath();\n      ctx.moveTo(topLeft.x, cy);\n      ctx.lineTo(bottomRight.x, cy);\n      ctx.stroke();\n    }\n\n    // Draw center crosshair\n    ctx.strokeStyle = \"#2a3a4a\";\n    ctx.lineWidth = 1;\n    const center = worldToCanvas(50, 50);\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, center.y);\n    ctx.lineTo(bottomRight.x, center.y);\n    ctx.moveTo(center.x, topLeft.y);\n    ctx.lineTo(center.x, bottomRight.y);\n    ctx.stroke();\n\n    // Draw world border\n    ctx.strokeStyle = \"#3a4a5a\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(topLeft.x, topLeft.y, worldWidth, worldHeight);\n\n    // Draw regions\n    regions.forEach((region) => {\n      drawPlaneRegion(ctx, region, selectedRegionId, dragPositionRef, worldToCanvas, scale);\n    });\n\n    // Draw entities\n    entities.forEach((entity) => {\n      if (!entity.coordinates) return;\n\n      // Check for drag override position\n      const drag = dragPositionRef.current;\n      let coordX = entity.coordinates.x;\n      let coordY = entity.coordinates.y;\n\n      if (drag && drag.type === \"entity\" && drag.id === entity.id) {\n        coordX = drag.position.x;\n        coordY = drag.position.y;\n      }\n\n      const { x: cx, y: cy } = worldToCanvas(coordX, coordY);\n      const culture = cultures.find((c) => c.id === entity.culture);\n      const color = culture?.color || \"#888\";\n      const isSelected = entity.id === selectedEntityId;\n\n      // Entity dot\n      ctx.beginPath();\n      ctx.arc(cx, cy, isSelected ? 10 : 7, 0, Math.PI * 2);\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      if (isSelected) {\n        ctx.strokeStyle = \"#fff\";\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n\n      // Entity label\n      ctx.fillStyle = \"#ccc\";\n      ctx.font = \"10px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(entity.name || entity.id, cx, cy - 12);\n    });\n\n    // Draw axis labels on the edges\n    const axes = plane?.axes || {};\n    const axisById = new Map((axisDefinitions || []).map((axis) => [axis.id, axis]));\n    const resolveAxis = (axisRef) => (axisRef?.axisId ? axisById.get(axisRef.axisId) : undefined);\n\n    ctx.fillStyle = \"#666\";\n    ctx.font = \"11px sans-serif\";\n\n    // X axis labels\n    if (axes.x) {\n      const axisRef = axes.x;\n      const axisDef = resolveAxis(axisRef);\n      const axisName = axisDef?.name || axisRef.axisId || \"X Axis\";\n      const lowLabel = axisDef?.lowTag || \"0\";\n      const highLabel = axisDef?.highTag || \"100\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(lowLabel, topLeft.x, bottomRight.y + 16);\n      ctx.textAlign = \"right\";\n      ctx.fillText(highLabel, bottomRight.x, bottomRight.y + 16);\n      ctx.textAlign = \"center\";\n      ctx.fillText(axisName, (topLeft.x + bottomRight.x) / 2, bottomRight.y + 28);\n    }\n\n    // Y axis labels\n    if (axes.y) {\n      const axisRef = axes.y;\n      const axisDef = resolveAxis(axisRef);\n      const axisName = axisDef?.name || axisRef.axisId || \"Y Axis\";\n      const lowLabel = axisDef?.lowTag || \"0\";\n      const highLabel = axisDef?.highTag || \"100\";\n      ctx.textAlign = \"right\";\n      ctx.fillText(lowLabel, topLeft.x - 6, bottomRight.y);\n      ctx.fillText(highLabel, topLeft.x - 6, topLeft.y + 4);\n\n      // Rotated Y axis name\n      ctx.save();\n      ctx.translate(topLeft.x - 28, (topLeft.y + bottomRight.y) / 2);\n      ctx.rotate(-Math.PI / 2);\n      ctx.textAlign = \"center\";\n      ctx.fillText(axisName, 0, 0);\n      ctx.restore();\n    }\n  }, [\n    plane,\n    regions,\n    entities,\n    cultures,\n    axisDefinitions,\n    selectedEntityId,\n    selectedRegionId,\n    size,\n    camera,\n    baseScale,\n    worldToCanvas,\n    renderTrigger,\n  ]);\n\n  // Find entity at canvas position\n  const findEntityAt = (cx, cy) => {\n    for (const entity of entities) {\n      if (!entity.coordinates) continue;\n      const { x: ex, y: ey } = worldToCanvas(entity.coordinates.x, entity.coordinates.y);\n      const dist = Math.sqrt((cx - ex) ** 2 + (cy - ey) ** 2);\n      if (dist < 12) return entity;\n    }\n    return null;\n  };\n\n  // Find region at canvas position (checks if click is within region bounds)\n  const findRegionAt = (cx, cy) => {\n    const scale = baseScale * camera.zoom;\n    // Check in reverse order so topmost (last drawn) regions are found first\n    for (let i = regions.length - 1; i >= 0; i--) {\n      const region = regions[i];\n      const bounds = region.bounds;\n      if (!bounds) continue;\n\n      if (bounds.shape === \"circle\" && bounds.center) {\n        const { x: rx, y: ry } = worldToCanvas(bounds.center.x, bounds.center.y);\n        const radius = (bounds.radius || 10) * scale;\n        const dist = Math.sqrt((cx - rx) ** 2 + (cy - ry) ** 2);\n        if (dist < radius) return region;\n      }\n    }\n    return null;\n  };\n\n  // Check if clicking on the edge of the selected region (for resizing)\n  const findRegionEdgeAt = (cx, cy) => {\n    if (!selectedRegionId) return null;\n\n    const region = regions.find((r) => r.id === selectedRegionId);\n    if (!region?.bounds?.center) return null;\n\n    const scale = baseScale * camera.zoom;\n    const { x: rx, y: ry } = worldToCanvas(region.bounds.center.x, region.bounds.center.y);\n    const radius = (region.bounds.radius || 10) * scale;\n\n    // Distance from click to center\n    const distToCenter = Math.sqrt((cx - rx) ** 2 + (cy - ry) ** 2);\n\n    // Check if near the edge (within 8px tolerance of the circle edge)\n    const edgeTolerance = 8;\n    if (Math.abs(distToCenter - radius) < edgeTolerance) {\n      return region;\n    }\n\n    return null;\n// ... (truncated)", "parameters": [{"name": "{\n  plane,\n  regions = [],\n  entities = [],\n  cultures = [],\n  axisDefinitions = [],\n  selectedEntityId,\n  selectedRegionId,\n  onSelectEntity,\n  onSelectRegion,\n  onMoveEntity,\n  onMoveRegion,\n  onResizeRegion,\n}", "type": "{ plane: any; regions?: any[]; entities?: any[]; cultures?: any[]; axisDefinitions?: any[]; selectedEntityId: any; selectedRegionId: any; onSelectEntity: any; onSelectRegion: any; onMoveEntity: any; onMoveRegion: any; onResizeRegion: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useRef", "useState", "useEffect", "useCallback", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./PlaneCanvas.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/generator/GenerateTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/generator/GenerateTab.jsx", "sourceCode": "/**\n * Generate Tab - Full control over name generation\n *\n * Note: Conditions (entityKind, subtype, tags, prominence) are evaluated at the\n * strategy GROUP level within profiles, not at the profile level. The generator\n * filters which strategy groups apply based on the generation context.\n */\nfunction GenerateTab({ worldSchema, cultures, formState, onFormStateChange }) {\n  // Use lifted state if provided, otherwise use local state\n  const [localState, setLocalState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }], // Start with one empty row\n  });\n\n  // Use formState from parent if available\n  const state = formState || localState;\n  const setState = onFormStateChange || setLocalState;\n\n  // Destructure for convenience\n  const {\n    selectedCulture,\n    selectedProfile,\n    selectedKind,\n    selectedSubKind,\n    tags,\n    prominence,\n    count,\n    contextPairs,\n  } = state;\n\n  // Update helpers\n  const updateField = (field, value) => {\n    setState({ ...state, [field]: value });\n  };\n\n  // Results\n  const [generatedNames, setGeneratedNames] = useState([]);\n  const [debugInfo, setDebugInfo] = useState([]);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [generating, setGenerating] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Get available options from schema\n  const cultureIds = Object.keys(cultures || {});\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  // Get profiles for selected culture\n  const availableProfiles = useMemo(() => {\n    if (!selectedCulture) return [];\n    return cultures[selectedCulture]?.naming?.profiles || [];\n  }, [selectedCulture, cultures]);\n\n  // Auto-select first profile when culture changes\n  useMemo(() => {\n    if (availableProfiles.length > 0 && !selectedProfile) {\n      updateField(\"selectedProfile\", availableProfiles[0].id);\n    } else if (availableProfiles.length === 0 && selectedProfile) {\n      updateField(\"selectedProfile\", \"\");\n    }\n  }, [availableProfiles]);\n\n  // Get subkinds for selected entity kind\n  const subKinds = useMemo(() => {\n    if (!selectedKind || !worldSchema?.entityKinds) return [];\n    const entity = worldSchema.entityKinds.find((e) => e.kind === selectedKind);\n    return entity?.subtypes?.map((s) => s.id) || [];\n  }, [selectedKind, worldSchema]);\n\n  // Prominence levels\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  // Get the culture for generation\n  const getSelectedCulture = () => {\n    if (!selectedCulture) return null;\n    return cultures[selectedCulture] || null;\n  };\n\n  // Context pair handlers\n  const handleAddContextPair = () => {\n    updateField(\"contextPairs\", [...contextPairs, { key: \"\", value: \"\" }]);\n  };\n\n  const handleRemoveContextPair = (index) => {\n    const newPairs = contextPairs.filter((_, i) => i !== index);\n    // Always keep at least one row\n    updateField(\"contextPairs\", newPairs.length > 0 ? newPairs : [{ key: \"\", value: \"\" }]);\n  };\n\n  const handleUpdateContextPair = (index, field, value) => {\n    const updated = [...contextPairs];\n    updated[index] = { ...updated[index], [field]: value };\n    updateField(\"contextPairs\", updated);\n  };\n\n  const handleGenerate = async () => {\n    setError(null);\n    setGenerating(true);\n\n    try {\n      const culture = getSelectedCulture();\n\n      if (!culture) {\n        throw new Error(\"No culture selected.\");\n      }\n\n      if (!culture?.naming?.profiles || culture.naming.profiles.length === 0) {\n        throw new Error(\"No profile found. Create a profile in Workshop \u2192 Profiles.\");\n      }\n\n      // Parse tags for condition matching\n      const tagList = Array.isArray(tags) ? tags : [];\n\n      // Build context object from key-value pairs for grammar context:key slots\n      const userContext = {};\n      for (const pair of contextPairs) {\n        if (pair.key) {\n          userContext[pair.key] = pair.value;\n        }\n      }\n\n      // Add standard fields to context as well\n      if (selectedKind) userContext.entityKind = selectedKind;\n      if (selectedSubKind) userContext.subtype = selectedSubKind;\n      if (prominence) userContext.prominence = prominence;\n      if (tagList.length > 0) userContext.tags = tagList.join(\",\");\n\n      // Generate names - pass culture directly\n      const result = await generateTestNames({\n        culture,\n        profileId: selectedProfile || undefined,\n        count,\n        seed: `generate-${Date.now()}`,\n        context: userContext,\n        kind: selectedKind || undefined,\n        subtype: selectedSubKind || undefined,\n        prominence: prominence || undefined,\n        tags: tagList,\n      });\n\n      setGeneratedNames(result.names || []);\n      setDebugInfo(result.debugInfo || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setError(err.message);\n      setGeneratedNames([]);\n      setDebugInfo([]);\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  const handleCopy = () => {\n    navigator.clipboard.writeText(generatedNames.join(\"\\n\"));\n  };\n\n  const handleCopyJson = () => {\n    navigator.clipboard.writeText(JSON.stringify(generatedNames, null, 2));\n  };\n\n  // Check if we can generate\n  const canGenerate = selectedCulture;\n  const culture = canGenerate ? getSelectedCulture() : null;\n  const hasProfile = culture?.naming?.profiles?.length > 0;\n\n  return (\n    <div className=\"generate-container\">\n      <h2>Name Generator</h2>\n      <p className=\"text-muted intro\">\n        Generate names using configured profiles. Strategy groups with conditions will be filtered\n        based on entity type, subtype, tags, and prominence.\n      </p>\n\n      <div className=\"generate-layout\">\n        {/* Left: Controls */}\n        <div className=\"generate-controls\">\n          <div className=\"card mb-md\">\n            <h3 className=\"mt-0 mb-md\">Generation Settings</h3>\n\n            {/* Culture Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"culture\">Culture *</label>\n              <select id=\"culture\"\n                value={selectedCulture}\n                onChange={(e) => {\n                  setState({ ...state, selectedCulture: e.target.value, selectedProfile: \"\" });\n                }}\n              >\n                <option value=\"\">Select a culture...</option>\n                {cultureIds.map((id) => (\n                  <option key={id} value={id}>\n                    {cultures[id]?.name || id}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            {/* Profile Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"profile\">Profile</label>\n              <select id=\"profile\"\n                value={selectedProfile}\n                onChange={(e) => updateField(\"selectedProfile\", e.target.value)}\n                disabled={availableProfiles.length === 0}\n              >\n                {availableProfiles.length === 0 ? (\n                  <option value=\"\">No profiles available</option>\n                ) : (\n                  availableProfiles.map((p) => (\n                    <option key={p.id} value={p.id}>\n                      {p.id}\n                    </option>\n                  ))\n                )}\n              </select>\n            </div>\n\n            <div className=\"generate-section-divider\">\n              <div className=\"generate-section-header\">\n                Context (for conditional strategy groups)\n              </div>\n\n              {/* Entity Kind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"entity-kind\">Entity Kind</label>\n                <select id=\"entity-kind\"\n                  value={selectedKind}\n                  onChange={(e) => {\n                    setState({ ...state, selectedKind: e.target.value, selectedSubKind: \"\" });\n                  }}\n                >\n                  <option value=\"\">Any type</option>\n                  {entityKinds.map((kind) => (\n                    <option key={kind} value={kind}>\n                      {kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* SubKind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"subtype\">Subtype</label>\n                <select id=\"subtype\"\n                  value={selectedSubKind}\n                  onChange={(e) => updateField(\"selectedSubKind\", e.target.value)}\n                  disabled={subKinds.length === 0}\n                >\n                  <option value=\"\">Any subtype</option>\n                  {subKinds.map((sub) => (\n                    <option key={sub} value={sub}>\n                      {sub}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Tags */}\n              <div className=\"form-group\">\n                <label>Tags\n                <TagSelector\n                  value={tags || []}\n                  onChange={(vals) => updateField(\"tags\", vals)}\n                  tagRegistry={tagRegistry}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n\n              {/* Prominence */}\n              <div className=\"form-group\">\n                <label htmlFor=\"prominence\">Prominence</label>\n                <select id=\"prominence\"\n                  value={prominence}\n                  onChange={(e) => updateField(\"prominence\", e.target.value)}\n                >\n                  <option value=\"\">Any prominence</option>\n                  {prominenceLevels.map((level) => (\n                    <option key={level} value={level}>\n                      {level}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            {/* Context Key-Value Pairs */}\n            <div className=\"generate-section-divider\">\n              <div className=\"flex justify-between items-center mb-sm\">\n                <div className=\"generate-section-header mb-0\">\n                  Context Values\n                  <span className=\"hint\">(for context:key slots)</span>\n                </div>\n                <button type=\"button\" onClick={handleAddContextPair} className=\"add-row-btn\">\n// ... (truncated)", "parameters": [{"name": "{ worldSchema, cultures, formState, onFormStateChange }", "type": "{ worldSchema: any; cultures: any; formState: any; onFormStateChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector", "NumberInput"], "category": "external"}, {"source": "../../lib/browser-generator.js", "specifiers": ["generateTestNames"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/modals/ConditionsModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/modals/ConditionsModal.jsx", "sourceCode": "function ConditionsModal({ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }) {\n  const [localConditions, setLocalConditions] = useState(conditions || {});\n\n  useEffect(() => {\n    setLocalConditions(conditions || {});\n  }, [conditions, isOpen]);\n\n  const handleSave = () => {\n    // Clean up empty values\n    const cleaned = {};\n    if (localConditions.tags?.length > 0) cleaned.tags = localConditions.tags;\n    if (localConditions.requireAllTags) cleaned.requireAllTags = true;\n    if (localConditions.prominence?.length > 0) cleaned.prominence = localConditions.prominence;\n    if (localConditions.subtype?.length > 0) cleaned.subtype = localConditions.subtype;\n\n    onChange(Object.keys(cleaned).length > 0 ? cleaned : undefined);\n    onClose();\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <ModalShell onClose={onClose} title=\"Strategy Conditions\" className=\"conditions-modal\">\n      <p className=\"text-muted text-small mt-0\">\n        Define when this strategy should be used. Leave empty for unconditional use.\n      </p>\n\n      {/* Tags */}\n      <div className=\"form-group\">\n        <label>Entity Tags\n        <TagSelector\n          value={localConditions.tags || []}\n          onChange={(tags) =>\n            setLocalConditions({ ...localConditions, tags: tags.length > 0 ? tags : undefined })\n          }\n          tagRegistry={tagRegistry}\n          placeholder=\"Select tags...\"\n          matchAllEnabled={true}\n          matchAll={localConditions.requireAllTags || false}\n          onMatchAllChange={(val) =>\n            setLocalConditions({ ...localConditions, requireAllTags: val || undefined })\n          }\n          onAddToRegistry={onAddTag}\n        />\n        </label>\n        <small className=\"text-muted\">\n          Use tags from the shared registry; toggle match-all when needed.\n        </small>\n      </div>\n\n      {/* Prominence */}\n      <div className=\"form-group\">\n        <span>Prominence Levels</span>\n        <div className=\"flex flex-wrap gap-sm mt-xs\">\n          {PROMINENCE_LEVELS.map((level) => {\n            const isSelected = (localConditions.prominence || []).includes(level);\n            return (\n              <button\n                key={level}\n                type=\"button\"\n                onClick={() => {\n                  const current = localConditions.prominence || [];\n                  const updated = isSelected\n                    ? current.filter((l) => l !== level)\n                    : [...current, level];\n                  setLocalConditions({\n                    ...localConditions,\n                    prominence: updated.length > 0 ? updated : undefined,\n                  });\n                }}\n                className={`pill-button ${isSelected ? \"selected-gold\" : \"\"}`}\n              >\n                {level}\n              </button>\n            );\n          })}\n        </div>\n        <small className=\"text-muted mt-sm block\">\n          Only use this strategy for entities with selected prominence levels\n        </small>\n      </div>\n\n      {/* Subtype */}\n      <div className=\"form-group\">\n        <label htmlFor=\"entity-subtypes\">Entity Subtypes</label>\n        <input id=\"entity-subtypes\"\n          value={(localConditions.subtype || []).join(\", \")}\n          onChange={(e) => {\n            const subtypes = e.target.value\n              .split(\",\")\n              .map((t) => t.trim())\n              .filter((t) => t);\n            setLocalConditions({\n              ...localConditions,\n              subtype: subtypes.length > 0 ? subtypes : undefined,\n            });\n          }}\n          placeholder=\"e.g., merchant, artisan, warrior\"\n        />\n        <small className=\"text-muted\">Comma-separated list of subtypes to match</small>\n      </div>\n\n      {/* Summary */}\n      {(localConditions.tags?.length > 0 ||\n        localConditions.prominence?.length > 0 ||\n        localConditions.subtype?.length > 0) && (\n        <div className=\"conditions-preview\">\n          <strong className=\"text-gold\">Preview:</strong> This strategy will be used when entity has{\" \"}\n          {[\n            localConditions.tags?.length > 0 &&\n              `${localConditions.requireAllTags ? \"ALL\" : \"any\"} tags: ${localConditions.tags.join(\", \")}`,\n            localConditions.prominence?.length > 0 &&\n              `prominence: ${localConditions.prominence.join(\" or \")}`,\n            localConditions.subtype?.length > 0 &&\n              `subtype: ${localConditions.subtype.join(\" or \")}`,\n          ]\n            .filter(Boolean)\n            .join(\" AND \")}\n        </div>\n      )}\n\n      <div className=\"flex gap-md mt-lg justify-end\">\n        <button className=\"secondary\" onClick={onClose}>\n          Cancel\n        </button>\n        <button className=\"primary\" onClick={handleSave}>\n          Save Conditions\n        </button>\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }", "type": "{ isOpen: any; onClose: any; conditions: any; onChange: any; tagRegistry?: any[]; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell", "TagSelector"], "category": "external"}, {"source": "../constants", "specifiers": ["PROMINENCE_LEVELS"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx::computeDomainDiff", "name": "computeDomainDiff", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx", "sourceCode": "/**\n * Compute diff between two domain configs\n * Returns an array of changes with path, old value, and new value\n */\nexport function computeDomainDiff(initial, optimized) {\n  const changes = [];\n\n  if (!initial || !optimized) return changes;\n\n  // Helper to compare arrays\n  const arrayDiff = (path, oldArr, newArr, labels) => {\n    if (!oldArr && !newArr) return;\n    if (!oldArr) {\n      changes.push({ path, type: \"added\", newValue: newArr });\n      return;\n    }\n    if (!newArr) {\n      changes.push({ path, type: \"removed\", oldValue: oldArr });\n      return;\n    }\n\n    // For weight arrays, show significant changes\n    const changedIndices = [];\n    const maxLen = Math.max(oldArr.length, newArr.length);\n    for (let i = 0; i < maxLen; i++) {\n      const oldVal = oldArr[i] ?? 0;\n      const newVal = newArr[i] ?? 0;\n      if (Math.abs(oldVal - newVal) > 0.01) {\n        changedIndices.push({\n          index: i,\n          label: labels?.[i] || `[${i}]`,\n          oldVal: typeof oldVal === \"number\" ? oldVal.toFixed(2) : oldVal,\n          newVal: typeof newVal === \"number\" ? newVal.toFixed(2) : newVal,\n        });\n      }\n    }\n    if (changedIndices.length > 0) {\n      changes.push({ path, type: \"weights\", changes: changedIndices });\n    }\n  };\n\n  // Helper to compare scalars\n  const scalarDiff = (path, oldVal, newVal) => {\n    if (oldVal === newVal) return;\n    if (oldVal === undefined && newVal === undefined) return;\n\n    const oldNum = typeof oldVal === \"number\" ? oldVal : null;\n    const newNum = typeof newVal === \"number\" ? newVal : null;\n\n    if (oldNum !== null && newNum !== null) {\n      if (Math.abs(oldNum - newNum) < 0.001) return;\n    }\n\n    changes.push({\n      path,\n      type: \"scalar\",\n      oldValue: oldVal === undefined ? \"(default)\" : oldVal,\n      newValue: newVal === undefined ? \"(default)\" : newVal,\n    });\n  };\n\n  // Helper to compare string arrays (sets)\n  const setDiff = (path, oldSet, newSet) => {\n    if (!oldSet && !newSet) return;\n    const oldItems = new Set(oldSet || []);\n    const newItems = new Set(newSet || []);\n\n    const added = [...newItems].filter((x) => !oldItems.has(x));\n    const removed = [...oldItems].filter((x) => !newItems.has(x));\n\n    if (added.length > 0 || removed.length > 0) {\n      changes.push({ path, type: \"set\", added, removed });\n    }\n  };\n\n  // Compare phonology\n  const ph = { old: initial.phonology, new: optimized.phonology };\n  arrayDiff(\n    \"phonology.consonantWeights\",\n    ph.old?.consonantWeights,\n    ph.new?.consonantWeights,\n    ph.old?.consonants\n  );\n  arrayDiff(\"phonology.vowelWeights\", ph.old?.vowelWeights, ph.new?.vowelWeights, ph.old?.vowels);\n  arrayDiff(\n    \"phonology.templateWeights\",\n    ph.old?.templateWeights,\n    ph.new?.templateWeights,\n    ph.old?.syllableTemplates\n  );\n  scalarDiff(\n    \"phonology.favoredClusterBoost\",\n    ph.old?.favoredClusterBoost,\n    ph.new?.favoredClusterBoost\n  );\n  setDiff(\"phonology.favoredClusters\", ph.old?.favoredClusters, ph.new?.favoredClusters);\n  setDiff(\"phonology.consonants\", ph.old?.consonants, ph.new?.consonants);\n  setDiff(\"phonology.vowels\", ph.old?.vowels, ph.new?.vowels);\n\n  if (ph.old?.lengthRange && ph.new?.lengthRange) {\n    if (\n      ph.old.lengthRange[0] !== ph.new.lengthRange[0] ||\n      ph.old.lengthRange[1] !== ph.new.lengthRange[1]\n    ) {\n      changes.push({\n        path: \"phonology.lengthRange\",\n        type: \"scalar\",\n        oldValue: `[${ph.old.lengthRange[0]}, ${ph.old.lengthRange[1]}]`,\n        newValue: `[${ph.new.lengthRange[0]}, ${ph.new.lengthRange[1]}]`,\n      });\n    }\n  }\n\n  // Compare morphology\n  const mo = { old: initial.morphology, new: optimized.morphology };\n  arrayDiff(\n    \"morphology.prefixWeights\",\n    mo.old?.prefixWeights,\n    mo.new?.prefixWeights,\n    mo.old?.prefixes\n  );\n  arrayDiff(\n    \"morphology.suffixWeights\",\n    mo.old?.suffixWeights,\n    mo.new?.suffixWeights,\n    mo.old?.suffixes\n  );\n  arrayDiff(\n    \"morphology.structureWeights\",\n    mo.old?.structureWeights,\n    mo.new?.structureWeights,\n    mo.old?.structure\n  );\n\n  // Compare style\n  const st = { old: initial.style || {}, new: optimized.style || {} };\n  scalarDiff(\"style.apostropheRate\", st.old.apostropheRate, st.new.apostropheRate);\n  scalarDiff(\"style.hyphenRate\", st.old.hyphenRate, st.new.hyphenRate);\n  scalarDiff(\"style.targetLength\", st.old.targetLength, st.new.targetLength);\n  scalarDiff(\"style.lengthTolerance\", st.old.lengthTolerance, st.new.lengthTolerance);\n  scalarDiff(\n    \"style.preferredEndingBoost\",\n    st.old.preferredEndingBoost,\n    st.new.preferredEndingBoost\n  );\n  scalarDiff(\"style.capitalization\", st.old.capitalization, st.new.capitalization);\n  scalarDiff(\"style.rhythmBias\", st.old.rhythmBias, st.new.rhythmBias);\n\n  return changes;\n}", "parameters": [{"name": "initial", "type": "any", "optional": false}, {"name": "optimized", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx", "sourceCode": "/**\n * Domain Diff Component - Shows what changed in a collapsible format\n */\nexport default function DomainDiff({ initial, optimized }) {\n  const changes = useMemo(() => computeDomainDiff(initial, optimized), [initial, optimized]);\n\n  if (changes.length === 0) {\n    return <div className=\"text-muted italic p-sm\">No changes detected</div>;\n  }\n\n  return (\n    <div className=\"text-small\">\n      {changes.map((change, i) => (\n        <div key={i} className={`diff-row ${i % 2 === 0 ? \"alt\" : \"\"}`}>\n          <div className=\"diff-path\">{change.path}</div>\n\n          {change.type === \"scalar\" && (\n            <div className=\"flex align-center gap-sm\">\n              <span className=\"diff-old\">{String(change.oldValue)}</span>\n              <span className=\"text-muted\">\u2192</span>\n              <span className=\"diff-new\">{String(change.newValue)}</span>\n            </div>\n          )}\n\n          {change.type === \"set\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.removed.map((item, j) => (\n                <span key={`r${j}`} className=\"diff-tag removed\">\n                  -{item}\n                </span>\n              ))}\n              {change.added.map((item, j) => (\n                <span key={`a${j}`} className=\"diff-tag added\">\n                  +{item}\n                </span>\n              ))}\n            </div>\n          )}\n\n          {change.type === \"weights\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.changes.slice(0, 8).map((c, j) => (\n                <span key={j} className=\"diff-weight\">\n                  <strong className=\"text-gold\">{c.label}</strong>: {c.oldVal}\u2192{c.newVal}\n                </span>\n              ))}\n              {change.changes.length > 8 && (\n                <span className=\"text-muted text-small\">+{change.changes.length - 8} more</span>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ initial, optimized }", "type": "{ initial: any; optimized: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainSelector.jsx", "sourceCode": "/**\n * DomainSelector - Left panel for selecting domains to optimize\n */\nexport default function DomainSelector({\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}) {\n  return (\n    <div className=\"optimizer-sidebar\">\n      <div className=\"optimizer-sidebar-header\">\n        <h3 className=\"mt-0 mb-sm text-small\">Select Domains</h3>\n        <div className=\"flex gap-sm\">\n          <button onClick={onSelectAll} className=\"secondary btn-xs\">\n            Select All\n          </button>\n          <button onClick={onDeselectAll} className=\"secondary btn-xs\">\n            Clear\n          </button>\n        </div>\n        <div className=\"mt-sm text-small text-muted\">\n          {selectedDomains.size} of {allDomains.length} selected\n        </div>\n      </div>\n\n      <div className=\"optimizer-sidebar-list\">\n        {Object.entries(domainsByCulture).map(([cultureId, { name, domains }]) => {\n          const isExpanded = expandedCultures.has(cultureId);\n          const allSelected = domains.every((d) => selectedDomains.has(d.id));\n          const someSelected = domains.some((d) => selectedDomains.has(d.id));\n\n          return (\n            <div key={cultureId} className=\"mb-sm\">\n              <div className=\"culture-row\">\n                <input\n                  type=\"checkbox\"\n                  checked={allSelected}\n                  ref={(el) => {\n                    if (el) el.indeterminate = someSelected && !allSelected;\n                  }}\n                  onChange={() => onToggleAllInCulture(cultureId)}\n                  onClick={(e) => e.stopPropagation()}\n                  className=\"accent-ice\"\n                />\n                <span onClick={() => onToggleCulture(cultureId)} className=\"culture-row-label\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  {isExpanded ? \"\u25bc\" : \"\u25b6\"} {name || cultureId}\n                  <span className=\"text-muted font-normal ml-sm\">({domains.length})</span>\n                </span>\n              </div>\n\n              {isExpanded && (\n                <div className=\"domain-list\">\n                  {domains.map((domain) => (\n                    <div\n                      key={domain.id}\n                      className={`domain-row ${selectedDomains.has(domain.id) ? \"selected\" : \"\"}`}\n                      onClick={() => onToggleDomain(domain.id)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedDomains.has(domain.id)}\n                        onChange={() => onToggleDomain(domain.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        className=\"accent-gold\"\n                      />\n                      <span>{domain.id}</span>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          );\n        })}\n\n        {allDomains.length === 0 && (\n          <div className=\"empty-message\">\n            No domains found. Create domains in the Workshop tab first.\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}", "type": "{ domainsByCulture: any; allDomains: any; selectedDomains: any; expandedCultures: any; onToggleDomain: any; onToggleCulture: any; onToggleAllInCulture: any; onSelectAll: any; onDeselectAll: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::computeDomainDiff", "name": "computeDomainDiff", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Compute diff between two domain configs\n * Returns an array of changes with path, old value, and new value\n */\nexport function computeDomainDiff(initial, optimized) {\n  const changes = [];\n\n  if (!initial || !optimized) return changes;\n\n  // Helper to compare arrays\n  const arrayDiff = (path, oldArr, newArr, labels) => {\n    if (!oldArr && !newArr) return;\n    if (!oldArr) {\n      changes.push({ path, type: \"added\", newValue: newArr });\n      return;\n    }\n    if (!newArr) {\n      changes.push({ path, type: \"removed\", oldValue: oldArr });\n      return;\n    }\n\n    // For weight arrays, show significant changes\n    const changedIndices = [];\n    const maxLen = Math.max(oldArr.length, newArr.length);\n    for (let i = 0; i < maxLen; i++) {\n      const oldVal = oldArr[i] ?? 0;\n      const newVal = newArr[i] ?? 0;\n      if (Math.abs(oldVal - newVal) > 0.01) {\n        changedIndices.push({\n          index: i,\n          label: labels?.[i] || `[${i}]`,\n          oldVal: typeof oldVal === \"number\" ? oldVal.toFixed(2) : oldVal,\n          newVal: typeof newVal === \"number\" ? newVal.toFixed(2) : newVal,\n        });\n      }\n    }\n    if (changedIndices.length > 0) {\n      changes.push({ path, type: \"weights\", changes: changedIndices });\n    }\n  };\n\n  // Helper to compare scalars\n  const scalarDiff = (path, oldVal, newVal) => {\n    if (oldVal === newVal) return;\n    if (oldVal === undefined && newVal === undefined) return;\n\n    const oldNum = typeof oldVal === \"number\" ? oldVal : null;\n    const newNum = typeof newVal === \"number\" ? newVal : null;\n\n    if (oldNum !== null && newNum !== null) {\n      if (Math.abs(oldNum - newNum) < 0.001) return;\n    }\n\n    changes.push({\n      path,\n      type: \"scalar\",\n      oldValue: oldVal === undefined ? \"(default)\" : oldVal,\n      newValue: newVal === undefined ? \"(default)\" : newVal,\n    });\n  };\n\n  // Helper to compare string arrays (sets)\n  const setDiff = (path, oldSet, newSet) => {\n    if (!oldSet && !newSet) return;\n    const oldItems = new Set(oldSet || []);\n    const newItems = new Set(newSet || []);\n\n    const added = [...newItems].filter((x) => !oldItems.has(x));\n    const removed = [...oldItems].filter((x) => !newItems.has(x));\n\n    if (added.length > 0 || removed.length > 0) {\n      changes.push({ path, type: \"set\", added, removed });\n    }\n  };\n\n  // Compare phonology\n  const ph = { old: initial.phonology, new: optimized.phonology };\n  arrayDiff(\n    \"phonology.consonantWeights\",\n    ph.old?.consonantWeights,\n    ph.new?.consonantWeights,\n    ph.old?.consonants\n  );\n  arrayDiff(\"phonology.vowelWeights\", ph.old?.vowelWeights, ph.new?.vowelWeights, ph.old?.vowels);\n  arrayDiff(\n    \"phonology.templateWeights\",\n    ph.old?.templateWeights,\n    ph.new?.templateWeights,\n    ph.old?.syllableTemplates\n  );\n  scalarDiff(\n    \"phonology.favoredClusterBoost\",\n    ph.old?.favoredClusterBoost,\n    ph.new?.favoredClusterBoost\n  );\n  setDiff(\"phonology.favoredClusters\", ph.old?.favoredClusters, ph.new?.favoredClusters);\n  setDiff(\"phonology.consonants\", ph.old?.consonants, ph.new?.consonants);\n  setDiff(\"phonology.vowels\", ph.old?.vowels, ph.new?.vowels);\n\n  if (ph.old?.lengthRange && ph.new?.lengthRange) {\n    if (\n      ph.old.lengthRange[0] !== ph.new.lengthRange[0] ||\n      ph.old.lengthRange[1] !== ph.new.lengthRange[1]\n    ) {\n      changes.push({\n        path: \"phonology.lengthRange\",\n        type: \"scalar\",\n        oldValue: `[${ph.old.lengthRange[0]}, ${ph.old.lengthRange[1]}]`,\n        newValue: `[${ph.new.lengthRange[0]}, ${ph.new.lengthRange[1]}]`,\n      });\n    }\n  }\n\n  // Compare morphology\n  const mo = { old: initial.morphology, new: optimized.morphology };\n  arrayDiff(\n    \"morphology.prefixWeights\",\n    mo.old?.prefixWeights,\n    mo.new?.prefixWeights,\n    mo.old?.prefixes\n  );\n  arrayDiff(\n    \"morphology.suffixWeights\",\n    mo.old?.suffixWeights,\n    mo.new?.suffixWeights,\n    mo.old?.suffixes\n  );\n  arrayDiff(\n    \"morphology.structureWeights\",\n    mo.old?.structureWeights,\n    mo.new?.structureWeights,\n    mo.old?.structure\n  );\n\n  // Compare style\n  const st = { old: initial.style || {}, new: optimized.style || {} };\n  scalarDiff(\"style.apostropheRate\", st.old.apostropheRate, st.new.apostropheRate);\n  scalarDiff(\"style.hyphenRate\", st.old.hyphenRate, st.new.hyphenRate);\n  scalarDiff(\"style.targetLength\", st.old.targetLength, st.new.targetLength);\n  scalarDiff(\"style.lengthTolerance\", st.old.lengthTolerance, st.new.lengthTolerance);\n  scalarDiff(\n    \"style.preferredEndingBoost\",\n    st.old.preferredEndingBoost,\n    st.new.preferredEndingBoost\n  );\n  scalarDiff(\"style.capitalization\", st.old.capitalization, st.new.capitalization);\n  scalarDiff(\"style.rhythmBias\", st.old.rhythmBias, st.new.rhythmBias);\n\n  return changes;\n}", "parameters": [{"name": "initial", "type": "any", "optional": false}, {"name": "optimized", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/OptimizerSettings.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/OptimizerSettings.jsx", "sourceCode": "/**\n * OptimizerSettings - Right panel for algorithm settings and optimization controls\n */\nexport default function OptimizerSettings({\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}) {\n  const handleAlgorithmParamChange = (key, defaultValue) => (v) => {\n    onAlgorithmParamsChange((prev) => ({ ...prev, [key]: v ?? defaultValue }));\n  };\n\n  // Render algorithm parameter inputs\n  const renderAlgorithmParams = () => {\n    const config = ALGORITHMS[algorithm];\n    if (!config?.params || Object.keys(config.params).length === 0) {\n      return (\n        <p className=\"text-muted text-small italic\">No additional parameters for this algorithm.</p>\n      );\n    }\n\n    return (\n      <div className=\"optimizer-param-grid\">\n        {Object.entries(config.params).map(([key, param]) => (\n          <div key={key} className=\"flex flex-col gap-xs\">\n            <label className=\"text-small\">{param.label}\n            <NumberInput\n              value={algorithmParams[key] ?? param.default}\n              onChange={handleAlgorithmParamChange(key, param.default)}\n              min={param.min}\n              max={param.max}\n              step={param.step || 1}\n              className=\"optimizer-input\"\n            />\n            </label>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"optimizer-main\">\n      {/* Settings */}\n      <div className=\"optimizer-settings-area\">\n        <h2 className=\"mt-0 mb-md\">Optimizer Settings</h2>\n\n        {/* Algorithm Selection */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm</h3>\n          <div className=\"algorithm-grid\">\n            {Object.entries(ALGORITHMS).map(([key, config]) => (\n              <div\n                key={key}\n                onClick={() => onAlgorithmChange(key)}\n                className={`algorithm-card ${algorithm === key ? \"selected\" : \"\"}`}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className={`algorithm-name ${algorithm === key ? \"selected\" : \"\"}`}>\n                  {config.name}\n                </div>\n                <div className=\"algorithm-desc\">{config.description}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Algorithm-Specific Parameters */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm Parameters</h3>\n          {renderAlgorithmParams()}\n        </div>\n\n        {/* Validation Settings */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Validation Settings</h3>\n          <div className=\"optimizer-param-grid-small\">\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Size\n              <NumberInput\n                value={validationSettings.requiredNames}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, requiredNames: v ?? 500 }))\n                }\n                min={100}\n                max={5000}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Factor\n              <NumberInput\n                value={validationSettings.sampleFactor}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, sampleFactor: v ?? 10 }))\n                }\n                min={1}\n                max={50}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        {/* Fitness Weights */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Fitness Weights</h3>\n          <div className=\"fitness-grid\">\n            {[\n              { key: \"capacity\", label: \"Capacity\", title: \"Entropy / collision rate\" },\n              { key: \"diffuseness\", label: \"Diffuseness\", title: \"Intra-domain variation\" },\n              { key: \"separation\", label: \"Separation\", title: \"Inter-domain distinctiveness\" },\n              { key: \"pronounceability\", label: \"Pronounce\", title: \"Phonetic naturalness\" },\n              { key: \"length\", label: \"Length\", title: \"Target length adherence\" },\n              { key: \"style\", label: \"Style\", title: \"LLM style judge (optional)\" },\n            ].map(({ key, label, title }) => (\n              <div key={key} className=\"flex flex-col gap-xs\">\n                <label className=\"text-small\" title={title}>\n                  {label}\n                </label>\n                <NumberInput\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  value={fitnessWeights[key]}\n                  onChange={(v) => onFitnessWeightsChange((prev) => ({ ...prev, [key]: v ?? 0 }))}\n                  title={title}\n                  disabled={key === \"separation\" && allDomains.length <= 1}\n                  className={`optimizer-input ${key === \"separation\" && allDomains.length <= 1 ? \"disabled\" : \"\"}`}\n                />\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Run Button */}\n        <div className=\"flex gap-md align-center flex-wrap\">\n          <button\n            onClick={onOptimize}\n            disabled={optimizing || selectedDomains.size === 0}\n            className={`optimize-button ${optimizing || selectedDomains.size === 0 ? \"disabled\" : \"\"}`}\n          >\n            {optimizing ? \"Optimizing...\" : `Optimize ${selectedDomains.size} Domain(s)`}\n          </button>\n\n          {results.length > 0 && results.some((r) => r.success) && (\n            <button onClick={onSaveResults} className=\"secondary optimize-action-button\">\n              Save Results\n            </button>\n          )}\n\n          {optimizing && (\n            <span className=\"text-small text-muted\">\n              {progress.current}/{progress.total}: {progress.currentDomain}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Status Bar - Shows when there are results */}\n      {results.length > 0 && !optimizing && (\n        <div className=\"optimizer-status-bar\">\n          <div className=\"flex align-center gap-md\">\n            <span className=\"text-small\">\n              Last run:{\" \"}\n              <strong className=\"text-success\">{results.filter((r) => r.success).length}</strong>{\" \"}\n              succeeded,{\" \"}\n              <strong className={results.some((r) => !r.success) ? \"text-danger\" : \"\"}>\n                {results.filter((r) => !r.success).length}\n              </strong>{\" \"}\n              failed\n            </span>\n            {results.filter((r) => r.success).length > 0 && (\n              <span className=\"text-gold font-bold text-small\">\n                Avg improvement: +\n                {(\n                  (results\n                    .filter((r) => r.success)\n                    .reduce((sum, r) => sum + (r.improvement || 0), 0) /\n                    results.filter((r) => r.success).length) *\n                  100\n                ).toFixed(1)}\n                %\n              </span>\n            )}\n          </div>\n          <button onClick={onShowModal} className=\"secondary text-small\">\n            View Details\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}", "type": "{ algorithm: any; onAlgorithmChange: any; algorithmParams: any; onAlgorithmParamsChange: any; validationSettings: any; onValidationSettingsChange: any; fitnessWeights: any; onFitnessWeightsChange: any; selectedDomains: any; allDomains: any; optimizing: any; progress: any; results: any; onOptimize: any; onSaveResults: any; onShowModal: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["NumberInput"], "category": "external"}, {"source": "./constants", "specifiers": ["ALGORITHMS"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/OptimizerWorkshop.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/OptimizerWorkshop.jsx", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../lib/browser-optimizer.js", "specifiers": ["optimizeDomain as runOptimizer"], "category": "internal"}, {"source": "./constants", "specifiers": ["ALGORITHMS"], "category": "internal"}, {"source": "./DomainSelector", "specifiers": ["DomainSelector"], "category": "internal"}, {"source": "./OptimizerSettings", "specifiers": ["OptimizerSettings"], "category": "internal"}, {"source": "./ResultsModal", "specifiers": ["ResultsModal"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/optimizer/ResultsModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/ResultsModal.jsx", "sourceCode": "/**\n * ResultsModal - Modal showing optimization progress and results\n */\nexport default function ResultsModal({\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}) {\n  const [expandedResults, setExpandedResults] = useState(new Set());\n  const toggleExpand = domainId => {\n    setExpandedResults(prev => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n  if (!show) return null;\n  return <div className=\"optimizer-modal-overlay\" onClick={e => {\n    if (e.target === e.currentTarget && !optimizing) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"optimizer-modal\">\n        {/* Modal Header */}\n        <div className=\"optimizer-modal-header\">\n          <h2 className=\"mt-0 mb-0\">\n            {optimizing ? \"Optimization in Progress...\" : \"Optimization Results\"}\n          </h2>\n          {!optimizing && <button onClick={onClose} className=\"modal-close-btn\">\n              \u00d7\n            </button>}\n        </div>\n\n        {/* Progress Bar (during optimization) */}\n        {optimizing && <div className=\"optimizer-progress-section\">\n            <div className=\"flex justify-between mb-sm\">\n              <span className=\"text-small\">\n                Processing: <strong>{progress.currentDomain}</strong>\n              </span>\n              <span className=\"text-small text-muted\">\n                {progress.current} / {progress.total}\n              </span>\n            </div>\n            <div className=\"progress-bar-track\">\n              <div className=\"progress-bar-fill rm-progress-bar-fill\" style={{\n            '--rm-progress-width': `${progress.total > 0 ? progress.current / progress.total * 100 : 0}%`\n          }} />\n            </div>\n          </div>}\n\n        {/* Modal Body - Log and Results */}\n        <div className=\"optimizer-modal-body\">\n          {/* Log Section */}\n          <div className=\"optimizer-log-section\">\n            <h3 className=\"section-title mt-0\">Optimization Log</h3>\n            <div className=\"optimizer-log\">\n              {logs.map((log, i) => <div key={i} className={`log-entry ${log.type}`}>\n                  {log.message}\n                </div>)}\n              {logs.length === 0 && <div className=\"text-muted italic\">Waiting for optimization to start...</div>}\n            </div>\n\n            {/* Results Table */}\n            {results.length > 0 && <div className=\"mt-lg\">\n                <h3 className=\"section-title mt-0\">Results Summary</h3>\n                <div className=\"results-table-container\">\n                  <table className=\"results-table\">\n                    <thead>\n                      <tr>\n                        <th className=\"col-expand\"></th>\n                        <th>Domain</th>\n                        <th className=\"text-right\">Initial</th>\n                        <th className=\"text-right\">Final</th>\n                        <th className=\"text-right\">Improvement</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {results.map((result, i) => <ResultRow key={result.domainId} result={result} index={i} isExpanded={expandedResults.has(result.domainId)} onToggle={toggleExpand} />)}\n                    </tbody>\n                  </table>\n                </div>\n              </div>}\n          </div>\n        </div>\n\n        {/* Modal Footer */}\n        <div className=\"optimizer-modal-footer\">\n          {results.length > 0 && results.some(r => r.success) && !optimizing && <button onClick={onSaveResults} className=\"optimize-button\">\n              Save Results\n            </button>}\n          <button onClick={onClose} disabled={optimizing} className={`secondary optimize-action-button ${optimizing ? \"disabled\" : \"\"}`}>\n            {optimizing ? \"Running...\" : \"Close\"}\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}", "type": "{ show: any; onClose: any; optimizing: any; progress: any; logs: any; results: any; onSaveResults: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./DomainDiff", "specifiers": ["DomainDiff"], "category": "internal"}, {"source": "./ResultsModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/sidebar/CultureSidebar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/sidebar/CultureSidebar.jsx", "sourceCode": "function CultureSidebar({\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}) {\n  const [creatingCulture, setCreatingCulture] = useState(false);\n  const [newCultureId, setNewCultureId] = useState(\"\");\n  const [newCultureName, setNewCultureName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const handleCreateCulture = () => {\n    if (!newCultureId.trim()) {\n      setError(\"Culture ID is required\");\n      return;\n    }\n    if (!/^[a-z0-9_]+$/.test(newCultureId)) {\n      setError(\"Culture ID must be lowercase letters, numbers, and underscores only (no hyphens)\");\n      return;\n    }\n    if (cultures[newCultureId]) {\n      setError(\"Culture ID already exists\");\n      return;\n    }\n    const cultureName = newCultureName || newCultureId;\n\n    // Create new culture with culture-level resources\n    const newCulture = {\n      id: newCultureId,\n      name: cultureName,\n      naming: {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: []\n      }\n    };\n    const updatedCultures = {\n      ...cultures,\n      [newCultureId]: newCulture\n    };\n    onCulturesChange(updatedCultures);\n\n    // Select the new culture\n    onSelectCulture(newCultureId);\n\n    // Reset form\n    setNewCultureId(\"\");\n    setNewCultureName(\"\");\n    setCreatingCulture(false);\n    setError(null);\n  };\n\n  // Get resource counts for a culture\n  const getResourceCounts = culture => {\n    const naming = culture?.naming || {};\n    return {\n      domains: naming.domains?.length || 0,\n      lexemes: Object.keys(naming.lexemeLists || {}).length,\n      grammars: naming.grammars?.length || 0,\n      profiles: naming.profiles?.length || 0\n    };\n  };\n\n  // Calculate completion based on having at least one of each resource\n  const calculateCompletion = culture => {\n    const counts = getResourceCounts(culture);\n    let completed = 0;\n    if (counts.domains > 0) completed++;\n    if (counts.lexemes > 0) completed++;\n    if (counts.grammars > 0) completed++;\n    if (counts.profiles > 0) completed++;\n    return Math.round(completed / 4 * 100);\n  };\n  return <div className=\"culture-sidebar\">\n      <div className=\"culture-sidebar-header\">\n        <div className=\"culture-sidebar-header-row\">\n          <h4>Cultures</h4>\n          {!readOnly && !creatingCulture && <button className=\"primary sm\" onClick={() => setCreatingCulture(true)}>\n              + New\n            </button>}\n        </div>\n\n        {creatingCulture && <div className=\"culture-form\">\n            <div className=\"form-group\">\n              <label htmlFor=\"culture-id\">Culture ID</label>\n              <input id=\"culture-id\" type=\"text\" value={newCultureId} onChange={e => setNewCultureId(e.target.value)} placeholder=\"elven\" />\n            </div>\n            <div className=\"form-group\">\n              <label htmlFor=\"display-name\">Display Name</label>\n              <input id=\"display-name\" type=\"text\" value={newCultureName} onChange={e => setNewCultureName(e.target.value)} placeholder=\"Elven\" />\n            </div>\n\n            {error && <div className=\"error\">{error}</div>}\n\n            <div className=\"culture-form-buttons\">\n              <button className=\"primary\" onClick={handleCreateCulture}>\n                Create\n              </button>\n              <button className=\"secondary\" onClick={() => {\n            setCreatingCulture(false);\n            setError(null);\n            setNewCultureId(\"\");\n            setNewCultureName(\"\");\n          }}>\n                Cancel\n              </button>\n            </div>\n          </div>}\n      </div>\n\n      <div className=\"culture-list\">\n        {Object.keys(cultures).length === 0 ? <div className=\"culture-list-empty\">No cultures yet. Create one to get started.</div> : Object.values(cultures).map(culture => {\n        const completion = calculateCompletion(culture);\n        const counts = getResourceCounts(culture);\n        const isSelected = selectedCulture === culture.id;\n        return <div key={culture.id} onClick={() => onSelectCulture(culture.id)} className={`culture-card ${isSelected ? \"selected\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n                <div className=\"culture-card-content\">\n                  <div className=\"culture-card-name\">{culture.name || culture.id}</div>\n\n                  {/* Resource counts */}\n                  <div className=\"culture-resource-grid\">\n                    <span className={`culture-resource-item ${counts.domains > 0 ? \"has-domains\" : \"\"}`}>\n                      {counts.domains} dom\n                    </span>\n                    <span className={`culture-resource-item ${counts.lexemes > 0 ? \"has-lexemes\" : \"\"}`}>\n                      {counts.lexemes} lex\n                    </span>\n                    <span className={`culture-resource-item ${counts.grammars > 0 ? \"has-grammars\" : \"\"}`}>\n                      {counts.grammars} gram\n                    </span>\n                    <span className={`culture-resource-item ${counts.profiles > 0 ? \"has-profiles\" : \"\"}`}>\n                      {counts.profiles} prof\n                    </span>\n                  </div>\n\n                  {/* Progress bar */}\n                  <div className=\"culture-progress-bar\">\n                    <div className={`culture-progress-fill csb-progress-fill ${completion === 100 ? \"complete\" : \"\"}`} style={{\n                '--csb-progress-width': `${completion}%`\n              }} />\n                  </div>\n                </div>\n              </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}", "type": "{ cultures: any; selectedCulture: any; onSelectCulture: any; onCulturesChange: any; readOnly?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CultureSidebar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/EntityWorkspace.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/EntityWorkspace.jsx", "sourceCode": "function EntityWorkspace({\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}) {\n  const [error, setError] = useState(null);\n\n  // Use prop or fallback to local handling\n  const setActiveTab = onTabChange || (() => {});\n\n  if (!cultureId) {\n    return (\n      <div className=\"workspace-empty\">\n        <p className=\"text-muted\">Select a culture from the sidebar to begin</p>\n      </div>\n    );\n  }\n\n  // Handle domains change at culture level\n  const handleDomainsChange = (newDomains) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          domains: newDomains,\n        },\n      });\n    }\n  };\n\n  // Handle lexemes change at culture level\n  // Optional third param allows atomic update with grammars (for copy operations)\n  const handleLexemesChange = (newLexemeLists, newLexemeSpecs, newGrammars) => {\n    if (onCultureChange) {\n      const updates = {\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n        },\n      };\n      if (newLexemeLists !== undefined) updates.naming.lexemeLists = newLexemeLists;\n      if (newLexemeSpecs !== undefined) updates.naming.lexemeSpecs = newLexemeSpecs;\n      if (newGrammars !== undefined) updates.naming.grammars = newGrammars;\n      onCultureChange(updates);\n    }\n  };\n\n  // Handle grammars change at culture level\n  const handleGrammarsChange = (newGrammars) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          grammars: newGrammars,\n        },\n      });\n    }\n  };\n\n  // Handle profiles change at culture level\n  const handleProfilesChange = (newProfiles) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          profiles: newProfiles,\n        },\n      });\n    }\n  };\n\n  const getCompletionBadge = (key) => {\n    const naming = cultureConfig?.naming || {};\n    // Compute counts from culture-level data\n    if (key === \"domain\") {\n      const count = naming.domains?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"lexemes\") {\n      const count = Object.keys(naming.lexemeLists || {}).length;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"grammars\") {\n      const count = naming.grammars?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"profiles\") {\n      const count = naming.profiles?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className=\"workspace\">\n      {/* Header */}\n      <div className=\"workspace-header\">\n        <div className=\"workspace-header-row\">\n          <div>\n            <h3 className=\"workspace-title\">\n              <span className=\"workspace-title-name\">{cultureConfig?.name || cultureId}</span>\n              <span className=\"workspace-title-label\">Culture</span>\n            </h3>\n          </div>\n          <div className=\"workspace-autosave\">Auto-saved</div>\n        </div>\n\n        {error && (\n          <div className=\"error mt-sm\">\n            {error}\n            <button className=\"secondary ml-sm\" onClick={() => setError(null)}>\n              Dismiss\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"workspace-tabs\">\n        {[\"domain\", \"lexemes\", \"grammars\", \"profiles\"].map((tab) => (\n          <button\n            key={tab}\n            onClick={() => setActiveTab(tab)}\n            className={`workspace-tab ${activeTab === tab ? \"active\" : \"\"}`}\n          >\n            {tab} {getCompletionBadge(tab)}\n          </button>\n        ))}\n      </div>\n\n      {/* Content */}\n      <div className=\"workspace-content\">\n        {activeTab === \"domain\" && (\n          <DomainTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onDomainsChange={handleDomainsChange}\n          />\n        )}\n\n        {activeTab === \"lexemes\" && (\n          <LexemesTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onLexemesChange={handleLexemesChange}\n            apiKey={apiKey}\n          />\n        )}\n\n        {activeTab === \"grammars\" && (\n          <GrammarsTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onGrammarsChange={handleGrammarsChange}\n            onLexemesChange={handleLexemesChange}\n          />\n        )}\n\n        {activeTab === \"profiles\" && (\n          <ProfileTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            onProfilesChange={handleProfilesChange}\n            worldSchema={worldSchema}\n            onAddTag={onAddTag}\n            generators={generators}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}", "type": "{ worldSchema: any; cultureId: any; cultureConfig: any; allCultures: any; activeTab?: string; onTabChange: any; onCultureChange: any; onAddTag: any; apiKey: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./tabs", "specifiers": ["DomainTab", "LexemesTab", "GrammarsTab", "ProfileTab"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/actions/tabs/InstigatorTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/tabs/InstigatorTab.jsx", "sourceCode": "export function InstigatorTab({ action, onChange, schema }) {\n  const actor = action.actor || {};\n\n  const updateActor = (field, value) => {\n    onChange({\n      ...action,\n      actor: { ...actor, [field]: value },\n    });\n  };\n\n  const instigator = actor.instigator;\n  const hasInstigator = Boolean(instigator);\n\n  const addInstigator = () => {\n    updateActor(\"instigator\", { from: \"graph\", kind: \"\", pickStrategy: \"random\", required: false });\n  };\n\n  const updateInstigator = (updated) => {\n    updateActor(\"instigator\", updated);\n  };\n\n  const removeInstigator = () => {\n    updateActor(\"instigator\", undefined);\n  };\n\n  return (\n    <div>\n      <div className=\"info-box\">\n        <div className=\"info-box-title\">Instigator</div>\n        <div className=\"info-box-text\">\n          Configure optional instigator selection for this action.\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">\ud83d\udc64 Instigator (Optional)</div>\n        <div className=\"section-desc\">\n          An instigator can trigger the action on behalf of the actor (e.g., NPC leader acts for\n          their faction).\n        </div>\n\n        {!hasInstigator ? (\n          <div>\n            <div className=\"text-muted text-small mb-md\">\n              No instigator configured. The actor performs the action directly.\n            </div>\n            <button className=\"btn btn-add\" onClick={addInstigator}>\n              + Add Instigator\n            </button>\n          </div>\n        ) : (\n          <div>\n            <label className=\"checkbox-label mb-lg\">\n              <input\n                type=\"checkbox\"\n                checked={instigator.required || false}\n                onChange={(e) =>\n                  updateInstigator({ ...instigator, required: e.target.checked || undefined })\n                }\n                className=\"checkbox\"\n              />\n              Instigator required\n            </label>\n            <VariableSelectionEditor\n              value={instigator}\n              onChange={(updated) =>\n                updateInstigator({ ...updated, required: instigator.required })\n              }\n              schema={schema}\n              availableRefs={[\"$actor\"]}\n            />\n            <button\n              className=\"btn btn-danger-outline mt-lg\"\n              onClick={removeInstigator}\n            >\n              Remove Instigator\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onChange, schema }", "type": "{ action: any; onChange: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared/VariableSelectionEditor", "specifiers": ["VariableSelectionEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/actions/tabs/VariablesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/tabs/VariablesTab.jsx", "sourceCode": "// ============================================================================\n// VariablesTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.action - The action being edited\n * @param {Function} props.onChange - Callback when action changes\n * @param {Object} props.schema - Domain schema\n */\nexport function VariablesTab({ action, onChange, schema }) {\n  const variables = action.variables || {};\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddForm, setShowAddForm] = useState(false);\n\n  // Build available refs for relationship queries (actor, instigator, target, target2 + other vars)\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$actor\", \"$instigator\", \"$target\", \"$target2\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    // Ensure the name starts with $\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    // Create with empty required fields - validation will flag them\n    onChange({\n      ...action,\n      variables: {\n        ...variables,\n        [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"\" } },\n      },\n    });\n    setNewVarName(\"\");\n    setShowAddForm(false);\n  };\n\n  const varEntries = Object.entries(variables);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Variables</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What are variables?</div>\n          <div className=\"info-box-text\">\n            Variables let you select additional entities from the graph to use in mutations. For\n            example, you might select a <code className=\"inline-code\">$victimFaction</code> to\n            create an enemy relationship with, or an <code className=\"inline-code\">$artifact</code>{\" \"}\n            to modify. Variables are resolved after <code className=\"inline-code\">$actor</code> and{\" \"}\n            <code className=\"inline-code\">$target</code> are chosen.\n          </div>\n        </div>\n\n        {varEntries.length === 0 && !showAddForm ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udce6</div>\n            <div className=\"empty-state-title\">No variables defined</div>\n            <div className=\"empty-state-desc\">\n              Add variables to select additional entities for use in mutations.\n            </div>\n          </div>\n        ) : (\n          varEntries.map(([name, config]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={config}\n              onChange={(updated) =>\n                onChange({ ...action, variables: { ...variables, [name]: updated } })\n              }\n              onRemove={() => {\n                const newVars = { ...variables };\n                delete newVars[name];\n                onChange({ ...action, variables: newVars });\n              }}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onChange, schema }", "type": "{ action: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared/VariableSelectionEditor", "specifiers": ["VariableSelectionEditor"], "category": "internal"}, {"source": "./VariablesTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/AddRuleButton.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/AddRuleButton.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onAdd - Callback when a rule type is selected\n * @param {number} props.depth - Nesting depth (limits nested rule types at depth >= 2)\n */\nexport function AddRuleButton({ onAdd, depth = 0 }) {\n  const [showPicker, setShowPicker] = useState(false);\n\n  return (\n    <div className=\"dropdown\">\n      <button className=\"btn-add\" onClick={() => setShowPicker(!showPicker)}>\n        + Add Rule\n      </button>\n\n      {showPicker && (\n        <div className=\"dropdown-menu arb-dropdown\">\n          <div className=\"dropdown-options\">\n            {Object.entries(APPLICABILITY_TYPES)\n              .filter(([type]) => depth < 2 || (type !== \"or\" && type !== \"and\"))\n              .map(([type, config]) => (\n                <div\n                  key={type}\n                  className=\"dropdown-menu-item\"\n                  onClick={() => {\n                    onAdd(type);\n                    setShowPicker(false);\n                  }}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div\n                    className=\"dropdown-menu-icon\"\n                    // eslint-disable-next-line local/no-inline-styles -- dynamic color per rule type\n                    style={{ '--arb-icon-bg': `${config.color}20`, backgroundColor: 'var(--arb-icon-bg)' }}\n                  >\n                    {config.icon}\n                  </div>\n                  <div>\n                    <div className=\"dropdown-menu-label\">{config.label}</div>\n                    <div className=\"arb-desc\">\n                      {config.desc}\n                    </div>\n                  </div>\n                </div>\n              ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ onAdd, depth = 0 }", "type": "{ onAdd: Function; depth: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["APPLICABILITY_TYPES"], "category": "internal"}, {"source": "./AddRuleButton.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityRuleCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityRuleCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.rule - The rule configuration\n * @param {Function} props.onChange - Callback when rule changes\n * @param {Function} props.onRemove - Callback to remove this rule\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n * @param {number} props.depth - Nesting depth for nested rules\n */\nexport function ApplicabilityRuleCard({\n  rule,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  eras,\n  depth = 0,\n}) {\n  const [expanded, setExpanded] = useState(false);\n  const typeConfig = APPLICABILITY_TYPES[rule.type] || {};\n\n  const entityKinds = schema?.entityKinds || [];\n  const entityKindOptions = entityKinds.map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const getSubtypesForKind = (kind) => {\n    const ek = entityKinds.find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const pressureOptions = (pressures || []).map((p) => ({\n    value: p.id,\n    label: p.name || p.id,\n  }));\n\n  const eraOptions = (eras || []).map((e) => ({\n    value: e.id,\n    label: e.name || e.id,\n  }));\n\n  const updateField = (field, value) => {\n    onChange({ ...rule, [field]: value });\n  };\n\n  const getSummary = () => {\n    switch (rule.type) {\n      case \"entity_count\": {\n        const kindSpec = `${rule.kind || \"?\"}${rule.subtype ? \":\" + rule.subtype : \"\"}`;\n        const minPart = rule.min !== undefined ? `>= ${rule.min}` : \"\";\n        const maxPart = rule.max !== undefined ? ` <= ${rule.max}` : \"\";\n        return `${kindSpec} ${minPart}${maxPart}`;\n      }\n      case \"pressure\":\n        return `${rule.pressureId || \"?\"} in [${rule.min ?? \"-\\u221E\"}, ${rule.max ?? \"\\u221E\"}]`;\n      case \"pressure_any_above\":\n        return `Any of [${rule.pressureIds?.join(\", \") || \"?\"}] > ${rule.threshold ?? \"?\"}`;\n      case \"pressure_compare\":\n        return `${rule.pressureA || \"?\"} ${rule.operator || \">\"} ${rule.pressureB || \"?\"}`;\n      case \"relationship_count\": {\n        const relMinPart = rule.min !== undefined ? `>= ${rule.min}` : \"\";\n        const relMaxPart = rule.max !== undefined ? ` <= ${rule.max}` : \"\";\n        return `${rule.relationshipKind || \"any\"} count ${relMinPart}${relMaxPart}`;\n      }\n      case \"relationship_exists\": {\n        const targetSuffix = rule.targetKind ? ` to ${rule.targetKind}` : \"\";\n        return `${rule.relationshipKind || \"?\"} exists${targetSuffix}`;\n      }\n      case \"tag_exists\":\n        return `has tag \"${rule.tag || \"?\"}\"`;\n      case \"tag_absent\":\n        return `missing tag \"${rule.tag || \"?\"}\"`;\n      case \"status\":\n        return rule.not ? `status != ${rule.status || \"?\"}` : `status = ${rule.status || \"?\"}`;\n      case \"prominence\":\n        return `prominence ${rule.min || \"?\"}-${rule.max || \"?\"}`;\n      case \"time_elapsed\":\n        return `${rule.minTicks || \"?\"} ticks since ${rule.since || \"updated\"}`;\n      case \"growth_phases_complete\": {\n        const eraSuffix = rule.eraId ? ` in ${rule.eraId}` : \"\";\n        return `${rule.minPhases ?? \"?\"} growth phases${eraSuffix}`;\n      }\n      case \"era_match\":\n        return rule.eras?.length ? rule.eras.join(\", \") : \"No eras selected\";\n      case \"random_chance\":\n        return `${Math.round((rule.chance ?? 0.5) * 100)}% chance`;\n      case \"cooldown_elapsed\":\n        return `${rule.cooldownTicks ?? \"?\"} ticks since last run`;\n      case \"creations_per_epoch\":\n        return `max ${rule.maxPerEpoch ?? \"?\"} per epoch`;\n      case \"graph_path\":\n        return `graph path (${rule.assert?.check || \"exists\"})`;\n      case \"entity_exists\":\n        return `entity ${rule.entity || \"?\"} exists`;\n      case \"entity_has_relationship\":\n        return `${rule.entity || \"?\"} has ${rule.relationshipKind || \"?\"} relationship`;\n      case \"or\":\n      case \"and\":\n        return `${rule.conditions?.length || 0} sub-rules`;\n      case \"always\":\n        return \"always\";\n      default:\n        return rule.type;\n    }\n  };\n\n  const isNested = rule.type === \"or\" || rule.type === \"and\";\n\n  return (\n    <div className=\"condition-card\">\n      <div className=\"condition-card-header\">\n        <div className=\"condition-card-type\">\n          <div\n            className=\"condition-card-icon\"\n            // eslint-disable-next-line local/no-inline-styles -- dynamic color per rule type\n            style={{ '--arc-icon-bg': `${typeConfig.color || \"#3b82f6\"}20`, backgroundColor: 'var(--arc-icon-bg)' }}\n          >\n            {typeConfig.icon || \"\ud83d\udccb\"}\n          </div>\n          <div>\n            <div className=\"condition-card-label\">{typeConfig.label || rule.type}</div>\n            <div className=\"condition-card-summary\">{getSummary()}</div>\n          </div>\n        </div>\n        <div className=\"condition-card-actions\">\n          <button className=\"btn-icon\" onClick={() => setExpanded(!expanded)}>\n            {expanded ? \"^\" : \"v\"}\n          </button>\n          <button className=\"btn-icon btn-icon-danger\" onClick={onRemove}>\n            x\n          </button>\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"mt-lg\">\n          <div className=\"form-grid\">\n            {rule.type === \"entity_count\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={rule.kind}\n                  onChange={(v) => {\n                    updateField(\"kind\", v);\n                    if (rule.subtype) updateField(\"subtype\", undefined);\n                  }}\n                  options={entityKindOptions}\n                />\n                <ReferenceDropdown\n                  label=\"Subtype (optional)\"\n                  value={rule.subtype || \"\"}\n                  onChange={(v) => updateField(\"subtype\", v || undefined)}\n                  options={[{ value: \"\", label: \"Any\" }, ...getSubtypesForKind(rule.kind)]}\n                  placeholder=\"Any\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Min\n                  <NumberInput\n                    value={rule.min}\n                    onChange={(v) => updateField(\"min\", v)}\n                    min={0}\n                    integer\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Max\n                  <NumberInput\n                    value={rule.max}\n                    onChange={(v) => updateField(\"max\", v)}\n                    min={0}\n                    integer\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure\"\n                  value={rule.pressureId}\n                  onChange={(v) => updateField(\"pressureId\", v)}\n                  options={pressureOptions}\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Min Value\n                  <NumberInput\n                    value={rule.min}\n                    onChange={(v) => updateField(\"min\", v)}\n                    min={-100}\n                    max={100}\n                    integer\n                    allowEmpty\n                    placeholder=\"0\"\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Max Value\n                  <NumberInput\n                    value={rule.max}\n                    onChange={(v) => updateField(\"max\", v)}\n                    min={-100}\n                    max={100}\n                    integer\n                    allowEmpty\n                    placeholder=\"100\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure_any_above\" && (\n              <>\n                <div className=\"grid-col-full\">\n                  <ChipSelect\n                    label=\"Pressures\"\n                    value={rule.pressureIds || []}\n                    onChange={(v) => updateField(\"pressureIds\", v)}\n                    options={pressureOptions}\n                    placeholder=\"+ Add pressure\"\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Threshold\n                  <NumberInput\n                    value={rule.threshold}\n                    onChange={(v) => updateField(\"threshold\", v ?? 0)}\n                    min={-100}\n                    max={100}\n                    integer\n                    placeholder=\"50\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure_compare\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure A\"\n                  value={rule.pressureA}\n                  onChange={(v) => updateField(\"pressureA\", v)}\n                  options={pressureOptions}\n                />\n                <ReferenceDropdown\n                  label=\"Operator\"\n                  value={rule.operator || \">\"}\n                  onChange={(v) => updateField(\"operator\", v)}\n                  options={[\n                    { value: \">\", label: \">\" },\n                    { value: \">=\", label: \">=\" },\n                    { value: \"<\", label: \"<\" },\n                    { value: \"<=\", label: \"<=\" },\n                    { value: \"==\", label: \"==\" },\n                    { value: \"!=\", label: \"!=\" },\n                  ]}\n                />\n                <ReferenceDropdown\n                  label=\"Pressure B\"\n                  value={rule.pressureB}\n                  onChange={(v) => updateField(\"pressureB\", v)}\n                  options={pressureOptions}\n                />\n              </>\n            )}\n\n\n            {rule.type === \"era_match\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Eras\"\n                  value={rule.eras || []}\n                  onChange={(v) => updateField(\"eras\", v)}\n                  options={eraOptions}\n                  placeholder=\"+ Add era\"\n                />\n              </div>\n            )}\n\n            {rule.type === \"random_chance\" && (\n              <div className=\"form-group grid-col-full\">\n                <span className=\"label\">Chance (%)</span>\n                <div className=\"flex items-center gap-lg\">\n// ... (truncated)", "parameters": [{"name": "{\n  rule,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  eras,\n  depth = 0,\n}", "type": "{ rule: any; onChange: Function; onRemove: Function; schema: any; pressures: any[]; eras: any[]; depth: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["APPLICABILITY_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput", "PROMINENCE_LEVELS"], "category": "internal"}, {"source": "./AddRuleButton", "specifiers": ["AddRuleButton"], "category": "internal"}, {"source": "./createNewRule", "specifiers": ["createNewRule"], "category": "internal"}, {"source": "../filters/GraphPathEditor", "specifiers": ["GraphPathEditor"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n */\nexport function ApplicabilityTab({ generator, onChange, schema, pressures, eras }) {\n  const rules = generator.applicability || [];\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Applicability Rules</div>\n        <div className=\"section-desc\">\n          Define when this generator is eligible to run. If no rules are defined, the generator will\n          always be eligible. Multiple top-level rules are combined with AND logic.\n        </div>\n\n        {rules.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\u2713</div>\n            <div className=\"empty-state-title\">No applicability rules</div>\n            <div className=\"empty-state-desc\">\n              This generator will always be eligible to run. Add rules to control when it activates.\n            </div>\n          </div>\n        ) : (\n          rules.map((rule, index) => (\n            <ApplicabilityRuleCard\n              key={index}\n              rule={rule}\n              onChange={(updated) => {\n                const newRules = [...rules];\n                newRules[index] = updated;\n                onChange({ ...generator, applicability: newRules });\n              }}\n              onRemove={() =>\n                onChange({ ...generator, applicability: rules.filter((_, i) => i !== index) })\n              }\n              schema={schema}\n              pressures={pressures}\n              eras={eras}\n            />\n          ))\n        )}\n\n        <AddRuleButton\n          onAdd={(type) => {\n            const newRule = createNewRule(type, pressures);\n            onChange({ ...generator, applicability: [...rules, newRule] });\n          }}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema, pressures, eras }", "type": "{ generator: any; onChange: Function; schema: any; pressures: any[]; eras: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ApplicabilityRuleCard", "specifiers": ["ApplicabilityRuleCard"], "category": "internal"}, {"source": "./AddRuleButton", "specifiers": ["AddRuleButton"], "category": "internal"}, {"source": "./createNewRule", "specifiers": ["createNewRule"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js::createNewRule", "name": "createNewRule", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/index.js::createNewRule", "name": "createNewRule", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/index.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/cards/GeneratorListCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/cards/GeneratorListCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator to display\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {Function} props.onToggle - Callback to toggle enabled state\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport function GeneratorListCard({ generator, onClick, onToggle, usageMap }) {\n  const isEnabled = generator.enabled !== false;\n\n  const summary = useMemo(() => {\n    const creates =\n      generator.creation?.map((c) => c.kind).filter((v, i, a) => a.indexOf(v) === i) || [];\n    const rels = generator.relationships?.length || 0;\n    const effects = generator.stateUpdates?.length || 0;\n    return { creates, rels, effects };\n  }, [generator]);\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"generator\", generator.id)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, generator.id]\n  );\n\n  const eraUsage = useMemo(() => {\n    if (!usageMap?.generators?.[generator.id]) return [];\n    return usageMap.generators[generator.id].eras || [];\n  }, [usageMap, generator.id]);\n\n  const errorCount = validation.invalidRefs.length;\n  const hasErrors = errorCount > 0;\n  const isOrphan = validation.isOrphan;\n\n  return (\n    <div\n      className={`card card-clickable ${!isEnabled ? \"card-disabled\" : \"\"} ${hasErrors ? \"card-error\" : \"\"} ${isOrphan && !hasErrors ? \"card-warning\" : \"\"}`}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{generator.name || generator.id}</span>\n            <ErrorBadge count={errorCount} />\n          </div>\n          <div className=\"card-id\">{generator.id}</div>\n        </div>\n        <EnableToggle\n          enabled={isEnabled}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n        />\n      </div>\n\n      <div className=\"card-stats\">\n        <div className=\"card-stat\">\n          <span>\u2728</span> {generator.creation?.length || 0} creates\n        </div>\n        <div className=\"card-stat\">\n          <span>\ud83d\udd17</span> {summary.rels} rels\n        </div>\n        <div className=\"card-stat\">\n          <span>\u26a1</span> {summary.effects} effects\n        </div>\n      </div>\n\n      <div className=\"card-badges\">\n        {summary.creates.slice(0, 3).map((kind) => (\n          <span key={kind} className=\"badge badge-entity-kind\">\n            + {kind}\n          </span>\n        ))}\n      </div>\n\n      <EraBadges eras={eraUsage} />\n      {isOrphan && (\n        <div className=\"mt-md\">\n          <OrphanBadge isOrphan={isOrphan} />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onClick, onToggle, usageMap }", "type": "{ generator: any; onClick: Function; onToggle: Function; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["getElementValidation"], "category": "external"}, {"source": "../../shared", "specifiers": ["ErrorBadge", "OrphanBadge", "EraBadges", "EnableToggle"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/GraphPathEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/GraphPathEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.assert - The path assertion configuration\n * @param {Function} props.onChange - Callback when assertion changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function GraphPathEditor({ assert, onChange, schema, availableRefs }) {\n  const [showConstraintMenu, setShowConstraintMenu] = useState(false);\n\n  const assertion = assert || { check: \"exists\", path: [] };\n\n  const updateAssertion = (field, value) => {\n    onChange({ ...assertion, [field]: value });\n  };\n\n  const addStep = () => {\n    // Create with empty required fields - validation will flag them\n    const newStep = { via: \"\", direction: \"\", targetKind: \"\", targetSubtype: \"\" };\n    updateAssertion(\"path\", [...(assertion.path || []), newStep]);\n  };\n\n  const updateStep = (index, updated) => {\n    const newPath = [...(assertion.path || [])];\n    newPath[index] = updated;\n    updateAssertion(\"path\", newPath);\n  };\n\n  const removeStep = (index) => {\n    updateAssertion(\n      \"path\",\n      (assertion.path || []).filter((_, i) => i !== index)\n    );\n  };\n\n  const addConstraint = (type) => {\n    const newConstraint = { type };\n    if (type === \"has_relationship\" || type === \"lacks_relationship\") {\n      newConstraint.direction = \"any\";\n    }\n    updateAssertion(\"where\", [...(assertion.where || []), newConstraint]);\n    setShowConstraintMenu(false);\n  };\n\n  const updateConstraint = (index, updated) => {\n    const newWhere = [...(assertion.where || [])];\n    newWhere[index] = updated;\n    updateAssertion(\"where\", newWhere);\n  };\n\n  const removeConstraint = (index) => {\n    const newWhere = (assertion.where || []).filter((_, i) => i !== index);\n    updateAssertion(\"where\", newWhere.length > 0 ? newWhere : undefined);\n  };\n\n  // Collect variables from path steps for constraint references\n  const pathVars = (assertion.path || []).filter((s) => s.as).map((s) => s.as);\n  const allRefs = [...(availableRefs || []), ...pathVars];\n\n  return (\n    <div className=\"graph-path-editor\">\n      {/* Check type and count */}\n      <div className=\"path-editor-grid\">\n        <div>\n          <label className=\"label label-tiny\">Check Type\n          <ReferenceDropdown\n            value={assertion.check || \"exists\"}\n            onChange={(v) => updateAssertion(\"check\", v)}\n            options={PATH_CHECK_TYPES}\n          />\n          </label>\n        </div>\n        {(assertion.check === \"count_min\" || assertion.check === \"count_max\") && (\n          <div>\n            <label className=\"label label-tiny\">Count\n            <NumberInput\n              value={assertion.count ?? 1}\n              onChange={(v) => updateAssertion(\"count\", v ?? 1)}\n              min={0}\n              integer\n              className=\"input input-compact\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      {/* Path steps */}\n      <div>\n        <span className=\"label label-tiny\">Path Steps (traverse relationships)</span>\n        <div className=\"path-steps-list\">\n          {(assertion.path || []).map((step, index) => (\n            <PathStepEditor\n              key={index}\n              step={step}\n              onChange={(updated) => updateStep(index, updated)}\n              onRemove={() => removeStep(index)}\n              schema={schema}\n              stepIndex={index}\n            />\n          ))}\n          {(assertion.path || []).length < 2 && (\n            <button onClick={addStep} className=\"button button-add-step\">\n              + Add Step {(assertion.path || []).length === 0 ? \"(required)\" : \"(optional)\"}\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* Where constraints */}\n      <div>\n        <span className=\"label label-tiny\">Where Constraints (optional)</span>\n        <div className=\"path-constraints-list\">\n          {(assertion.where || []).map((constraint, index) => (\n            <PathConstraintEditor\n              key={index}\n              constraint={constraint}\n              onChange={(updated) => updateConstraint(index, updated)}\n              onRemove={() => removeConstraint(index)}\n              schema={schema}\n              availableRefs={allRefs}\n            />\n          ))}\n          <div className=\"relative\">\n            <button\n              onClick={() => setShowConstraintMenu(!showConstraintMenu)}\n              className=\"button button-add-constraint\"\n            >\n              + Add Constraint\n            </button>\n            {showConstraintMenu && (\n              <div className=\"dropdown-menu\">\n                {PATH_CONSTRAINT_TYPES.map(({ value, label }) => (\n                  <div\n                    key={value}\n                    onClick={() => addConstraint(value)}\n                    className=\"dropdown-menu-item\"\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    {label}\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ assert, onChange, schema, availableRefs }", "type": "{ assert: any; onChange: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["PATH_CHECK_TYPES", "PATH_CONSTRAINT_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "./PathStepEditor", "specifiers": ["PathStepEditor"], "category": "internal"}, {"source": "./PathConstraintEditor", "specifiers": ["PathConstraintEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/PathConstraintEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/PathConstraintEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.constraint - The path constraint configuration\n * @param {Function} props.onChange - Callback when constraint changes\n * @param {Function} props.onRemove - Callback to remove this constraint\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function PathConstraintEditor({ constraint, onChange, onRemove, schema, availableRefs }) {\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const entityKinds = schema?.entityKinds || [];\n  const entityKindOptions = entityKinds.map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  // Gather all subtypes from all entity kinds for subtype_equals constraint\n  const allSubtypeOptions = entityKinds.flatMap((ek) =>\n    (ek.subtypes || []).map((st) => ({\n      value: st.id,\n      label: `${st.name || st.id} (${ek.kind})`,\n    }))\n  );\n\n  const refOptions = (availableRefs || []).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  const updateConstraint = (field, value) => {\n    onChange({ ...constraint, [field]: value || undefined });\n  };\n\n  const renderConstraintFields = () => {\n    switch (constraint.type) {\n      case \"not_self\":\n        return <span className=\"text-muted text-small\">Target cannot be the starting entity</span>;\n\n      case \"not_in\":\n      case \"in\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Set Variable\n            <ReferenceDropdown\n              value={constraint.set || \"\"}\n              onChange={(v) => updateConstraint(\"set\", v)}\n              options={refOptions}\n              placeholder=\"e.g. $allies\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"kind_equals\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Entity Kind\n            <ReferenceDropdown\n              value={constraint.kind || \"\"}\n              onChange={(v) => updateConstraint(\"kind\", v)}\n              options={entityKindOptions}\n            />\n            </label>\n          </div>\n        );\n\n      case \"subtype_equals\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Subtype\n            <ReferenceDropdown\n              value={constraint.subtype || \"\"}\n              onChange={(v) => updateConstraint(\"subtype\", v)}\n              options={allSubtypeOptions}\n              placeholder=\"Select subtype...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_relationship\":\n      case \"lacks_relationship\":\n        return (\n          <div className=\"constraint-fields-grid\">\n            <div>\n              <label className=\"label label-micro\">Kind\n              <ReferenceDropdown\n                value={constraint.kind || \"\"}\n                onChange={(v) => updateConstraint(\"kind\", v)}\n                options={relationshipKindOptions}\n              />\n              </label>\n            </div>\n            <div>\n              <label className=\"label label-micro\">With\n              <ReferenceDropdown\n                value={constraint.with || \"\"}\n                onChange={(v) => updateConstraint(\"with\", v)}\n                options={refOptions}\n              />\n              </label>\n            </div>\n            <div>\n              <label className=\"label label-micro\">Direction\n              <ReferenceDropdown\n                value={constraint.direction || \"any\"}\n                onChange={(v) => updateConstraint(\"direction\", v)}\n                options={PATH_DIRECTIONS}\n              />\n              </label>\n            </div>\n          </div>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  const constraintLabel =\n    PATH_CONSTRAINT_TYPES.find((c) => c.value === constraint.type)?.label || constraint.type;\n\n  return (\n    <div className=\"path-constraint-card\">\n      <div className=\"path-constraint-header\">\n        <span className=\"path-constraint-label\">{constraintLabel}</span>\n        <button onClick={onRemove} className=\"button button-remove-micro\">\n          \u00d7\n        </button>\n      </div>\n      {renderConstraintFields()}\n    </div>\n  );\n}", "parameters": [{"name": "{ constraint, onChange, onRemove, schema, availableRefs }", "type": "{ constraint: any; onChange: Function; onRemove: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["PATH_DIRECTIONS", "PATH_CONSTRAINT_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/PathStepEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/PathStepEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.step - The path step configuration\n * @param {Function} props.onChange - Callback when step changes\n * @param {Function} props.onRemove - Callback to remove this step\n * @param {Object} props.schema - Domain schema\n * @param {number} props.stepIndex - Index of this step in the path\n */\nexport function PathStepEditor({ step, onChange, onRemove, schema, stepIndex }) {\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const entityKindOptions = [\n    { value: \"any\", label: \"Any kind\" },\n    ...(schema?.entityKinds || []).map((ek) => ({\n      value: ek.kind,\n      label: ek.description || ek.kind,\n    })),\n  ];\n\n  const getSubtypeOptions = (kind) => {\n    if (!kind || kind === \"any\") return [{ value: \"any\", label: \"Any subtype\" }];\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [{ value: \"any\", label: \"Any subtype\" }];\n    return [\n      { value: \"any\", label: \"Any subtype\" },\n      ...ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id })),\n    ];\n  };\n\n  const updateStep = (field, value) => {\n    onChange({ ...step, [field]: value });\n  };\n\n  return (\n    <div className=\"path-step-card\">\n      <div className=\"path-step-header\">\n        <span className=\"path-step-label\">Step {stepIndex + 1}</span>\n        <button onClick={onRemove} className=\"button button-remove-micro\">\n          \u00d7\n        </button>\n      </div>\n      <div className=\"path-step-grid\">\n        <div>\n          <label className=\"label label-micro\">Via Relationship\n          <ReferenceDropdown\n            value={step.via || \"\"}\n            onChange={(v) => updateStep(\"via\", v)}\n            options={relationshipKindOptions}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Direction\n          <ReferenceDropdown\n            value={step.direction || \"any\"}\n            onChange={(v) => updateStep(\"direction\", v)}\n            options={PATH_DIRECTIONS}\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Target Kind\n          <ReferenceDropdown\n            value={step.targetKind}\n            onChange={(v) => updateStep(\"targetKind\", v)}\n            options={entityKindOptions}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Target Subtype\n          <ReferenceDropdown\n            value={step.targetSubtype}\n            onChange={(v) => updateStep(\"targetSubtype\", v)}\n            options={getSubtypeOptions(step.targetKind)}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div className=\"path-step-full-width\">\n          <label htmlFor=\"store-as-variable-optional\" className=\"label label-micro\">Store As Variable (optional)</label>\n          <input id=\"store-as-variable-optional\"\n            type=\"text\"\n            value={step.as || \"\"}\n            onChange={(e) => updateStep(\"as\", e.target.value)}\n            className=\"input input-micro\"\n            placeholder=\"e.g. $allies\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ step, onChange, onRemove, schema, stepIndex }", "type": "{ step: any; onChange: Function; onRemove: Function; schema: any; stepIndex: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["PATH_DIRECTIONS"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFilterCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFilterCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.filter - The filter configuration\n * @param {Function} props.onChange - Callback when filter changes\n * @param {Function} props.onRemove - Callback to remove this filter\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function SelectionFilterCard({ filter, onChange, onRemove, schema, availableRefs }) {\n  const [expanded, setExpanded] = useState(false);\n  const typeConfig = FILTER_TYPES[filter.type] || {\n    label: filter.type,\n    icon: \"\u2753\",\n    color: \"#6b7280\",\n  };\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const refOptions = (availableRefs || []).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  const updateFilter = (field, value) => {\n    onChange({ ...filter, [field]: value });\n  };\n\n  const getSummary = () => {\n    switch (filter.type) {\n      case \"has_tag\": {\n        const valueSuffix = filter.value !== undefined ? ` = ${filter.value}` : \"\";\n        return `${filter.tag || \"?\"}${valueSuffix}`;\n      }\n      case \"has_tags\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"has_any_tag\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"lacks_tag\":\n        return filter.tag || \"tag?\";\n      case \"lacks_any_tag\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"has_culture\":\n        return filter.culture || \"culture?\";\n      case \"matches_culture\":\n        return `with ${filter.with || \"?\"}`;\n      case \"has_status\":\n        return filter.status || \"status?\";\n      case \"has_prominence\":\n        return filter.minProminence || \"prominence?\";\n      case \"has_relationship\": {\n        const withLabel = filter.with ? ` with ${filter.with}` : \"\";\n        const direction = filter.direction ? ` [${filter.direction}]` : \"\";\n        return `${filter.kind || \"?\"}${withLabel}${direction}`;\n      }\n      case \"lacks_relationship\": {\n        const withLabel = filter.with ? ` with ${filter.with}` : \"\";\n        return `${filter.kind || \"?\"}${withLabel}`;\n      }\n      case \"exclude\":\n        return `${(filter.entities || []).length} excluded`;\n      case \"shares_related\":\n        return `${filter.relationshipKind || \"?\"} with ${filter.with || \"?\"}`;\n      case \"graph_path\":\n        return `graph path (${filter.assert?.check || \"exists\"})`;\n      default:\n        return \"\";\n    }\n  };\n\n  const summary = getSummary();\n\n  const renderFilterFields = () => {\n    switch (filter.type) {\n      case \"has_tag\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-wide\">\n              <label className=\"label label-small\">Tag\n              <TagSelector\n                value={filter.tag ? [filter.tag] : []}\n                onChange={(v) => updateFilter(\"tag\", v[0] || \"\")}\n                tagRegistry={schema?.tagRegistry || []}\n                placeholder=\"Select tag...\"\n                singleSelect\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-wide\">\n              <label htmlFor=\"value-optional\" className=\"label label-small\">Value (optional)</label>\n              <input id=\"value-optional\"\n                type=\"text\"\n                value={filter.value ?? \"\"}\n                onChange={(e) => updateFilter(\"value\", e.target.value || undefined)}\n                className=\"input input-compact\"\n                placeholder=\"Any value\"\n              />\n            </div>\n          </div>\n        );\n\n      case \"has_tags\":\n      case \"has_any_tag\":\n        return (\n          <div>\n            <label className=\"label label-small\">\n              {filter.type === \"has_tags\" ? \"Tags (must have ALL)\" : \"Tags (must have at least ONE)\"}\n            </label>\n            <TagSelector\n              value={filter.tags || []}\n              onChange={(v) => updateFilter(\"tags\", v)}\n              tagRegistry={schema?.tagRegistry || []}\n              placeholder=\"Select tags...\"\n            />\n          </div>\n        );\n\n      case \"lacks_tag\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-wide\">\n              <label className=\"label label-small\">Tag\n              <TagSelector\n                value={filter.tag ? [filter.tag] : []}\n                onChange={(v) => updateFilter(\"tag\", v[0] || \"\")}\n                tagRegistry={schema?.tagRegistry || []}\n                placeholder=\"Select tag...\"\n                singleSelect\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-wide\">\n              <label htmlFor=\"value-optional\" className=\"label label-small\">Value (optional)</label>\n              <input id=\"value-optional\"\n                type=\"text\"\n                value={filter.value ?? \"\"}\n                onChange={(e) => updateFilter(\"value\", e.target.value || undefined)}\n                className=\"input input-compact\"\n                placeholder=\"Any value\"\n              />\n            </div>\n          </div>\n        );\n\n      case \"lacks_any_tag\":\n        return (\n          <div>\n            <label className=\"label label-small\">Tags (exclude if has ANY)\n            <TagSelector\n              value={filter.tags || []}\n              onChange={(v) => updateFilter(\"tags\", v)}\n              tagRegistry={schema?.tagRegistry || []}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n        );\n\n\n      case \"has_culture\":\n        return (\n          <div>\n            <label className=\"label label-small\">Culture\n            <ReferenceDropdown\n              value={filter.culture || \"\"}\n              onChange={(v) => updateFilter(\"culture\", v)}\n              options={(schema?.cultures || []).map((c) => ({\n                value: c.id,\n                label: c.name || c.id,\n              }))}\n              placeholder=\"Select culture...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"matches_culture\":\n        return (\n          <div>\n            <label className=\"label label-small\">Same Culture As\n            <ReferenceDropdown\n              value={filter.with || \"\"}\n              onChange={(v) => updateFilter(\"with\", v)}\n              options={refOptions}\n              placeholder=\"Select variable...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_status\":\n        return (\n          <div>\n            <label htmlFor=\"status\" className=\"label label-small\">Status</label>\n            <input id=\"status\"\n              type=\"text\"\n              value={filter.status || \"\"}\n              onChange={(e) => updateFilter(\"status\", e.target.value)}\n              className=\"input input-compact\"\n              placeholder=\"e.g., active, historical\"\n            />\n          </div>\n        );\n\n      case \"has_prominence\":\n        return (\n          <div>\n            <label className=\"label label-small\">Minimum Prominence\n            <ReferenceDropdown\n              value={filter.minProminence || \"\"}\n              onChange={(v) => updateFilter(\"minProminence\", v)}\n              options={PROMINENCE_LEVELS.map((p) => ({ value: p.value, label: p.label }))}\n              placeholder=\"Select prominence...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_relationship\":\n      case \"lacks_relationship\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-medium\">\n              <label className=\"label label-small\">Relationship Kind\n              <ReferenceDropdown\n                value={filter.kind || \"\"}\n                onChange={(v) => updateFilter(\"kind\", v)}\n                options={relationshipKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-narrow\">\n              <label className=\"label label-small\">With Entity (optional)\n              <ReferenceDropdown\n                value={filter.with || \"\"}\n                onChange={(v) => updateFilter(\"with\", v || undefined)}\n                options={refOptions}\n                placeholder=\"Any entity\"\n              />\n              </label>\n            </div>\n            {filter.type === \"has_relationship\" && (\n              <div className=\"sfc-flex-field-tiny\">\n                <label className=\"label label-small\">Direction\n                <ReferenceDropdown\n                  value={filter.direction || \"both\"}\n                  onChange={(v) => updateFilter(\"direction\", v)}\n                  options={[\n                    { value: \"both\", label: \"Both\" },\n                    { value: \"src\", label: \"Outgoing\" },\n                    { value: \"dst\", label: \"Incoming\" },\n                  ]}\n                />\n                </label>\n              </div>\n            )}\n          </div>\n        );\n\n      case \"exclude\":\n        return (\n          <ChipSelect\n            label=\"Entities to Exclude\"\n            value={filter.entities || []}\n            onChange={(v) => updateFilter(\"entities\", v)}\n            options={refOptions}\n            placeholder=\"+ Add variable...\"\n          />\n        );\n\n      case \"shares_related\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-medium\">\n              <label className=\"label label-small\">Via Relationship\n              <ReferenceDropdown\n                value={filter.relationshipKind || \"\"}\n                onChange={(v) => updateFilter(\"relationshipKind\", v)}\n                options={relationshipKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-narrow\">\n              <label className=\"label label-small\">With Entity\n              <ReferenceDropdown\n                value={filter.with || \"\"}\n                onChange={(v) => updateFilter(\"with\", v)}\n                options={refOptions}\n                placeholder=\"Select variable...\"\n              />\n              </label>\n            </div>\n          </div>\n        );\n\n      case \"graph_path\":\n// ... (truncated)", "parameters": [{"name": "{ filter, onChange, onRemove, schema, availableRefs }", "type": "{ filter: any; onChange: Function; onRemove: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["FILTER_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "ChipSelect", "PROMINENCE_LEVELS"], "category": "internal"}, {"source": "./GraphPathEditor", "specifiers": ["GraphPathEditor"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "./SelectionFilterCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFiltersEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFiltersEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.filters - Array of filter configurations\n * @param {Function} props.onChange - Callback when filters change\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function SelectionFiltersEditor({ filters, onChange, schema, availableRefs }) {\n  const [showTypeMenu, setShowTypeMenu] = useState(false);\n  const [dropdownPos, setDropdownPos] = useState({ top: 0, left: 0, width: 0 });\n  const containerRef = useRef(null);\n\n  // Calculate dropdown position when opening (like TagSelector)\n  useLayoutEffect(() => {\n    if (showTypeMenu && containerRef.current) {\n      const rect = containerRef.current.getBoundingClientRect();\n      setDropdownPos({\n        top: rect.bottom + 4,\n        left: rect.left,\n        width: Math.max(rect.width, 220),\n      });\n    }\n  }, [showTypeMenu]);\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    if (!showTypeMenu) return;\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setShowTypeMenu(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showTypeMenu]);\n\n  const handleAddFilter = (type) => {\n    // Create with empty required fields - validation will flag them\n    const newFilter = { type };\n    // Tag filters\n    if (type === \"has_tag\") newFilter.tag = \"\";\n    if (type === \"has_tags\") newFilter.tags = [];\n    if (type === \"has_any_tag\") newFilter.tags = [];\n    if (type === \"lacks_tag\") newFilter.tag = \"\";\n    if (type === \"lacks_any_tag\") newFilter.tags = [];\n    // Attribute filters\n    if (type === \"has_culture\") newFilter.culture = \"\";\n    if (type === \"matches_culture\") newFilter.with = \"\";\n    if (type === \"has_status\") newFilter.status = \"\";\n    if (type === \"has_prominence\") newFilter.minProminence = \"\";\n    // Relationship filters\n    if (type === \"has_relationship\") newFilter.kind = \"\";\n    if (type === \"lacks_relationship\") newFilter.kind = \"\";\n    if (type === \"shares_related\") {\n      newFilter.relationshipKind = \"\";\n      newFilter.with = \"\";\n    }\n    // Other\n    if (type === \"exclude\") newFilter.entities = [];\n    if (type === \"graph_path\")\n      newFilter.assert = {\n        check: \"\",\n        path: [{ via: \"\", direction: \"\", targetKind: \"\", targetSubtype: \"\" }],\n      };\n    onChange([...(filters || []), newFilter]);\n    setShowTypeMenu(false);\n  };\n\n  const handleUpdateFilter = (index, updated) => {\n    const newFilters = [...(filters || [])];\n    newFilters[index] = updated;\n    onChange(newFilters);\n  };\n\n  const handleRemoveFilter = (index) => {\n    onChange((filters || []).filter((_, i) => i !== index));\n  };\n\n  return (\n    <div>\n      {(filters || []).length === 0 ? (\n        <div className=\"empty-state-compact\">\n          No filters defined. Filters narrow down which entities can be selected as targets.\n        </div>\n      ) : (\n        <div className=\"condition-list\">\n          {(filters || []).map((filter, index) => (\n            <SelectionFilterCard\n              key={index}\n              filter={filter}\n              onChange={(updated) => handleUpdateFilter(index, updated)}\n              onRemove={() => handleRemoveFilter(index)}\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))}\n        </div>\n      )}\n\n      <div ref={containerRef} className=\"relative mt-lg\">\n        <button onClick={() => setShowTypeMenu(!showTypeMenu)} className=\"btn-add-inline\">\n          + Add Filter\n        </button>\n\n        {showTypeMenu && (\n          <div\n            className=\"dropdown-menu sfe-dropdown-fixed\"\n            // eslint-disable-next-line local/no-inline-styles -- dynamic position from measured DOM rect\n            style={{ '--sfe-dd-top': `${dropdownPos.top}px`, '--sfe-dd-left': `${dropdownPos.left}px`, '--sfe-dd-width': `${dropdownPos.width}px`, top: 'var(--sfe-dd-top)', left: 'var(--sfe-dd-left)', width: 'var(--sfe-dd-width)' }}\n          >\n            {Object.entries(FILTER_TYPES).map(([type, config]) => (\n              <div key={type} onClick={() => handleAddFilter(type)} className=\"dropdown-menu-item\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                <span\n                  className=\"dropdown-menu-icon\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic color per filter type\n                  style={{ '--sfe-icon-bg': `${config.color}20`, backgroundColor: 'var(--sfe-icon-bg)' }}\n                >\n                  {config.icon}\n                </span>\n                <span className=\"dropdown-menu-label\">{config.label}</span>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ filters, onChange, schema, availableRefs }", "type": "{ filters: any[]; onChange: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useLayoutEffect", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["FILTER_TYPES"], "category": "internal"}, {"source": "./SelectionFilterCard", "specifiers": ["SelectionFilterCard"], "category": "internal"}, {"source": "./SelectionFiltersEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx", "sourceCode": "// ============================================================================\n// CreationTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.tagRegistry - Available tags\n * @param {Function} props.onAddToRegistry - Callback to add new tag to registry\n * @param {Array} props.pressures - Available pressure definitions\n */\nexport function CreationTab({\n  generator,\n  onChange,\n  schema,\n  tagRegistry = [],\n  onAddToRegistry,\n  pressures = [],\n}) {\n  const creation = generator.creation || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    creation.forEach((c) => {\n      if (c.entityRef && !refs.includes(c.entityRef)) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, creation]);\n\n  const culturesById = useMemo(() => {\n    const map = {};\n    (schema?.cultures || []).forEach((culture) => {\n      map[culture.id] = culture;\n    });\n    return map;\n  }, [schema?.cultures]);\n\n  const cultureIds = useMemo(() => Object.keys(culturesById), [culturesById]);\n\n  const handleAdd = () => {\n    const nextNum = creation.length + 1;\n    onChange({\n      ...generator,\n      creation: [\n        ...creation,\n        { entityRef: `$entity${nextNum}`, kind: \"npc\", prominence: \"marginal\" },\n      ],\n    });\n  };\n\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Entity Creation</div>\n        <div className=\"section-desc\">\n          Define entities that this generator creates. Each entity gets a reference (like{\" \"}\n          <code className=\"inline-code\">$hero</code>) that can be used in relationships.\n        </div>\n\n        {creation.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\u2728</div>\n            <div className=\"empty-state-title\">No entities created</div>\n            <div className=\"empty-state-desc\">\n              This generator only modifies existing entities. Add creation rules to spawn new\n              entities.\n            </div>\n          </div>\n        ) : (\n          creation.map((item, index) => (\n            <CreationCard\n              key={index}\n              item={item}\n              onChange={(updated) => {\n                const newCreation = [...creation];\n                newCreation[index] = updated;\n                onChange({ ...generator, creation: newCreation });\n              }}\n              onRemove={() =>\n                onChange({ ...generator, creation: creation.filter((_, i) => i !== index) })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n              culturesById={culturesById}\n              cultureIds={cultureIds}\n              generator={generator}\n              tagRegistry={tagRegistry}\n              onAddToRegistry={onAddToRegistry}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Entity Creation\n        </button>\n      </div>\n\n      <VariantsSection\n        generator={generator}\n        onChange={onChange}\n        pressures={pressures}\n        schema={schema}\n        tagRegistry={tagRegistry}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  generator,\n  onChange,\n  schema,\n  tagRegistry = [],\n  onAddToRegistry,\n  pressures = [],\n}", "type": "{ generator: any; onChange: Function; schema: any; tagRegistry: any[]; onAddToRegistry: Function; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "LevelSelector", "PROMINENCE_LEVELS", "ChipSelect", "NumberInput", "LocalTextArea"], "category": "internal"}, {"source": "./CreationTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/EffectsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/EffectsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Object} props.schema - Domain schema\n */\nexport function EffectsTab({ generator, onChange, pressures, schema }) {\n  const stateUpdates = generator.stateUpdates || [];\n  const [showTypeMenu, setShowTypeMenu] = useState(false);\n  const [dropdownPos, setDropdownPos] = useState({ top: 0, left: 0, width: 0 });\n  const addButtonRef = useRef(null);\n\n  // Build available entity references from target + variables + created entities\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  const createMutation = (type) => {\n    let newUpdate;\n    switch (type) {\n      case \"modify_pressure\":\n        newUpdate = { type: \"modify_pressure\", pressureId: pressures?.[0]?.id || \"\", delta: 0 };\n        break;\n      case \"archive_relationship\":\n        newUpdate = {\n          type: \"archive_relationship\",\n          entity: \"$target\",\n          relationshipKind: \"\",\n          direction: \"both\",\n        };\n        break;\n      case \"change_status\":\n        newUpdate = { type: \"change_status\", entity: \"$target\", newStatus: \"\" };\n        break;\n      case \"set_tag\":\n        newUpdate = { type: \"set_tag\", entity: \"$target\", tag: \"\", value: true };\n        break;\n      case \"remove_tag\":\n        newUpdate = { type: \"remove_tag\", entity: \"$target\", tag: \"\" };\n        break;\n      case \"update_rate_limit\":\n        newUpdate = { type: \"update_rate_limit\" };\n        break;\n      default:\n        return null;\n    }\n    return newUpdate;\n  };\n\n  const addMutation = (type) => {\n    const next = createMutation(type);\n    if (!next) return;\n    onChange({ ...generator, stateUpdates: [...stateUpdates, next] });\n  };\n\n  const updateMutation = (index, updated) => {\n    const newUpdates = [...stateUpdates];\n    newUpdates[index] = updated;\n    onChange({ ...generator, stateUpdates: newUpdates });\n  };\n\n  const removeMutation = (index) => {\n    onChange({ ...generator, stateUpdates: stateUpdates.filter((_, i) => i !== index) });\n  };\n\n  const knownTypes = new Set(DEFAULT_MUTATION_TYPES.map((type) => type.value));\n  const unrecognizedUpdates = stateUpdates\n    .map((update, index) => (knownTypes.has(update.type) ? null : { update, index }))\n    .filter(Boolean);\n\n  useLayoutEffect(() => {\n    if (showTypeMenu && addButtonRef.current) {\n      const rect = addButtonRef.current.getBoundingClientRect();\n      setDropdownPos({\n        top: rect.bottom + 4,\n        left: rect.left,\n        width: Math.max(rect.width, 220),\n      });\n    }\n  }, [showTypeMenu]);\n\n  useEffect(() => {\n    if (!showTypeMenu) return;\n    const handleClickOutside = (event) => {\n      if (addButtonRef.current && !addButtonRef.current.contains(event.target)) {\n        setShowTypeMenu(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showTypeMenu]);\n\n  return (\n    <div>\n      {/* Unrecognized Effects - shown first to draw attention */}\n      {unrecognizedUpdates.length > 0 && (\n        <div className=\"section et-unrecognized-section\">\n          <div className=\"section-title et-unrecognized-title\">\n            <span>\u26a0\ufe0f</span> Unrecognized Effects\n          </div>\n          <div className=\"section-desc mb-lg\">\n            These state updates have unrecognized types and may be from an older version. Remove\n            them to clear validation errors.\n          </div>\n\n          {unrecognizedUpdates.map((entry) => {\n            const globalIdx = entry.index;\n            const update = entry.update;\n            return (\n              <div\n                key={globalIdx}\n                className=\"item-card et-unrecognized-card\"\n              >\n                <div className=\"et-unrecognized-body\">\n                  <div className=\"et-unrecognized-layout\">\n                    <div className=\"flex-1\">\n                      <div className=\"et-unrecognized-type\">\n                        Unknown type: &quot;{update.type || \"(no type)\"}&quot;\n                      </div>\n                      <pre className=\"et-unrecognized-json\">\n                        {JSON.stringify(update, null, 2)}\n                      </pre>\n                    </div>\n                    <button\n                      className=\"btn btn-danger flex-shrink-0\"\n                      onClick={() => removeMutation(globalIdx)}\n                    >\n                      Remove\n                    </button>\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      <div className=\"section\">\n        <div className=\"section-title\">\u26a1 Effects ({stateUpdates.length})</div>\n        <div className=\"section-desc\">\n          Apply state updates when this generator runs. Effects use the unified mutation library.\n        </div>\n\n        {stateUpdates.map((update, index) => {\n          if (!knownTypes.has(update.type)) return null;\n          return (\n            <MutationCard\n              key={index}\n              mutation={update}\n              onChange={(updated) => updateMutation(index, updated)}\n              onRemove={() => removeMutation(index)}\n              schema={schema}\n              pressures={pressures}\n              entityOptions={availableRefs}\n              typeOptions={DEFAULT_MUTATION_TYPES}\n              createMutation={createMutation}\n            />\n          );\n        })}\n\n        <div ref={addButtonRef} className=\"relative mt-lg\">\n          <button onClick={() => setShowTypeMenu(!showTypeMenu)} className=\"btn-add-inline\">\n            + Add Effect\n          </button>\n\n          {showTypeMenu && (\n            <div\n              className=\"dropdown-menu et-dropdown-fixed\"\n              // eslint-disable-next-line local/no-inline-styles -- dynamic position from measured DOM rect\n              style={{ '--et-dd-top': `${dropdownPos.top}px`, '--et-dd-left': `${dropdownPos.left}px`, '--et-dd-width': `${dropdownPos.width}px`, top: 'var(--et-dd-top)', left: 'var(--et-dd-left)', width: 'var(--et-dd-width)' }}\n            >\n              {MUTATION_TYPE_OPTIONS.map((opt) => (\n                <div\n                  key={opt.value}\n                  onClick={() => {\n                    addMutation(opt.value);\n                    setShowTypeMenu(false);\n                  }}\n                  className=\"dropdown-menu-item\"\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <span\n                    className=\"dropdown-menu-icon\"\n                    // eslint-disable-next-line local/no-inline-styles -- dynamic color per mutation type\n                    style={{ '--et-icon-bg': `${opt.color}20`, backgroundColor: 'var(--et-icon-bg)' }}\n                  >\n                    {opt.icon}\n                  </span>\n                  <span className=\"dropdown-menu-label\">{opt.label}</span>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, pressures, schema }", "type": "{ generator: any; onChange: Function; pressures: any[]; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useLayoutEffect", "useMemo", "useRef", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared/MutationCard", "specifiers": ["MutationCard", "DEFAULT_MUTATION_TYPES"], "category": "internal"}, {"source": "../../actions/constants", "specifiers": ["MUTATION_TYPE_OPTIONS"], "category": "internal"}, {"source": "./EffectsTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Function} props.onDelete - Callback to delete the generator\n * @param {Function} props.onDuplicate - Callback to duplicate the generator\n */\nexport function OverviewTab({ generator, onChange, onDelete, onDuplicate }) {\n  const updateField = (field, value) => {\n    onChange({ ...generator, [field]: value });\n  };\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(generator.id, (value) =>\n    updateField(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(generator.name, (value) =>\n    updateField(\"name\", value)\n  );\n\n  const summary = useMemo(() => {\n    return {\n      rules: generator.applicability?.length || 0,\n      variables: Object.keys(generator.variables || {}).length,\n      creates: generator.creation?.length || 0,\n      relationships: generator.relationships?.length || 0,\n      effects: generator.stateUpdates?.length || 0,\n    };\n  }, [generator]);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Basic Information</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label htmlFor=\"generator-id\" className=\"label\">Generator ID</label>\n            <input id=\"generator-id\"\n              type=\"text\"\n              value={localId}\n              onChange={(e) => setLocalId(e.target.value)}\n              onBlur={handleIdBlur}\n              className=\"input\"\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"display-name\" className=\"label\">Display Name</label>\n            <input id=\"display-name\"\n              type=\"text\"\n              value={localName}\n              onChange={(e) => setLocalName(e.target.value)}\n              onBlur={handleNameBlur}\n              className=\"input\"\n              placeholder=\"Optional friendly name\"\n            />\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Enabled\n          <EnableToggle\n            enabled={generator.enabled !== false}\n            onChange={(enabled) => updateField(\"enabled\", enabled)}\n            label={generator.enabled !== false ? \"Generator is active\" : \"Generator is disabled\"}\n          />\n          </label>\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">Narration Template</span>\n          <div className=\"section-desc mb-md\">\n            Syntax: {\"{$target.field}\"}, {\"{$var.field}\"}, {\"{count:kind}\"}, {\"{list:created}\"},{\" \"}\n            {\"{field|fallback}\"}.\n          </div>\n          <LocalTextArea\n            value={generator.narrationTemplate || \"\"}\n            onChange={(value) => updateField(\"narrationTemplate\", value || undefined)}\n            placeholder=\"e.g., From {$target.name}, {count:npc} new souls emerged to shape the realm.\"\n            rows={2}\n          />\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Summary</div>\n        <div className=\"summary-stats-grid\">\n          {[\n            { label: \"Rules\", value: summary.rules, icon: \"\u2713\" },\n            { label: \"Variables\", value: summary.variables, icon: \"\ud83d\udce6\" },\n            { label: \"Creates\", value: summary.creates, icon: \"\u2728\" },\n            { label: \"Connects\", value: summary.relationships, icon: \"\ud83d\udd17\" },\n            { label: \"Effects\", value: summary.effects, icon: \"\u26a1\" },\n          ].map((stat) => (\n            <div key={stat.label} className=\"summary-stat\">\n              <div className=\"summary-stat-icon\">{stat.icon}</div>\n              <div className=\"summary-stat-value\">{stat.value}</div>\n              <div className=\"summary-stat-label\">{stat.label}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"danger-zone\">\n        <button className=\"btn btn-secondary\" onClick={onDuplicate}>\n          Duplicate Generator\n        </button>\n        <button className=\"btn btn-danger\" onClick={onDelete}>\n          Delete Generator\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, onDelete, onDuplicate }", "type": "{ generator: any; onChange: Function; onDelete: Function; onDuplicate: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["EnableToggle", "useLocalInputState", "LocalTextArea"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function RelationshipsTab({ generator, onChange, schema }) {\n  const relationships = generator.relationships || [];\n  const saturationLimits = generator.selection?.saturationLimits || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  // Find the first created entity ref for implied relationships\n  const firstCreatedRef = useMemo(() => {\n    const creation = generator.creation || [];\n    return creation.length > 0 ? creation[0].entityRef : \"$created\";\n  }, [generator.creation]);\n\n  const handleAdd = () => {\n    onChange({\n      ...generator,\n      relationships: [\n        ...relationships,\n        {\n          kind: schema?.relationshipKinds?.[0]?.kind || \"ally_of\",\n          src: availableRefs[1] || \"$entity1\",\n          dst: \"$target\",\n          strength: 0.8,\n        },\n      ],\n    });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Relationships</div>\n        <div className=\"section-desc\">\n          Define relationships created between entities. Use entity references like{\" \"}\n          <code className=\"inline-code\">$target</code>, created entities like{\" \"}\n          <code className=\"inline-code\">$hero</code>, or variables like{\" \"}\n          <code className=\"inline-code\">$faction</code>.\n        </div>\n\n        {/* Implied relationships from saturation limits */}\n        {saturationLimits.length > 0 && (\n          <div className=\"mb-xl\">\n            {saturationLimits.map((limit, index) => (\n              <ImpliedRelationshipCard\n                key={`implied-${index}`}\n                saturationLimit={limit}\n                schema={schema}\n                createdEntityRef={firstCreatedRef}\n              />\n            ))}\n          </div>\n        )}\n\n        {relationships.length === 0 && saturationLimits.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udd17</div>\n            <div className=\"empty-state-title\">No relationships</div>\n            <div className=\"empty-state-desc\">\n              This generator doesn&apos;t create any relationships. Add relationships to connect\n              entities.\n            </div>\n          </div>\n        ) : (\n          relationships.map((rel, index) => (\n            <RelationshipCard\n              key={index}\n              rel={rel}\n              onChange={(updated) => {\n                const newRels = [...relationships];\n                newRels[index] = updated;\n                onChange({ ...generator, relationships: newRels });\n              }}\n              onRemove={() =>\n                onChange({\n                  ...generator,\n                  relationships: relationships.filter((_, i) => i !== index),\n                })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Relationship\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "./RelationshipsTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema with entity/relationship kinds\n */\nexport function TargetTab({ generator, onChange, schema }) {\n  const selection = generator.selection || { strategy: \"by_kind\" };\n\n  // Get the kind of the first created entity for saturation limit inference\n  const firstCreatedKind = (generator.creation || [])[0]?.kind;\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Target Selection</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What is $target?</div>\n          <div className=\"info-box-text\">\n            The <code className=\"inline-code\">$target</code> is the primary entity this generator\n            operates on. It&apos;s selected from the world graph based on the rules you define here. Once\n            selected, you can reference it in creation rules (e.g., inherit culture from $target)\n            and relationships (e.g., connect new entity to $target).\n          </div>\n        </div>\n\n        <SelectionRuleEditor\n          value={selection}\n          onChange={(updated) => onChange({ ...generator, selection: updated })}\n          schema={schema}\n          availableRefs={[\"$target\", ...Object.keys(generator.variables || {})]}\n        />\n\n        {/* Saturation Limits */}\n        <div className=\"mt-2xl\">\n          <span className=\"label\">Saturation Limits</span>\n          <div className=\"info-box-text mb-lg text-sm\">\n            Limit targets based on existing relationship counts. Only targets with fewer than the\n            max count of relationships will be selected.\n          </div>\n          <SaturationLimitsEditor\n            limits={selection.saturationLimits || []}\n            onChange={(limits) =>\n              onChange({\n                ...generator,\n                selection: {\n                  ...selection,\n                  saturationLimits: limits.length > 0 ? limits : undefined,\n                },\n              })\n            }\n            schema={schema}\n            createdKind={firstCreatedKind}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "../../shared/SelectionRuleEditor", "specifiers": ["SelectionRuleEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx", "sourceCode": "// ============================================================================\n// VariablesTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function VariablesTab({ generator, onChange, schema }) {\n  const variables = generator.variables || {};\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddForm, setShowAddForm] = useState(false);\n\n  // Build available refs for relationship queries (target + other vars + creation refs)\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$target\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef && !refs.includes(c.entityRef)) refs.push(c.entityRef);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    // Ensure the name starts with $\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    // Create with empty required fields - validation will flag them\n    onChange({\n      ...generator,\n      variables: {\n        ...variables,\n        [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"\" } },\n      },\n    });\n    setNewVarName(\"\");\n    setShowAddForm(false);\n  };\n\n  const varEntries = Object.entries(variables);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Variables</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What are variables?</div>\n          <div className=\"info-box-text\">\n            Variables let you select additional entities from the graph to use in creation and\n            relationships. For example, you might select a{\" \"}\n            <code className=\"inline-code\">$faction</code> to make a new NPC a member of, or an{\" \"}\n            <code className=\"inline-code\">$ability</code> for them to practice. Variables are\n            selected after <code className=\"inline-code\">$target</code> is chosen.\n          </div>\n        </div>\n\n        {varEntries.length === 0 && !showAddForm ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udce6</div>\n            <div className=\"empty-state-title\">No variables defined</div>\n            <div className=\"empty-state-desc\">\n              Add variables to select additional entities for use in creation and relationships.\n            </div>\n          </div>\n        ) : (\n          varEntries.map(([name, config]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={config}\n              onChange={(updated) =>\n                onChange({ ...generator, variables: { ...variables, [name]: updated } })\n              }\n              onRemove={() => {\n                const newVars = { ...variables };\n                delete newVars[name];\n                onChange({ ...generator, variables: newVars });\n              }}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared/VariableSelectionEditor", "specifiers": ["VariableSelectionEditor"], "category": "internal"}, {"source": "./VariablesTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/analyzeNamingMappings.js::analyzeNamingMappings", "name": "analyzeNamingMappings", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/analyzeNamingMappings.js", "sourceCode": "export function analyzeNamingMappings(generators, schema) {\n  const mappings = [];\n  const warnings = [];\n\n  // Build culture lookup\n  const culturesById = {};\n  (schema.cultures || []).forEach((c) => {\n    culturesById[c.id] = c;\n  });\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    if (!gen.creation || gen.creation.length === 0) continue;\n\n    for (const creation of gen.creation) {\n      const entityKind = creation.kind;\n      // Subtype can be a string or object - ensure we get a string\n      const subtype = typeof creation.subtype === \"string\" ? creation.subtype : null;\n      const prominence = creation.prominence;\n      const tags = creation.tags ? Object.keys(creation.tags) : [];\n\n      // Determine culture source\n      let cultureSource = null;\n      let cultureIds = [];\n\n      if (creation.culture) {\n        if (typeof creation.culture === \"string\") {\n          cultureIds = [creation.culture];\n          cultureSource = \"explicit\";\n        } else if (creation.culture.inherit) {\n          cultureSource = \"inherited\";\n          // Culture is inherited from target - could be any culture\n          cultureIds = Object.keys(culturesById);\n        } else if (creation.culture.from) {\n          cultureSource = \"reference\";\n          cultureIds = Object.keys(culturesById);\n        }\n      } else {\n        // No culture specified - could be any\n        cultureSource = \"any\";\n        cultureIds = Object.keys(culturesById);\n      }\n\n      // Check each possible culture for naming profile match\n      for (const cultureId of cultureIds) {\n        const culture = culturesById[cultureId];\n        const namingConfig = culture?.naming;\n        const hasProfiles = !!namingConfig?.profiles?.length;\n        const match = hasProfiles\n          ? findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags)\n          : null;\n\n        mappings.push({\n          generatorId: gen.id,\n          generatorName: gen.name || gen.id,\n          entityKind,\n          subtype,\n          prominence,\n          cultureId,\n          cultureName: culture?.name || cultureId,\n          cultureColor: culture?.color || \"#888\",\n          cultureSource,\n          hasNamingProfile: hasProfiles,\n          match,\n        });\n\n        // Add warning if no match found\n        if (!match && hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"No matching strategy group\",\n          });\n        } else if (!hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"Culture has no naming profiles\",\n          });\n        }\n      }\n    }\n  }\n\n  return { mappings, warnings };\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}], "returnType": "{ mappings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; prominence: any; cultureId: any; cultureName: any; cultureColor: any; cultureSource: string; hasNamingProfile: boolean; match: { profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }; }[]; warnings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; cultureId: any; cultureName: any; cultureSource: string; reason: string; }[]; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./findMatchingProfile", "specifiers": ["findMatchingProfile"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/findMatchingProfile.js::findMatchingProfile", "name": "findMatchingProfile", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/findMatchingProfile.js", "sourceCode": "/**\n * Find which naming profile strategy group matches a given entity creation\n */\n\nexport function findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags = []) {\n  if (!namingConfig?.profiles) return null;\n\n  for (const profile of namingConfig.profiles) {\n    for (const group of profile.strategyGroups || []) {\n      const cond = group.conditions || {};\n\n      // Check entity kind\n      if (cond.entityKinds?.length > 0 && !cond.entityKinds.includes(entityKind)) {\n        continue;\n      }\n\n      // Check subtype\n      if (cond.subtypes?.length > 0) {\n        // Check if subtype matches (same logic for matchAll or matchAny on single entity)\n        if (!subtype || !cond.subtypes.includes(subtype)) continue;\n      }\n\n      // Check prominence\n      if (cond.prominence?.length > 0 && !cond.prominence.includes(prominence)) {\n        continue;\n      }\n\n      // Check tags\n      if (cond.tags?.length > 0) {\n        const entityTags = Array.isArray(tags) ? tags : Object.keys(tags || {});\n        if (cond.tagMatchAll) {\n          // All tags must be present\n          if (!cond.tags.every((t) => entityTags.includes(t))) continue;\n        } else {\n          // Any tag matches\n          if (!cond.tags.some((t) => entityTags.includes(t))) continue;\n        }\n      }\n\n      // Found a match!\n      return {\n        profileId: profile.id,\n        profileName: profile.name,\n        groupName: group.name,\n        strategy: group.strategy,\n        grammarId: group.grammarId,\n      };\n    }\n  }\n\n  return null;\n}", "parameters": [{"name": "namingConfig", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}, {"name": "subtype", "type": "any", "optional": false}, {"name": "prominence", "type": "any", "optional": false}, {"name": "tags", "type": "any[]", "optional": true}], "returnType": "{ profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js::findMatchingProfile", "name": "findMatchingProfile", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js", "sourceCode": "/**\n * Find which naming profile strategy group matches a given entity creation\n */\n\nexport function findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags = []) {\n  if (!namingConfig?.profiles) return null;\n\n  for (const profile of namingConfig.profiles) {\n    for (const group of profile.strategyGroups || []) {\n      const cond = group.conditions || {};\n\n      // Check entity kind\n      if (cond.entityKinds?.length > 0 && !cond.entityKinds.includes(entityKind)) {\n        continue;\n      }\n\n      // Check subtype\n      if (cond.subtypes?.length > 0) {\n        // Check if subtype matches (same logic for matchAll or matchAny on single entity)\n        if (!subtype || !cond.subtypes.includes(subtype)) continue;\n      }\n\n      // Check prominence\n      if (cond.prominence?.length > 0 && !cond.prominence.includes(prominence)) {\n        continue;\n      }\n\n      // Check tags\n      if (cond.tags?.length > 0) {\n        const entityTags = Array.isArray(tags) ? tags : Object.keys(tags || {});\n        if (cond.tagMatchAll) {\n          // All tags must be present\n          if (!cond.tags.every((t) => entityTags.includes(t))) continue;\n        } else {\n          // Any tag matches\n          if (!cond.tags.some((t) => entityTags.includes(t))) continue;\n        }\n      }\n\n      // Found a match!\n      return {\n        profileId: profile.id,\n        profileName: profile.name,\n        groupName: group.name,\n        strategy: group.strategy,\n        grammarId: group.grammarId,\n      };\n    }\n  }\n\n  return null;\n}", "parameters": [{"name": "namingConfig", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}, {"name": "subtype", "type": "any", "optional": false}, {"name": "prominence", "type": "any", "optional": false}, {"name": "tags", "type": "any[]", "optional": true}], "returnType": "{ profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js::analyzeNamingMappings", "name": "analyzeNamingMappings", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js", "sourceCode": "export function analyzeNamingMappings(generators, schema) {\n  const mappings = [];\n  const warnings = [];\n\n  // Build culture lookup\n  const culturesById = {};\n  (schema.cultures || []).forEach((c) => {\n    culturesById[c.id] = c;\n  });\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    if (!gen.creation || gen.creation.length === 0) continue;\n\n    for (const creation of gen.creation) {\n      const entityKind = creation.kind;\n      // Subtype can be a string or object - ensure we get a string\n      const subtype = typeof creation.subtype === \"string\" ? creation.subtype : null;\n      const prominence = creation.prominence;\n      const tags = creation.tags ? Object.keys(creation.tags) : [];\n\n      // Determine culture source\n      let cultureSource = null;\n      let cultureIds = [];\n\n      if (creation.culture) {\n        if (typeof creation.culture === \"string\") {\n          cultureIds = [creation.culture];\n          cultureSource = \"explicit\";\n        } else if (creation.culture.inherit) {\n          cultureSource = \"inherited\";\n          // Culture is inherited from target - could be any culture\n          cultureIds = Object.keys(culturesById);\n        } else if (creation.culture.from) {\n          cultureSource = \"reference\";\n          cultureIds = Object.keys(culturesById);\n        }\n      } else {\n        // No culture specified - could be any\n        cultureSource = \"any\";\n        cultureIds = Object.keys(culturesById);\n      }\n\n      // Check each possible culture for naming profile match\n      for (const cultureId of cultureIds) {\n        const culture = culturesById[cultureId];\n        const namingConfig = culture?.naming;\n        const hasProfiles = !!namingConfig?.profiles?.length;\n        const match = hasProfiles\n          ? findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags)\n          : null;\n\n        mappings.push({\n          generatorId: gen.id,\n          generatorName: gen.name || gen.id,\n          entityKind,\n          subtype,\n          prominence,\n          cultureId,\n          cultureName: culture?.name || cultureId,\n          cultureColor: culture?.color || \"#888\",\n          cultureSource,\n          hasNamingProfile: hasProfiles,\n          match,\n        });\n\n        // Add warning if no match found\n        if (!match && hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"No matching strategy group\",\n          });\n        } else if (!hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"Culture has no naming profiles\",\n          });\n        }\n      }\n    }\n  }\n\n  return { mappings, warnings };\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}], "returnType": "{ mappings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; prominence: any; cultureId: any; cultureName: any; cultureColor: any; cultureSource: string; hasNamingProfile: boolean; match: { profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }; }[]; warnings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; cultureId: any; cultureName: any; cultureSource: string; reason: string; }[]; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::formatValidationForExport", "name": "formatValidationForExport", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "/**\n * Export functions for validation results\n */\n\nexport function formatValidationForExport(validationResults) {\n  const items = [];\n\n  // Process errors\n  for (const error of validationResults.errors) {\n    for (const item of error.affectedItems) {\n      items.push({\n        severity: \"ERROR\",\n        category: error.id,\n        title: error.title,\n        message: error.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  // Process warnings\n  for (const warning of validationResults.warnings) {\n    for (const item of warning.affectedItems) {\n      items.push({\n        severity: \"WARNING\",\n        category: warning.id,\n        title: warning.title,\n        message: warning.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  return items;\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "{ severity: string; category: any; title: any; message: any; itemId: any; itemLabel: any; detail: any; }[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::exportAsJson", "name": "exportAsJson", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "export function exportAsJson(validationResults) {\n  const items = formatValidationForExport(validationResults);\n  const json = JSON.stringify(\n    {\n      exportedAt: new Date().toISOString(),\n      summary: {\n        errorCount: validationResults.errors.length,\n        warningCount: validationResults.warnings.length,\n        totalItems: items.length,\n      },\n      issues: items,\n    },\n    null,\n    2\n  );\n\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.json`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::exportAsCsv", "name": "exportAsCsv", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "export function exportAsCsv(validationResults) {\n  const items = formatValidationForExport(validationResults);\n\n  // CSV header\n  const headers = [\"Severity\", \"Category\", \"Title\", \"Message\", \"Item ID\", \"Item Label\", \"Detail\"];\n\n  // Escape CSV field\n  const escapeField = (field) => {\n    const str = String(field || \"\");\n    if (str.includes(\",\") || str.includes('\"') || str.includes(\"\\n\")) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n\n  // Build CSV rows\n  const rows = [\n    headers.join(\",\"),\n    ...items.map((item) =>\n      [\n        item.severity,\n        item.category,\n        escapeField(item.title),\n        escapeField(item.message),\n        escapeField(item.itemId),\n        escapeField(item.itemLabel),\n        escapeField(item.detail),\n      ].join(\",\")\n    ),\n  ];\n\n  const csv = rows.join(\"\\n\");\n  const blob = new Blob([csv], { type: \"text/csv\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.csv`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::formatValidationForExport", "name": "formatValidationForExport", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "/**\n * Export functions for validation results\n */\n\nexport function formatValidationForExport(validationResults) {\n  const items = [];\n\n  // Process errors\n  for (const error of validationResults.errors) {\n    for (const item of error.affectedItems) {\n      items.push({\n        severity: \"ERROR\",\n        category: error.id,\n        title: error.title,\n        message: error.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  // Process warnings\n  for (const warning of validationResults.warnings) {\n    for (const item of warning.affectedItems) {\n      items.push({\n        severity: \"WARNING\",\n        category: warning.id,\n        title: warning.title,\n        message: warning.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  return items;\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "{ severity: string; category: any; title: any; message: any; itemId: any; itemLabel: any; detail: any; }[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::exportAsJson", "name": "exportAsJson", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function exportAsJson(validationResults) {\n  const items = formatValidationForExport(validationResults);\n  const json = JSON.stringify(\n    {\n      exportedAt: new Date().toISOString(),\n      summary: {\n        errorCount: validationResults.errors.length,\n        warningCount: validationResults.warnings.length,\n        totalItems: items.length,\n      },\n      issues: items,\n    },\n    null,\n    2\n  );\n\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.json`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::exportAsCsv", "name": "exportAsCsv", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function exportAsCsv(validationResults) {\n  const items = formatValidationForExport(validationResults);\n\n  // CSV header\n  const headers = [\"Severity\", \"Category\", \"Title\", \"Message\", \"Item ID\", \"Item Label\", \"Detail\"];\n\n  // Escape CSV field\n  const escapeField = (field) => {\n    const str = String(field || \"\");\n    if (str.includes(\",\") || str.includes('\"') || str.includes(\"\\n\")) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n\n  // Build CSV rows\n  const rows = [\n    headers.join(\",\"),\n    ...items.map((item) =>\n      [\n        item.severity,\n        item.category,\n        escapeField(item.title),\n        escapeField(item.message),\n        escapeField(item.itemId),\n        escapeField(item.itemLabel),\n        escapeField(item.detail),\n      ].join(\",\")\n    ),\n  ];\n\n  const csv = rows.join(\"\\n\");\n  const blob = new Blob([csv], { type: \"text/csv\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.csv`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::runValidations", "name": "runValidations", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "/**\n * Run all validations\n * @param {Object} usageMap - Pre-computed usage map from computeUsageMap\n * @param {Object} schema - Domain schema\n * @param {Array} eras - Era configurations\n * @param {Array} pressures - Pressure configurations\n * @param {Array} generators - Generator configurations\n * @param {Array} systems - System configurations\n */\nexport function runValidations(usageMap, schema, eras, pressures, generators, systems) {\n  const results = {\n    errors: [],\n    warnings: [],\n  };\n\n  // Run each validation rule\n  // Rules that use usageMap only\n  const usageMapRules = [\n    () => validationRules.invalidEntityKind(usageMap),\n    () => validationRules.invalidRelationshipKind(usageMap),\n    () => validationRules.invalidPressureId(usageMap),\n    () => validationRules.invalidEraTemplateRef(usageMap),\n    () => validationRules.invalidEraSystemRef(usageMap),\n    () => validationRules.orphanGenerators(usageMap),\n    () => validationRules.orphanSystems(usageMap),\n    () => validationRules.relationshipCompatibility(usageMap),\n  ];\n\n  // Rules that need additional data\n  const dataRules = [\n    () => validationRules.pressureWithoutSources(usageMap, pressures, generators, systems),\n    () => validationRules.pressureWithoutSinks(usageMap, pressures, generators, systems),\n    () => validationRules.zeroWeightGenerators(usageMap, eras, generators),\n    () => validationRules.invalidSubtypeRef(usageMap, schema, generators, pressures),\n    () => validationRules.invalidStatusRef(usageMap, schema, generators),\n    () => validationRules.invalidCultureRef(usageMap, schema),\n    () => validationRules.undefinedTagRefs(usageMap, schema),\n    () => validationRules.conflictingTagsInUse(usageMap, schema, generators),\n    () => validationRules.numericRangeIssues(usageMap, pressures, eras),\n  ];\n\n  const allRules = [...usageMapRules, ...dataRules];\n\n  for (const rule of allRules) {\n    const result = rule();\n    if (result) {\n      if (result.severity === \"error\") {\n        results.errors.push(result);\n      } else {\n        results.warnings.push(result);\n      }\n    }\n  }\n\n  return results;\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any[]", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}, {"name": "generators", "type": "any[]", "optional": false}, {"name": "systems", "type": "any[]", "optional": false}], "returnType": "{ errors: any[]; warnings: any[]; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::getOverallStatus", "name": "getOverallStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function getOverallStatus(results) {\n  if (results.errors.length > 0) return \"error\";\n  if (results.warnings.length > 0) return \"warning\";\n  return \"clean\";\n}", "parameters": [{"name": "results", "type": "any", "optional": false}], "returnType": "\"error\" | \"warning\" | \"clean\"", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js::runValidations", "name": "runValidations", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js", "sourceCode": "/**\n * Run all validations\n * @param {Object} usageMap - Pre-computed usage map from computeUsageMap\n * @param {Object} schema - Domain schema\n * @param {Array} eras - Era configurations\n * @param {Array} pressures - Pressure configurations\n * @param {Array} generators - Generator configurations\n * @param {Array} systems - System configurations\n */\nexport function runValidations(usageMap, schema, eras, pressures, generators, systems) {\n  const results = {\n    errors: [],\n    warnings: [],\n  };\n\n  // Run each validation rule\n  // Rules that use usageMap only\n  const usageMapRules = [\n    () => validationRules.invalidEntityKind(usageMap),\n    () => validationRules.invalidRelationshipKind(usageMap),\n    () => validationRules.invalidPressureId(usageMap),\n    () => validationRules.invalidEraTemplateRef(usageMap),\n    () => validationRules.invalidEraSystemRef(usageMap),\n    () => validationRules.orphanGenerators(usageMap),\n    () => validationRules.orphanSystems(usageMap),\n    () => validationRules.relationshipCompatibility(usageMap),\n  ];\n\n  // Rules that need additional data\n  const dataRules = [\n    () => validationRules.pressureWithoutSources(usageMap, pressures, generators, systems),\n    () => validationRules.pressureWithoutSinks(usageMap, pressures, generators, systems),\n    () => validationRules.zeroWeightGenerators(usageMap, eras, generators),\n    () => validationRules.invalidSubtypeRef(usageMap, schema, generators, pressures),\n    () => validationRules.invalidStatusRef(usageMap, schema, generators),\n    () => validationRules.invalidCultureRef(usageMap, schema),\n    () => validationRules.undefinedTagRefs(usageMap, schema),\n    () => validationRules.conflictingTagsInUse(usageMap, schema, generators),\n    () => validationRules.numericRangeIssues(usageMap, pressures, eras),\n  ];\n\n  const allRules = [...usageMapRules, ...dataRules];\n\n  for (const rule of allRules) {\n    const result = rule();\n    if (result) {\n      if (result.severity === \"error\") {\n        results.errors.push(result);\n      } else {\n        results.warnings.push(result);\n      }\n    }\n  }\n\n  return results;\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any[]", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}, {"name": "generators", "type": "any[]", "optional": false}, {"name": "systems", "type": "any[]", "optional": false}], "returnType": "{ errors: any[]; warnings: any[]; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js::getOverallStatus", "name": "getOverallStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js", "sourceCode": "export function getOverallStatus(results) {\n  if (results.errors.length > 0) return \"error\";\n  if (results.warnings.length > 0) return \"warning\";\n  return \"clean\";\n}", "parameters": [{"name": "results", "type": "any", "optional": false}], "returnType": "\"error\" | \"warning\" | \"clean\"", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/DomainTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/DomainTab.jsx", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["NumberInput"], "category": "external"}, {"source": "../../utils", "specifiers": ["getAllDomains"], "category": "internal"}, {"source": "./PhonemeWeightGrid", "specifiers": ["PhonemeWeightGrid"], "category": "internal"}, {"source": "./DomainTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/GrammarsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/GrammarsTab.jsx", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../constants", "specifiers": ["MARKOV_MODELS", "CONTEXT_KEYS", "COMMON_LITERALS", "GRAMMAR_MODIFIERS"], "category": "internal"}, {"source": "../../../lib/browser-generator", "specifiers": ["previewGrammarNames"], "category": "internal"}, {"source": "./CopyGrammarModal", "specifiers": ["CopyGrammarModal"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/LexemesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/LexemesTab.jsx", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["NumberInput"], "category": "external"}, {"source": "../../constants", "specifiers": ["LEXEME_CATEGORIES", "WORD_STYLE_PRESETS"], "category": "internal"}, {"source": "../../../lib/anthropicClient", "specifiers": ["generateLexemesWithAnthropic"], "category": "internal"}, {"source": "./CopyLexemeModal", "specifiers": ["CopyLexemeModal"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/PhonemeWeightGrid.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/PhonemeWeightGrid.jsx", "sourceCode": "/**\n * Visual grid editor for phoneme weights\n * Shows each phoneme with its corresponding weight and a visual bar\n */\n\nfunction PhonemeWeightGrid({\n  label,\n  items,\n  weights,\n  onChange,\n  minWeight = 0.1,\n  maxWeight = 3.0\n}) {\n  const [editingIndex, setEditingIndex] = useState(null);\n  const [editValue, setEditValue] = useState(\"\");\n\n  // Ensure weights array matches items length\n  const normalizedWeights = items.map((_, i) => weights?.[i] ?? 1.0);\n\n  // Calculate max for visual scaling\n  const maxVal = Math.max(...normalizedWeights, 1);\n  const handleCellClick = index => {\n    setEditingIndex(index);\n    setEditValue(normalizedWeights[index].toString());\n  };\n  const handleBlur = () => {\n    if (editingIndex !== null) {\n      const newValue = parseFloat(editValue);\n      if (!isNaN(newValue) && newValue >= minWeight && newValue <= maxWeight) {\n        const newWeights = [...normalizedWeights];\n        newWeights[editingIndex] = Math.round(newValue * 100) / 100;\n        onChange(newWeights);\n      }\n      setEditingIndex(null);\n    }\n  };\n  const handleKeyDown = e => {\n    if (e.key === \"Enter\") {\n      handleBlur();\n    } else if (e.key === \"Escape\") {\n      setEditingIndex(null);\n    }\n  };\n  const handleReset = () => {\n    onChange(items.map(() => 1.0));\n  };\n  if (items.length === 0) {\n    return <div className=\"weight-grid-section\">\n        <div className=\"weight-grid-header\">\n          <span className=\"weight-grid-label\">{label}</span>\n        </div>\n        <div className=\"weight-grid-empty\">\n          No items defined. Add {label.toLowerCase().replace(\" weights\", \"s\")} in Phonology section.\n        </div>\n      </div>;\n  }\n  return <div className=\"weight-grid-section\">\n      <div className=\"weight-grid-header\">\n        <span className=\"weight-grid-label\">{label}</span>\n        <button type=\"button\" className=\"weight-grid-reset\" onClick={handleReset} title=\"Reset all to 1.0\">\n          Reset\n        </button>\n      </div>\n      <div className=\"weight-grid\">\n        {items.map((item, index) => {\n        const weight = normalizedWeights[index];\n        const barHeight = weight / maxVal * 100;\n        const isEditing = editingIndex === index;\n\n        // Color based on weight: low=cool, normal=neutral, high=warm\n        let hue;\n        if (weight < 1) hue = 200;else if (weight > 1) hue = 30;else hue = 150;\n        const saturation = Math.abs(weight - 1) * 50 + 20;\n        return <div key={index} className={`weight-cell ${isEditing ? \"editing\" : \"\"}`} onClick={() => !isEditing && handleCellClick(index)} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n              <div className=\"weight-cell-item\" title={item}>\n                {item}\n              </div>\n              {isEditing ? <input type=\"number\" className=\"weight-cell-input\" value={editValue} onChange={e => setEditValue(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} step=\"0.1\" min={minWeight} max={maxWeight}\n          // eslint-disable-next-line jsx-a11y/no-autofocus\n          autoFocus /> : <div className=\"weight-cell-value\">{weight.toFixed(1)}</div>}\n              <div className=\"weight-cell-bar-container\">\n                <div className=\"weight-cell-bar pwg-bar\" style={{\n              '--pwg-bar-height': `${barHeight}%`,\n              '--pwg-bar-color': `hsl(${hue}, ${saturation}%, 50%)`\n            }} />\n              </div>\n            </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  label,\n  items,\n  weights,\n  onChange,\n  minWeight = 0.1,\n  maxWeight = 3.0\n}", "type": "{ label: any; items: any; weights: any; onChange: any; minWeight?: number; maxWeight?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./PhonemeWeightGrid.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/ProfileTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/ProfileTab.jsx", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::findMatchingGenerators", "name": "findMatchingGenerators", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Analyze which generators will match a specific strategy group's conditions\n */\nexport function findMatchingGenerators(generators, cultureId, conditions) {\n  if (!generators || generators.length === 0) return [];\n\n  const matches = [];\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    const creations = gen.creation || [];\n    const genName = gen.name || gen.id;\n\n    for (const creation of creations) {\n      if (!creationMatchesCulture(creation, cultureId)) continue;\n\n      const match = matchCreationToConditions(creation, conditions, gen.id, genName);\n      if (match) matches.push(match);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "conditions", "type": "any", "optional": false}], "returnType": "{ generatorId: any; generatorName: any; entityKind: any; subtype: any; isDefault: boolean; }[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::computeProfileGeneratorUsage", "name": "computeProfileGeneratorUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Compute generator usage for all profiles in a culture\n */\nexport function computeProfileGeneratorUsage(profiles, generators, cultureId) {\n  const usage = {};\n\n  for (const profile of profiles) {\n    usage[profile.id] = {\n      totalMatches: 0,\n      groups: {},\n    };\n\n    for (const group of profile.strategyGroups || []) {\n      const matches = findMatchingGenerators(generators, cultureId, group.conditions);\n      usage[profile.id].groups[group.name || \"Default\"] = matches;\n      usage[profile.id].totalMatches += matches.length;\n    }\n  }\n\n  return usage;\n}", "parameters": [{"name": "profiles", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/MultiSelectPills.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/MultiSelectPills.jsx", "sourceCode": "/**\n * Multi-select pills component for selecting multiple options\n * Note: Consider replacing with ChipSelect from shared-components in future\n */\nexport default function MultiSelectPills({ options, selected, onChange, allLabel = \"All\" }) {\n  const isAllSelected = selected.length === 0 || (selected.length === 1 && selected[0] === \"*\");\n\n  const handleToggle = (value) => {\n    if (value === \"*\") {\n      onChange([]);\n    } else {\n      const newSelected = selected.filter((s) => s !== \"*\");\n      if (newSelected.includes(value)) {\n        const filtered = newSelected.filter((s) => s !== value);\n        onChange(filtered.length === 0 ? [] : filtered);\n      } else {\n        onChange([...newSelected, value]);\n      }\n    }\n  };\n\n  return (\n    <div className=\"flex flex-wrap gap-xs\">\n      <button\n        type=\"button\"\n        onClick={() => handleToggle(\"*\")}\n        className={`pill-button ${isAllSelected ? \"selected-gold\" : \"\"}`}\n      >\n        {allLabel}\n      </button>\n      {options.map((opt) => {\n        const isSelected = !isAllSelected && selected.includes(opt);\n        return (\n          <button\n            key={opt}\n            type=\"button\"\n            onClick={() => handleToggle(opt)}\n            className={`pill-button ${isSelected ? \"selected-green\" : \"\"}`}\n          >\n            {opt}\n          </button>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ options, selected, onChange, allLabel = \"All\" }", "type": "{ options: any; selected: any; onChange: any; allLabel?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileModal.jsx", "sourceCode": "export default function ProfileModal({\n  profile,\n  isNew,\n  onSave,\n  onClose,\n  onDelete,\n  onDuplicate,\n  cultureConfig,\n  worldSchema,\n  onAddTag,\n  generatorUsage,\n}) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n  const [editedProfile, setEditedProfile] = useState(null);\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedRef = useRef(null);\n\n  // Initialize edited profile\n  useEffect(() => {\n    if (profile) {\n      setEditedProfile(JSON.parse(JSON.stringify(profile)));\n      lastSavedRef.current = JSON.stringify(profile);\n    }\n  }, [profile]);\n\n  // Autosave effect\n  useEffect(() => {\n    if (!editedProfile) return;\n\n    const profileStr = JSON.stringify(editedProfile);\n    if (profileStr === lastSavedRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      handleSave(editedProfile);\n      lastSavedRef.current = profileStr;\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [editedProfile]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Build dynamic tabs based on strategy groups\n  const tabs = useMemo(() => {\n    if (!editedProfile) return [];\n\n    const dynamicTabs = [{ id: \"overview\", label: \"Overview\", icon: \"\ud83d\udccb\" }];\n\n    // Add a tab for each strategy group\n    (editedProfile.strategyGroups || []).forEach((group, idx) => {\n      const isConditional = !!group.conditions;\n      dynamicTabs.push({\n        id: `group-${idx}`,\n        label: group.name || `Group ${idx + 1}`,\n        icon: isConditional ? \"\ud83c\udfaf\" : \"\ud83d\udce6\",\n      });\n    });\n\n    dynamicTabs.push({ id: \"test\", label: \"Test\", icon: \"\ud83e\uddea\" });\n\n    return dynamicTabs;\n  }, [editedProfile]);\n\n  const handleSave = (profileToSave) => {\n    // Normalize weights within each group\n    const normalizedGroups = (profileToSave.strategyGroups || []).map((group) => {\n      const totalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n      return {\n        ...group,\n        strategies: group.strategies.map((s) => ({\n          ...s,\n          weight:\n            totalWeight > 0 ? s.weight / totalWeight : 1 / Math.max(group.strategies.length, 1),\n        })),\n      };\n    });\n\n    const updatedProfile = {\n      ...profileToSave,\n      strategyGroups: normalizedGroups,\n    };\n\n    onSave(updatedProfile, isNew);\n  };\n\n  const handleClose = () => {\n    // Save any pending changes before closing\n    if (editedProfile && JSON.stringify(editedProfile) !== lastSavedRef.current) {\n      handleSave(editedProfile);\n    }\n    onClose();\n  };\n\n  const handleDelete = () => {\n    if (confirm(`Delete profile \"${editedProfile?.id}\"?`)) {\n      onDelete(editedProfile?.id);\n      onClose();\n    }\n  };\n\n  const handleDuplicate = () => {\n    // Save any pending changes first\n    if (editedProfile && JSON.stringify(editedProfile) !== lastSavedRef.current) {\n      handleSave(editedProfile);\n    }\n    onDuplicate(editedProfile);\n  };\n\n  const handleAddGroup = (withConditions = false) => {\n    const newGroup = {\n      name: withConditions ? \"Conditional\" : \"Default\",\n      priority: withConditions ? 50 : 0,\n      conditions: withConditions\n        ? {\n            entityKinds: [],\n            prominence: [],\n            subtypes: [],\n            subtypeMatchAll: false,\n            tags: [],\n            tagMatchAll: false,\n          }\n        : null,\n      strategies: [],\n    };\n    const updated = {\n      ...editedProfile,\n      strategyGroups: [...(editedProfile.strategyGroups || []), newGroup],\n    };\n    setEditedProfile(updated);\n    // Switch to the new group's tab\n    setActiveTab(`group-${updated.strategyGroups.length - 1}`);\n  };\n\n  const handleDeleteGroup = (groupIdx) => {\n    const updated = {\n      ...editedProfile,\n      strategyGroups: editedProfile.strategyGroups.filter((_, i) => i !== groupIdx),\n    };\n    setEditedProfile(updated);\n    // Switch to overview if we deleted the current tab\n    if (activeTab === `group-${groupIdx}`) {\n      setActiveTab(\"overview\");\n    }\n  };\n\n  const handleGroupChange = (groupIdx, updatedGroup) => {\n    const groups = [...editedProfile.strategyGroups];\n    groups[groupIdx] = updatedGroup;\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  if (!editedProfile) return null;\n\n  const naming = cultureConfig?.naming || {};\n  const domains = naming.domains || [];\n  const grammars = naming.grammars || [];\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  const renderTabContent = () => {\n    if (activeTab === \"overview\") {\n      return (\n        <OverviewTab\n          profile={editedProfile}\n          onChange={setEditedProfile}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          onNavigateToGroup={(idx) => setActiveTab(`group-${idx}`)}\n          generatorUsage={generatorUsage}\n          entityKinds={entityKinds}\n        />\n      );\n    }\n\n    if (activeTab === \"test\") {\n      return <TestTab profile={editedProfile} cultureConfig={cultureConfig} />;\n    }\n\n    // Check if it's a group tab\n    if (activeTab.startsWith(\"group-\")) {\n      const groupIdx = parseInt(activeTab.replace(\"group-\", \"\"), 10);\n      const group = editedProfile.strategyGroups?.[groupIdx];\n      if (group) {\n        return (\n          <SingleGroupTab\n            group={group}\n            groupIdx={groupIdx}\n            onChange={(updated) => handleGroupChange(groupIdx, updated)}\n            onDelete={() => handleDeleteGroup(groupIdx)}\n            domains={domains}\n            grammars={grammars}\n            entityKinds={entityKinds}\n            worldSchema={worldSchema}\n            tagRegistry={tagRegistry}\n            onAddTag={onAddTag}\n          />\n        );\n      }\n    }\n\n    return null;\n  };\n\n  // Sidebar footer with add group buttons\n  const renderSidebarFooter = () => (\n    <div className=\"profile-modal-footer\">\n      <button\n        className=\"add-group-btn\"\n        onClick={() => handleAddGroup(false)}\n        title=\"Add default group\"\n      >\n        + Default\n      </button>\n      <button\n        className=\"add-group-btn conditional\"\n        onClick={() => handleAddGroup(true)}\n        title=\"Add conditional group\"\n      >\n        + Conditional\n      </button>\n    </div>\n  );\n\n  return (\n    <ModalShell\n      onClose={handleClose}\n      icon=\"\ud83d\udcdd\"\n      title={isNew ? \"New Profile\" : editedProfile.id}\n      tabs={tabs}\n      activeTab={activeTab}\n      onTabChange={setActiveTab}\n      sidebarFooter={renderSidebarFooter()}\n      className=\"profile-modal\"\n    >\n      {renderTabContent()}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  isNew,\n  onSave,\n  onClose,\n  onDelete,\n  onDuplicate,\n  cultureConfig,\n  worldSchema,\n  onAddTag,\n  generatorUsage,\n}", "type": "{ profile: any; isNew: any; onSave: any; onClose: any; onDelete: any; onDuplicate: any; cultureConfig: any; worldSchema: any; onAddTag: any; generatorUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useRef", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "./tabs", "specifiers": ["OverviewTab", "SingleGroupTab", "TestTab"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileTab.jsx", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./utils", "specifiers": ["computeProfileGeneratorUsage"], "category": "internal"}, {"source": "./ProfileModal", "specifiers": ["ProfileModal"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/StrategyGroupEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/StrategyGroupEditor.jsx", "sourceCode": "/**\n * Strategy group editor component\n */\nexport default function StrategyGroupEditor({\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}) {\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n  const hasConditions = !!group.conditions;\n\n  const toggleConditions = () => {\n    const groups = [...editedProfile.strategyGroups];\n    if (hasConditions) {\n      groups[groupIdx] = { ...groups[groupIdx], conditions: null };\n    } else {\n      groups[groupIdx] = {\n        ...groups[groupIdx],\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      };\n    }\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  return (\n    <div className={`strategy-group ${hasConditions ? \"conditional\" : \"default\"}`}>\n      <div className=\"flex justify-between align-center mb-md\">\n        <div className=\"flex align-center gap-md\">\n          <input\n            value={group.name || \"\"}\n            onChange={(e) => {\n              const groups = [...editedProfile.strategyGroups];\n              groups[groupIdx] = { ...groups[groupIdx], name: e.target.value };\n              setEditedProfile({ ...editedProfile, strategyGroups: groups });\n            }}\n            placeholder=\"Group name\"\n            className=\"input-group-name\"\n          />\n          <div className=\"flex align-center gap-xs\">\n            <label className=\"text-xs text-muted\">Priority:\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => {\n                const groups = [...editedProfile.strategyGroups];\n                groups[groupIdx] = { ...groups[groupIdx], priority: v ?? 0 };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"input-priority\"\n              integer\n            />\n            </label>\n          </div>\n          <button className=\"secondary btn-xs\" onClick={toggleConditions}>\n            {hasConditions ? \"Remove Conditions\" : \"Add Conditions\"}\n          </button>\n        </div>\n        <button className=\"danger text-xs\" onClick={() => onDeleteGroup(groupIdx)}>\n          Delete Group\n        </button>\n      </div>\n\n      {/* Group Conditions */}\n      {hasConditions && (\n        <div className=\"conditions-panel\">\n          <div className=\"text-xs font-bold text-purple mb-md\">Group Conditions</div>\n\n          {/* Row 1: Entity Types and Prominence */}\n          <div className=\"form-grid-2 mb-md\">\n            {/* Entity Types */}\n            <div>\n              <label className=\"condition-label\">Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => onConditionChange(groupIdx, \"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            {/* Prominence */}\n            <div>\n              <label className=\"condition-label\">Prominence\n              <MultiSelectPills\n                options={prominenceLevels}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => onConditionChange(groupIdx, \"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n          </div>\n\n          {/* Row 2: Subtypes and Tags */}\n          <div className=\"form-grid-2\">\n            {/* Subtypes */}\n            <div>\n              <div className=\"flex justify-between align-center mb-xs\">\n                <span className=\"condition-label mb-0\">Subtypes</span>\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) =>\n                      onConditionChange(groupIdx, \"subtypeMatchAll\", e.target.checked)\n                    }\n                    className=\"checkbox-small\"\n                  />\n                  Match all\n                </label>\n              </div>\n              <TagsInput\n                value={group.conditions?.subtypes || []}\n                onChange={(val) => onConditionChange(groupIdx, \"subtypes\", val)}\n                placeholder=\"Type and press space...\"\n              />\n            </div>\n\n            {/* Tags */}\n            <div>\n              <label className=\"condition-label\">Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => onConditionChange(groupIdx, \"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => onConditionChange(groupIdx, \"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Strategies */}\n      {group.strategies.length === 0 && (\n        <div className=\"text-muted text-small mb-sm\">No strategies. Add one below.</div>\n      )}\n\n      {group.strategies.map((strategy, stratIdx) => (\n        <div key={stratIdx} className={`strategy-card ${strategy.type}`}>\n          <div className=\"flex justify-between align-center mb-sm\">\n            <div className=\"flex align-center gap-sm\">\n              <strong className=\"capitalize text-small\">{strategy.type}</strong>\n              <span className=\"weight-badge\">\n                {groupTotalWeight > 0 ? ((strategy.weight / groupTotalWeight) * 100).toFixed(0) : 0}\n                %\n              </span>\n            </div>\n            <button className=\"danger btn-xs\" onClick={() => onDeleteStrategy(groupIdx, stratIdx)}>\n              Remove\n            </button>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.05\"\n            value={strategy.weight}\n            onChange={(e) => onWeightChange(groupIdx, stratIdx, e.target.value)}\n            className=\"strategy-slider\"\n          />\n\n          {strategy.type === \"phonotactic\" && (\n            <select\n              value={strategy.domainId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], domainId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select domain...</option>\n              {domains.map((d) => (\n                <option key={d.id} value={d.id}>\n                  {d.id}\n                </option>\n              ))}\n            </select>\n          )}\n\n          {strategy.type === \"grammar\" && (\n            <select\n              value={strategy.grammarId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], grammarId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select grammar...</option>\n              {grammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      ))}\n\n      <div className=\"flex gap-xs mt-sm\">\n        <button\n          className=\"secondary text-xs\"\n          onClick={() => onAddStrategy(groupIdx, \"phonotactic\")}\n        >\n          + Phonotactic\n        </button>\n        <button className=\"secondary text-xs\" onClick={() => onAddStrategy(groupIdx, \"grammar\")}>\n          + Grammar\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; domains: any; grammars: any; entityKinds: any; prominenceLevels: any; tagRegistry: any; editedProfile: any; setEditedProfile: any; onDeleteGroup: any; onAddStrategy: any; onDeleteStrategy: any; onWeightChange: any; onConditionChange: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector", "NumberInput"], "category": "external"}, {"source": "./MultiSelectPills", "specifiers": ["MultiSelectPills"], "category": "internal"}, {"source": "./TagsInput", "specifiers": ["TagsInput"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/TagsInput.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/TagsInput.jsx", "sourceCode": "/**\n * Tags input with auto-split on space/comma\n * Note: Consider using TagSelector from shared-components in future\n */\nexport default function TagsInput({ value, onChange, placeholder }) {\n  const tags = Array.isArray(value) ? value : [];\n\n  const handleKeyDown = (e) => {\n    if (e.key === \" \" || e.key === \",\" || e.key === \"Enter\") {\n      e.preventDefault();\n      const input = e.target.value.trim();\n      if (input && !tags.includes(input)) {\n        onChange([...tags, input]);\n      }\n      e.target.value = \"\";\n    } else if (e.key === \"Backspace\" && e.target.value === \"\" && tags.length > 0) {\n      onChange(tags.slice(0, -1));\n    }\n  };\n\n  const handleRemove = (tag) => {\n    onChange(tags.filter((t) => t !== tag));\n  };\n\n  return (\n    <div className=\"tags-input-container\">\n      {tags.map((tag) => (\n        <span key={tag} className=\"tag-chip\">\n          {tag}\n          <button type=\"button\" onClick={() => handleRemove(tag)} className=\"tag-remove-btn\">\n            x\n          </button>\n        </span>\n      ))}\n      <input\n        type=\"text\"\n        onKeyDown={handleKeyDown}\n        placeholder={tags.length === 0 ? placeholder : \"\"}\n        className=\"tags-input\"\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ value, onChange, placeholder }", "type": "{ value: any; onChange: any; placeholder: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/TestPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/TestPanel.jsx", "sourceCode": "/**\n * Test panel for generating test names from a profile\n */\nexport default function TestPanel({\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}) {\n  return (\n    <div className=\"test-panel\">\n      <div className=\"flex justify-between align-center mb-md\">\n        <h4 className=\"mt-0 mb-0\">Test: {profile.id}</h4>\n        <div className=\"flex gap-sm\">\n          <button\n            className=\"primary text-small\"\n            onClick={() => onTest(profile, 10)}\n            disabled={testLoading}\n          >\n            {testLoading ? \"...\" : \"Generate\"}\n          </button>\n          <button className=\"secondary text-small\" onClick={onClose}>\n            Close\n          </button>\n        </div>\n      </div>\n\n      {testError && <div className=\"error mb-md text-small\">{testError}</div>}\n\n      {strategyUsage && (\n        <div className=\"strategy-usage-panel\">\n          {Object.entries(strategyUsage)\n            .filter(([, count]) => count > 0)\n            .map(([strategy, count]) => (\n              <span key={strategy} className=\"mr-sm\">\n                {strategy}: {count}\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-names-list\">\n          {testNames.map((name, i) => (\n            <div key={i} className=\"test-name-item\">\n              {name}\n            </div>\n          ))}\n        </div>\n      ) : (\n        <p className=\"text-muted text-small mt-0 mb-0\">Click Generate to test this profile</p>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}", "type": "{ profile: any; testNames: any; testLoading: any; testError: any; strategyUsage: any; onTest: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js::findMatchingGenerators", "name": "findMatchingGenerators", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js", "sourceCode": "/**\n * Analyze which generators will match a specific strategy group's conditions\n */\nexport function findMatchingGenerators(generators, cultureId, conditions) {\n  if (!generators || generators.length === 0) return [];\n\n  const matches = [];\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    const creations = gen.creation || [];\n    const genName = gen.name || gen.id;\n\n    for (const creation of creations) {\n      if (!creationMatchesCulture(creation, cultureId)) continue;\n\n      const match = matchCreationToConditions(creation, conditions, gen.id, genName);\n      if (match) matches.push(match);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "conditions", "type": "any", "optional": false}], "returnType": "{ generatorId: any; generatorName: any; entityKind: any; subtype: any; isDefault: boolean; }[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js::computeProfileGeneratorUsage", "name": "computeProfileGeneratorUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js", "sourceCode": "/**\n * Compute generator usage for all profiles in a culture\n */\nexport function computeProfileGeneratorUsage(profiles, generators, cultureId) {\n  const usage = {};\n\n  for (const profile of profiles) {\n    usage[profile.id] = {\n      totalMatches: 0,\n      groups: {},\n    };\n\n    for (const group of profile.strategyGroups || []) {\n      const matches = findMatchingGenerators(generators, cultureId, group.conditions);\n      usage[profile.id].groups[group.name || \"Default\"] = matches;\n      usage[profile.id].totalMatches += matches.length;\n    }\n  }\n\n  return usage;\n}", "parameters": [{"name": "profiles", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/GroupsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/GroupsTab.jsx", "sourceCode": "export default function GroupsTab({\n  profile,\n  onChange,\n  domains,\n  grammars,\n  entityKinds,\n  tagRegistry,\n  onAddTag,\n}) {\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  const handleAddGroup = (withConditions = false) => {\n    const newGroup = {\n      name: withConditions ? \"Conditional Group\" : \"Default\",\n      priority: withConditions ? 50 : 0,\n      conditions: withConditions\n        ? {\n            entityKinds: [],\n            prominence: [],\n            subtypes: [],\n            subtypeMatchAll: false,\n            tags: [],\n            tagMatchAll: false,\n          }\n        : null,\n      strategies: [],\n    };\n    onChange({\n      ...profile,\n      strategyGroups: [...(profile.strategyGroups || []), newGroup],\n    });\n  };\n\n  const handleDeleteGroup = (groupIdx) => {\n    onChange({\n      ...profile,\n      strategyGroups: profile.strategyGroups.filter((_, i) => i !== groupIdx),\n    });\n  };\n\n  const handleAddStrategy = (groupIdx, type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n\n    const groups = [...profile.strategyGroups];\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      strategies: [...groups[groupIdx].strategies, newStrategy],\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleDeleteStrategy = (groupIdx, stratIdx) => {\n    const groups = [...profile.strategyGroups];\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      strategies: groups[groupIdx].strategies.filter((_, i) => i !== stratIdx),\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleWeightChange = (groupIdx, stratIdx, newWeight) => {\n    const groups = [...profile.strategyGroups];\n    const strategies = [...groups[groupIdx].strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    groups[groupIdx] = { ...groups[groupIdx], strategies };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleGroupConditionChange = (groupIdx, field, value) => {\n    const groups = [...profile.strategyGroups];\n    const currentConditions = groups[groupIdx].conditions || {\n      entityKinds: [],\n      prominence: [],\n      subtypes: [],\n      tags: [],\n    };\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      conditions: { ...currentConditions, [field]: value },\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const setEditedProfile = (updated) => {\n    onChange(updated);\n  };\n\n  return (\n    <div className=\"profile-groups-tab\">\n      <p className=\"text-muted text-small mt-0\">\n        Strategy groups are evaluated by priority (highest first). The first matching group&apos;s\n        strategies are used for name generation.\n      </p>\n\n      {(profile.strategyGroups || []).length === 0 && (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No strategy groups yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Add a default group to get started with name generation.\n          </p>\n        </div>\n      )}\n\n      {(profile.strategyGroups || []).map((group, groupIdx) => (\n        <StrategyGroupEditor\n          key={groupIdx}\n          group={group}\n          groupIdx={groupIdx}\n          domains={domains}\n          grammars={grammars}\n          entityKinds={entityKinds}\n          prominenceLevels={prominenceLevels}\n          tagRegistry={tagRegistry}\n          editedProfile={profile}\n          setEditedProfile={setEditedProfile}\n          onDeleteGroup={handleDeleteGroup}\n          onAddStrategy={handleAddStrategy}\n          onDeleteStrategy={handleDeleteStrategy}\n          onWeightChange={handleWeightChange}\n          onConditionChange={handleGroupConditionChange}\n          onAddTag={onAddTag}\n        />\n      ))}\n\n      <div className=\"add-group-buttons\">\n        <button className=\"secondary\" onClick={() => handleAddGroup(false)}>\n          + Default Group\n        </button>\n        <button className=\"secondary\" onClick={() => handleAddGroup(true)}>\n          + Conditional Group\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  domains,\n  grammars,\n  entityKinds,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ profile: any; onChange: any; domains: any; grammars: any; entityKinds: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../StrategyGroupEditor", "specifiers": ["StrategyGroupEditor"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/OverviewTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/OverviewTab.jsx", "sourceCode": "export default function OverviewTab({\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}) {\n  const matchCount = generatorUsage?.totalMatches || 0;\n  const groups = profile.strategyGroups || [];\n\n  // Drag state\n  const [draggedIdx, setDraggedIdx] = useState(null);\n  const [dragOverIdx, setDragOverIdx] = useState(null);\n  const dragNodeRef = useRef(null);\n\n  const handleDragStart = (e, idx) => {\n    setDraggedIdx(idx);\n    dragNodeRef.current = e.target;\n    e.target.classList.add(\"dragging\");\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setData(\"text/plain\", idx);\n  };\n\n  const handleDragEnd = (e) => {\n    e.target.classList.remove(\"dragging\");\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n    dragNodeRef.current = null;\n  };\n\n  const handleDragOver = (e, idx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === idx) return;\n    setDragOverIdx(idx);\n  };\n\n  const handleDragLeave = () => {\n    setDragOverIdx(null);\n  };\n\n  const handleDrop = (e, dropIdx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === dropIdx) return;\n\n    const newGroups = [...groups];\n    const [draggedGroup] = newGroups.splice(draggedIdx, 1);\n    newGroups.splice(dropIdx, 0, draggedGroup);\n\n    onChange({ ...profile, strategyGroups: newGroups });\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n  };\n\n  const getStrategyTypeCounts = (group) => {\n    const counts = { phonotactic: 0, grammar: 0 };\n    (group.strategies || []).forEach((s) => {\n      if (counts[s.type] !== undefined) counts[s.type]++;\n    });\n    return counts;\n  };\n\n  return (\n    <div className=\"profile-overview-tab\">\n      {/* Profile ID */}\n      <div className=\"form-group\">\n        <label htmlFor=\"profile-id\">Profile ID</label>\n        <input id=\"profile-id\"\n          value={profile.id || \"\"}\n          onChange={(e) => onChange({ ...profile, id: e.target.value })}\n          placeholder=\"e.g., culture_default\"\n        />\n        <small className=\"text-muted\">\n          Unique identifier used to reference this profile in generators\n        </small>\n      </div>\n\n      {/* Default Profile Toggle */}\n      <div className=\"form-group\">\n        <label className=\"checkbox-label\">\n          <input\n            type=\"checkbox\"\n            checked={profile.isDefault || false}\n            onChange={(e) => onChange({ ...profile, isDefault: e.target.checked })}\n          />\n          <span>Default Profile</span>\n        </label>\n        <small className=\"text-muted\">\n          Use this profile when no entity kind matches. Only one profile should be marked as\n          default.\n        </small>\n      </div>\n\n      {/* Entity Kinds Binding */}\n      <div className=\"form-group\">\n        <label>Entity Kinds\n        <MultiSelectPills\n          options={entityKinds}\n          selected={profile.entityKinds || []}\n          onChange={(kinds) => onChange({ ...profile, entityKinds: kinds })}\n          allLabel=\"Any\"\n        />\n        </label>\n        <small className=\"text-muted\">\n          Profile applies when generating names for these entity kinds. &quot;Any&quot; means use default\n          profile logic.\n        </small>\n      </div>\n\n      {/* Stats */}\n      <div className=\"profile-stats\">\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.length}</div>\n          <div className=\"stat-label\">Strategy Groups</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">\n            {groups.reduce((sum, g) => sum + (g.strategies?.length || 0), 0)}\n          </div>\n          <div className=\"stat-label\">Total Strategies</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.filter((g) => g.conditions).length}</div>\n          <div className=\"stat-label\">Conditional</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{matchCount}</div>\n          <div className=\"stat-label\">Generator Matches</div>\n        </div>\n      </div>\n\n      {/* Groups Overview */}\n      <div className=\"groups-overview\">\n        <div className=\"groups-header\">\n          <h4>Strategy Groups</h4>\n          <span className=\"text-muted text-small\">Drag to reorder priority</span>\n        </div>\n\n        {groups.length === 0 ? (\n          <div className=\"empty-groups\">\n            <p>No strategy groups yet. Add one using the buttons below the sidebar.</p>\n          </div>\n        ) : (\n          <div className=\"groups-list\">\n            {groups.map((group, idx) => {\n              const isConditional = !!group.conditions;\n              const counts = getStrategyTypeCounts(group);\n              const isDragOver = dragOverIdx === idx && draggedIdx !== idx;\n\n              return (\n                <div\n                  key={idx}\n                  className={`group-row ${isDragOver ? \"drag-over\" : \"\"} ${draggedIdx === idx ? \"dragging\" : \"\"}`}\n                  draggable\n                  onDragStart={(e) => handleDragStart(e, idx)}\n                  onDragEnd={handleDragEnd}\n                  onDragOver={(e) => handleDragOver(e, idx)}\n                  onDragLeave={handleDragLeave}\n                  onDrop={(e) => handleDrop(e, idx)}\n                  onClick={() => onNavigateToGroup?.(idx)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div className=\"drag-handle\" title=\"Drag to reorder\">\n                    <span>\u22ee\u22ee</span>\n                  </div>\n\n                  <div className=\"group-info\">\n                    <span className=\"group-name\">{group.name || `Group ${idx + 1}`}</span>\n                    <span\n                      className={`group-type-badge ${isConditional ? \"conditional\" : \"default\"}`}\n                    >\n                      {isConditional ? \"\ud83c\udfaf Conditional\" : \"\ud83d\udce6 Default\"}\n                    </span>\n                  </div>\n\n                  <div className=\"group-meta\">\n                    <span className=\"priority-badge\" title=\"Priority\">\n                      P{group.priority || 0}\n                    </span>\n                    {counts.phonotactic > 0 && (\n                      <span className=\"strategy-count phonotactic\" title=\"Phonotactic strategies\">\n                        {counts.phonotactic}\n                      </span>\n                    )}\n                    {counts.grammar > 0 && (\n                      <span className=\"strategy-count grammar\" title=\"Grammar strategies\">\n                        {counts.grammar}\n                      </span>\n                    )}\n                    {counts.phonotactic === 0 && counts.grammar === 0 && (\n                      <span className=\"no-strategies\">No strategies</span>\n                    )}\n                  </div>\n\n                  <div className=\"group-arrow\">\u2192</div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n\n        <p className=\"text-muted text-xs mt-sm\">\n          Groups are evaluated by priority (highest first). First matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Actions */}\n      <div className=\"profile-actions\">\n        <button className=\"secondary\" onClick={onDuplicate}>\n          Duplicate Profile\n        </button>\n      </div>\n\n      {/* Danger Zone */}\n      <div className=\"danger-zone\">\n        <h4>Danger Zone</h4>\n        <button className=\"danger\" onClick={onDelete}>\n          Delete Profile\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}", "type": "{ profile: any; onChange: any; onDelete: any; onDuplicate: any; onNavigateToGroup: any; generatorUsage: any; entityKinds?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../MultiSelectPills", "specifiers": ["MultiSelectPills"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/SingleGroupTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/SingleGroupTab.jsx", "sourceCode": "export default function SingleGroupTab({\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}) {\n  const hasConditions = !!group.conditions;\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n\n  // Compute available subtypes based on selected entity kinds\n  // worldSchema.hardState has: { kind, subtype: string[], status: string[] }\n  const availableSubtypes = useMemo(() => {\n    const selectedKinds = group.conditions?.entityKinds || [];\n    const entityDefs = worldSchema?.hardState || [];\n\n    // If no entity kinds selected, show all subtypes from all entity kinds\n    const kindsToCheck =\n      selectedKinds.length > 0\n        ? entityDefs.filter((e) => selectedKinds.includes(e.kind))\n        : entityDefs;\n\n    const subtypes = new Set();\n    kindsToCheck.forEach((entityDef) => {\n      // subtype is already a string array in hardState format\n      (entityDef.subtype || []).forEach((st) => {\n        if (st) subtypes.add(st);\n      });\n    });\n\n    return Array.from(subtypes).sort();\n  }, [group.conditions?.entityKinds, worldSchema]);\n\n  const updateGroup = (updates) => {\n    onChange({ ...group, ...updates });\n  };\n\n  const toggleConditions = () => {\n    if (hasConditions) {\n      updateGroup({ conditions: null });\n    } else {\n      updateGroup({\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      });\n    }\n  };\n\n  const handleConditionChange = (field, value) => {\n    updateGroup({\n      conditions: { ...group.conditions, [field]: value },\n    });\n  };\n\n  const handleAddStrategy = (type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n    updateGroup({\n      strategies: [...group.strategies, newStrategy],\n    });\n  };\n\n  const handleDeleteStrategy = (stratIdx) => {\n    updateGroup({\n      strategies: group.strategies.filter((_, i) => i !== stratIdx),\n    });\n  };\n\n  const handleWeightChange = (stratIdx, newWeight) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    updateGroup({ strategies });\n  };\n\n  const handleStrategyConfigChange = (stratIdx, field, value) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], [field]: value };\n    updateGroup({ strategies });\n  };\n\n  return (\n    <div className=\"single-group-tab\">\n      {/* Group Header */}\n      <div className=\"group-header-section\">\n        <div className=\"group-name-row\">\n          <div className=\"form-group\">\n            <label htmlFor=\"group-name\">Group Name</label>\n            <input id=\"group-name\"\n              value={group.name || \"\"}\n              onChange={(e) => updateGroup({ name: e.target.value })}\n              placeholder=\"e.g., Noble Names\"\n            />\n          </div>\n          <div className=\"form-group priority-field\">\n            <label>Priority\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => updateGroup({ priority: v ?? 0 })}\n              integer\n            />\n            </label>\n          </div>\n        </div>\n        <p className=\"text-muted text-small mt-0\">\n          Higher priority groups are evaluated first. The first matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Conditions Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Conditions</h4>\n          <button\n            className={`toggle-btn ${hasConditions ? \"active\" : \"\"}`}\n            onClick={toggleConditions}\n          >\n            {hasConditions ? \"Conditional\" : \"Always Match\"}\n          </button>\n        </div>\n\n        {hasConditions ? (\n          <div className=\"conditions-grid\">\n            <div className=\"condition-field\">\n              <label>Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => handleConditionChange(\"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Prominence\n              <MultiSelectPills\n                options={PROMINENCE_LEVELS}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => handleConditionChange(\"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>\n                Subtypes\n                <label className=\"match-all-toggle\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) => handleConditionChange(\"subtypeMatchAll\", e.target.checked)}\n                  />\n                  Match all\n                </label>\n              </label>\n              {availableSubtypes.length > 0 ? (\n                <MultiSelectPills\n                  options={availableSubtypes}\n                  selected={group.conditions?.subtypes || []}\n                  onChange={(val) => handleConditionChange(\"subtypes\", val)}\n                  allLabel=\"Any\"\n                />\n              ) : (\n                <p className=\"text-muted text-small sgt-no-subtypes\">\n                  {(group.conditions?.entityKinds?.length || 0) > 0\n                    ? \"Selected entity types have no subtypes defined\"\n                    : \"Select entity types to see available subtypes\"}\n                </p>\n              )}\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => handleConditionChange(\"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => handleConditionChange(\"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        ) : (\n          <p className=\"text-muted text-small\">\n            This group will always be considered. Click &quot;Always Match&quot; to add conditions.\n          </p>\n        )}\n      </div>\n\n      {/* Strategies Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Strategies</h4>\n          <div className=\"add-strategy-buttons\">\n            <button\n              className=\"add-btn phonotactic\"\n              onClick={() => handleAddStrategy(\"phonotactic\")}\n            >\n              + Phonotactic\n            </button>\n            <button className=\"add-btn grammar\" onClick={() => handleAddStrategy(\"grammar\")}>\n              + Grammar\n            </button>\n          </div>\n        </div>\n\n        {group.strategies.length === 0 ? (\n          <div className=\"empty-strategies\">\n            <p>No strategies yet. Add a strategy to define how names are generated.</p>\n          </div>\n        ) : (\n          <div className=\"strategies-list\">\n            {group.strategies.map((strategy, stratIdx) => (\n              <div key={stratIdx} className={`strategy-item ${strategy.type}`}>\n                <div className=\"strategy-header\">\n                  <span className=\"strategy-type\">{strategy.type}</span>\n                  <span className=\"strategy-weight\">\n                    {groupTotalWeight > 0\n                      ? Math.round((strategy.weight / groupTotalWeight) * 100)\n                      : 0}\n                    %\n                  </span>\n                  <button className=\"remove-btn\" onClick={() => handleDeleteStrategy(stratIdx)}>\n                    \u00d7\n                  </button>\n                </div>\n\n                <div className=\"strategy-body\">\n                  <div className=\"weight-slider\">\n                    <label htmlFor=\"weight\">Weight</label>\n                    <input id=\"weight\"\n                      type=\"range\"\n                      min=\"0\"\n                      max=\"1\"\n                      step=\"0.05\"\n                      value={strategy.weight}\n                      onChange={(e) => handleWeightChange(stratIdx, e.target.value)}\n                    />\n                  </div>\n\n                  {strategy.type === \"phonotactic\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"domain\">Domain</label>\n                      <select id=\"domain\"\n                        value={strategy.domainId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"domainId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select domain...</option>\n                        {domains.map((d) => (\n                          <option key={d.id} value={d.id}>\n                            {d.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n\n                  {strategy.type === \"grammar\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"grammar\">Grammar</label>\n                      <select id=\"grammar\"\n                        value={strategy.grammarId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"grammarId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select grammar...</option>\n                        {grammars.map((g) => (\n                          <option key={g.id} value={g.id}>\n                            {g.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n                </div>\n              </div>\n// ... (truncated)", "parameters": [{"name": "{\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; onChange: any; onDelete: any; domains: any; grammars: any; entityKinds: any; worldSchema: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["TagSelector", "NumberInput"], "category": "external"}, {"source": "../MultiSelectPills", "specifiers": ["MultiSelectPills"], "category": "internal"}, {"source": "./SingleGroupTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/TestTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/TestTab.jsx", "sourceCode": "export default function TestTab({ profile, cultureConfig }) {\n  const [testNames, setTestNames] = useState([]);\n  const [testLoading, setTestLoading] = useState(false);\n  const [testError, setTestError] = useState(null);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [count, setCount] = useState(10);\n\n  const handleTestNames = async () => {\n    if (!profile || !cultureConfig) return;\n\n    setTestLoading(true);\n    setTestError(null);\n    setTestNames([]);\n    setStrategyUsage(null);\n\n    try {\n      const result = await generateTestNames({\n        culture: cultureConfig,\n        profileId: profile.id,\n        count,\n        seed: `test-${Date.now()}`,\n      });\n\n      setTestNames(result.names || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setTestError(err.message);\n    } finally {\n      setTestLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"profile-test-tab\">\n      <div className=\"test-controls\">\n        <div className=\"test-count-control\">\n          <label>Count:\n          <NumberInput\n            min={1}\n            max={100}\n            value={count}\n            onChange={(v) => setCount(v ?? 10)}\n            integer\n          />\n          </label>\n        </div>\n        <button className=\"primary\" onClick={handleTestNames} disabled={testLoading}>\n          {testLoading ? \"Generating...\" : \"Generate Names\"}\n        </button>\n      </div>\n\n      {testError && <div className=\"error-box\">{testError}</div>}\n\n      {strategyUsage && Object.keys(strategyUsage).length > 0 && (\n        <div className=\"strategy-usage-summary\">\n          <span className=\"usage-label\">Strategy usage:</span>\n          {Object.entries(strategyUsage)\n            .filter(([, cnt]) => cnt > 0)\n            .map(([strategy, cnt]) => (\n              <span key={strategy} className=\"usage-item\">\n                <span className=\"usage-strategy\">{strategy}</span>\n                <span className=\"usage-count\">{cnt}</span>\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-results\">\n          <div className=\"results-header\">\n            <span className=\"results-count\">{testNames.length} names generated</span>\n          </div>\n          <div className=\"test-names-grid\">\n            {testNames.map((name, i) => (\n              <div key={i} className=\"test-name-card\">\n                {name}\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div className=\"empty-test-state\">\n          <p>Click &quot;Generate Names&quot; to test this profile</p>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ profile, cultureConfig }", "type": "{ profile: any; cultureConfig: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["NumberInput"], "category": "external"}, {"source": "../../../../../lib/browser-generator.js", "specifiers": ["generateTestNames"], "category": "internal"}]}]