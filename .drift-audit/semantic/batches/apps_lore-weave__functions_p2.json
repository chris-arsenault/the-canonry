[{"id": "apps/lore-weave/lib/graph/entityMutation.ts::updateEntity", "name": "updateEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Update entity in graph\n */\nexport function updateEntity(\n  graph: Graph,\n  entityId: string,\n  changes: Partial<HardState>\n): void {\n  // Use Graph's updateEntity method to modify the actual entity, not a clone\n  graph.updateEntity(entityId, changes);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "changes", "type": "Partial<HardState>", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::findEntities", "name": "findEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Find entities matching criteria\r\n */\r\nexport function findEntities(\r\n  graph: Graph,\r\n  criteria: Partial<HardState>\r\n): HardState[] {\r\n  const results: HardState[] = [];\r\n\r\n  graph.forEachEntity(entity => {\r\n    let matches = true;\r\n\r\n    for (const [key, value] of Object.entries(criteria)) {\r\n      if (entity[key as keyof HardState] !== value) {\r\n        matches = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches) {\r\n      results.push(entity);\r\n    }\r\n  });\r\n\r\n  return results;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "criteria", "type": "Partial<HardState>", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getRelated", "name": "getRelated", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Get related entities via relationships\r\n */\r\nexport function getRelated(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipKind?: string,\r\n  direction: 'src' | 'dst' | 'both' = 'both',\r\n  options?: RelationshipQueryOptions\r\n): HardState[] {\r\n  const related: Array<{ entity: HardState; strength: number }> = [];\r\n  const opts = options || {};\r\n\r\n  graph.getRelationships().forEach(rel => {\r\n    if (relationshipKind && rel.kind !== relationshipKind) return;\r\n\r\n    // Strength filtering\r\n    const strength = rel.strength ?? 0.5;\r\n    if (opts.minStrength !== undefined && strength < opts.minStrength) return;\r\n    if (opts.maxStrength !== undefined && strength > opts.maxStrength) return;\r\n\r\n    if ((direction === 'src' || direction === 'both') && rel.src === entityId) {\r\n      const entity = graph.getEntity(rel.dst);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n\r\n    if ((direction === 'dst' || direction === 'both') && rel.dst === entityId) {\r\n      const entity = graph.getEntity(rel.src);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n  });\r\n\r\n  // Sort by strength if requested\r\n  if (opts.sortByStrength) {\r\n    related.sort((a, b) => b.strength - a.strength);\r\n  }\r\n\r\n  return related.map(r => r.entity);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": true}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}, {"name": "options", "type": "RelationshipQueryOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "export function hasRelationship(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind?: string\r\n): boolean {\r\n  return graph.getRelationships().some(rel =>\r\n    rel.src === srcId &&\r\n    rel.dst === dstId &&\r\n    (!kind || rel.kind === kind)\r\n  );\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getConnectionWeight", "name": "getConnectionWeight", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Calculate relationship formation weight based on existing connection count.\r\n * Favors underconnected entities to balance network density and prevent hubs.\r\n */\r\nexport function getConnectionWeight(graph: Graph, entity: HardState): number {\r\n  const connectionCount = graph.getEntityRelationships(entity.id, 'both').length;\r\n\r\n  // Boost isolated/underconnected entities\r\n  if (connectionCount === 0) return 3.0;    // Strongly boost isolated\r\n  if (connectionCount <= 2) return 2.0;     // Boost underconnected (below median)\r\n  if (connectionCount <= 5) return 1.0;     // Normal\r\n  if (connectionCount <= 10) return 0.5;    // Reduce well-connected\r\n  return 0.2;                               // Heavily reduce hubs (15+)\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getFactionRelationship", "name": "getFactionRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Determine the relationship between two sets of factions.\r\n */\r\nexport function getFactionRelationship(\r\n  factions1: HardState[],\r\n  factions2: HardState[],\r\n  graph: Graph\r\n): 'allied' | 'enemy' | 'neutral' {\r\n  // Check for warfare/enmity\r\n  const atWar = factions1.some(f1 =>\r\n    factions2.some(f2 =>\r\n      hasRelationship(graph, f1.id, f2.id, 'at_war_with') ||\r\n      hasRelationship(graph, f1.id, f2.id, 'enemy_of')\r\n    )\r\n  );\r\n  if (atWar) return 'enemy';\r\n\r\n  // Check for alliances\r\n  const allied = factions1.some(f1 =>\r\n    factions2.some(f2 => hasRelationship(graph, f1.id, f2.id, 'allied_with'))\r\n  );\r\n  if (allied) return 'allied';\r\n\r\n  return 'neutral';\r\n}", "parameters": [{"name": "factions1", "type": "HardState[]", "optional": false}, {"name": "factions2", "type": "HardState[]", "optional": false}, {"name": "graph", "type": "Graph", "optional": false}], "returnType": "'allied' | 'enemy' | 'neutral'"}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getEntitiesByRelationship", "name": "getEntitiesByRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Graph Query Utilities\n *\n * Reusable query patterns for common graph operations.\n * Extracted to reduce code duplication and improve maintainability.\n *\n * @module graphQueries\n */\n\n/**\n * Get all entities related to a given entity by a specific relationship kind\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity to find related entities for\n * @param relationshipKind - Type of relationship to filter by\n * @param direction - Whether the entity is the source or destination\n * @returns Array of related entities\n */\nexport function getEntitiesByRelationship(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction: 'src' | 'dst'\n): HardState[] {\n  const relatedIds = graph.getRelationships()\n    .filter(r => r.kind === relationshipKind && r[direction] === entityId)\n    .map(r => direction === 'src' ? r.dst : r.src);\n\n  return relatedIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getRelationshipIdSet", "name": "getRelationshipIdSet", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Get all relationship IDs for an entity as a set\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKinds - Array of relationship kinds to include\n * @param direction - Optional direction filter ('src' or 'dst')\n * @returns Set of related entity IDs\n */\nexport function getRelationshipIdSet(\n  graph: Graph,\n  entityId: string,\n  relationshipKinds: string[],\n  direction?: 'src' | 'dst'\n): Set<string> {\n  return new Set(\n    graph.getRelationships()\n      .filter(r => {\n        if (!relationshipKinds.includes(r.kind)) return false;\n        if (!direction) return r.src === entityId || r.dst === entityId;\n        return r[direction] === entityId;\n      })\n      .map(r => r.src === entityId ? r.dst : r.src)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKinds", "type": "string[]", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": true}], "returnType": "Set<string>"}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::countRelationships", "name": "countRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Count relationships of a specific kind for an entity\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKind - Type of relationship to count\n * @param direction - Optional direction filter\n * @returns Count of matching relationships\n */\nexport function countRelationships(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction?: 'src' | 'dst'\n): number {\n  return graph.getRelationships().filter(r => {\n    if (r.kind !== relationshipKind) return false;\n    if (!direction) return r.src === entityId || r.dst === entityId;\n    return r[direction] === entityId;\n  }).length;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::findRelationship", "name": "findRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Find single relationship matching criteria\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKind - Type of relationship to find\n * @param direction - Direction filter\n * @returns First matching relationship or undefined\n */\nexport function findRelationship(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction: 'src' | 'dst'\n): Relationship | undefined {\n  return graph.getRelationships().find(r =>\n    r.kind === relationshipKind && r[direction] === entityId\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": false}], "returnType": "Relationship | undefined"}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getRelatedEntity", "name": "getRelatedEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Get entity at other end of a relationship\n *\n * @param graph - The graph to query\n * @param relationship - The relationship to traverse\n * @param fromEntityId - ID of the starting entity\n * @returns Entity at the other end of the relationship, or undefined\n */\nexport function getRelatedEntity(\n  graph: Graph,\n  relationship: Relationship | undefined,\n  fromEntityId: string\n): HardState | undefined {\n  if (!relationship) return undefined;\n  const targetId = relationship.src === fromEntityId ? relationship.dst : relationship.src;\n  return graph.getEntity(targetId);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "relationship", "type": "Relationship | undefined", "optional": false}, {"name": "fromEntityId", "type": "string", "optional": false}], "returnType": "HardState | undefined"}, {"id": "apps/lore-weave/lib/graph/relationshipBuilder.ts::buildRelationships", "name": "buildRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipBuilder.ts", "sourceCode": "/**\n * Helper function to create a new RelationshipBuilder\n * Usage: buildRelationships().add(...).add(...).build()\n */\nexport function buildRelationships(): RelationshipBuilder {\n  return new RelationshipBuilder();\n}", "parameters": [], "returnType": "RelationshipBuilder"}, {"id": "apps/lore-weave/lib/graph/relationshipBuilder.ts::createRelationship", "name": "createRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipBuilder.ts", "sourceCode": "/**\n * Quick helper to create a single relationship\n * @param kind - Relationship type\n * @param src - Source entity ID\n * @param dst - Destination entity ID\n * @param strength - Optional relationship strength\n */\nexport function createRelationship(\n  kind: string,\n  src: string,\n  dst: string,\n  strength: number = 0.5\n): Relationship {\n  return { kind, src, dst, strength };\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "Relationship"}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::addRelationship", "name": "addRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP MUTATION\r\n// ===========================\r\n\r\n/**\r\n * Add a relationship between two entities.\r\n * Distance is ALWAYS computed from Euclidean distance between coordinates.\r\n */\r\nexport function addRelationship(\r\n  graph: Graph,\r\n  kind: string,\r\n  srcId: string,\r\n  dstId: string,\r\n  strength: number = 0.5\r\n): void {\r\n  graph.addRelationship(kind, srcId, dstId, strength);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::archiveRelationship", "name": "archiveRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "/**\r\n * Archive a relationship by marking it as historical.\r\n */\r\nexport function archiveRelationship(\r\n  graph: Graph,\r\n  src: string,\r\n  dst: string,\r\n  kind: string,\r\n  reason?: string\r\n): void {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === src &&\r\n    r.dst === dst &&\r\n    r.kind === kind &&\r\n    r.status !== 'historical'\r\n  );\r\n\r\n  if (rel) {\r\n    const age = graph.tick - (rel.createdAt ?? 0);\r\n    rel.status = 'historical';\r\n    rel.archivedAt = graph.tick;\r\n\r\n    // Record archival for context-based event generation\r\n    graph.mutationTracker?.recordRelationshipArchived({\r\n      srcId: src,\r\n      dstId: dst,\r\n      kind,\r\n      age,\r\n      reason,\r\n    });\r\n  }\r\n\r\n  const srcEntity = graph.getEntity(src);\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  const dstEntity = graph.getEntity(dst);\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "reason", "type": "string", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::modifyRelationshipStrength", "name": "modifyRelationshipStrength", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "/**\r\n * Modify relationship strength by delta\r\n */\r\nexport function modifyRelationshipStrength(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind: string,\r\n  delta: number\r\n): boolean {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === srcId && r.dst === dstId && r.kind === kind\r\n  );\r\n\r\n  if (!rel) return false;\r\n\r\n  const currentStrength = rel.strength ?? 0.5;\r\n  rel.strength = Math.max(0.0, Math.min(1.0, currentStrength + delta));\r\n\r\n  const srcEntity = graph.getEntity(srcId);\r\n  const dstEntity = graph.getEntity(dstId);\r\n\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  return true;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "delta", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::canFormRelationship", "name": "canFormRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP COOLDOWN\r\n// ===========================\r\n\r\n/**\r\n * Check if an entity can form a new relationship based on cooldown.\r\n */\r\nexport function canFormRelationship(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string,\r\n  cooldownTicks: number\r\n): boolean {\r\n  const entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n  if (!entityCooldowns) return true;\r\n\r\n  const lastFormationTick = entityCooldowns.get(relationshipType);\r\n  if (lastFormationTick === undefined) return true;\r\n\r\n  return (graph.tick - lastFormationTick) >= cooldownTicks;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}, {"name": "cooldownTicks", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::recordRelationshipFormation", "name": "recordRelationshipFormation", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "/**\r\n * Record that an entity has formed a relationship.\r\n */\r\nexport function recordRelationshipFormation(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string\r\n): void {\r\n  let entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n\r\n  if (!entityCooldowns) {\r\n    entityCooldowns = new Map();\r\n    graph.relationshipCooldowns.set(entityId, entityCooldowns);\r\n  }\r\n\r\n  entityCooldowns.set(relationshipType, graph.tick);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/narrative/index.ts::calculateSignificance", "name": "calculateSignificance", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/index.ts", "sourceCode": "/**\r\n * Calculate significance score for a narrative event\r\n */\r\nexport function calculateSignificance(\r\n  eventKind: NarrativeEventKind,\r\n  subjectId: string,\r\n  stateChanges: StateChangeData[],\r\n  context: SignificanceContext\r\n): number {\r\n  let score = 0.0;\r\n\r\n  // Base scores by event kind\r\n  const kindScores: Record<NarrativeEventKind, number> = {\r\n    // Core events\r\n    entity_lifecycle: 0.5,         // Deaths, births are significant\r\n    era_transition: 0.9,           // Era changes are very significant\r\n    state_change: 0.3,             // Base for state changes\r\n    relationship_dissolved: 0.4,   // Breaking ties is notable\r\n    relationship_ended: 0.4,       // Lifecycle-driven endings are notable\r\n    succession: 0.6,               // Leadership transitions are significant\r\n    coalescence: 0.5,              // Multiple entities uniting is notable\r\n    // Polarity-based relationship events\r\n    betrayal: 0.7,                 // Breaking positive bonds is dramatic\r\n    reconciliation: 0.5,           // Ending enmity is notable\r\n    rivalry_formed: 0.5,           // New conflicts are significant\r\n    alliance_formed: 0.4,          // New alliances matter\r\n    relationship_formed: 0.35,     // Single relationship formed (base, modified by calculateRelationshipFormationSignificance)\r\n    // Status polarity events\r\n    downfall: 0.6,                 // Negative status transitions are significant\r\n    triumph: 0.5,                  // Positive status transitions are notable\r\n    // Leadership events\r\n    leadership_established: 0.6,   // First leadership is significant\r\n    // War events\r\n    war_started: 0.8,              // Wars starting are dramatic\r\n    war_ended: 0.7,                // Wars ending are significant\r\n    // Authority events\r\n    power_vacuum: 0.7,             // Leadership gaps are dramatic\r\n    // Tag events (base score, modified by calculateTagSignificance)\r\n    tag_gained: 0.3,               // Base for tag gains\r\n    tag_lost: 0.25,                // Base for tag losses\r\n    // Creation events (base score, modified by calculateCreationBatchSignificance)\r\n    creation_batch: 0.3,           // Base for creation batches\r\n  };\r\n  score += kindScores[eventKind] || 0.2;\r\n\r\n  // Prominence multiplier - mythic entities = more significant\r\n  const entity = context.getEntity(subjectId);\r\n  if (entity) {\r\n    score *= getProminenceMultiplier(entity.prominence);\r\n  }\r\n\r\n  // Status change severity\r\n  for (const change of stateChanges) {\r\n    if (change.field === 'status') {\r\n      const newValue = String(change.newValue);\r\n      // Endings are more significant\r\n      if (newValue === 'historical' || newValue === 'dissolved') {\r\n        score += 0.3;\r\n      }\r\n    }\r\n\r\n    // Prominence changes (now using numeric values)\r\n    if (change.field === 'prominence') {\r\n      const oldValue = change.previousValue as number;\r\n      const newValue = change.newValue as number;\r\n      const delta = Math.abs(newValue - oldValue);\r\n      score += delta * 0.1; // Each 1.0 of prominence change adds significance\r\n\r\n      // Bonus for crossing level boundaries\r\n      if (prominenceLabel(oldValue) !== prominenceLabel(newValue)) {\r\n        score += 0.15;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Connected entities - more connections = more significance\r\n  if (entity) {\r\n    const connections = context.getEntityRelationships(subjectId).length;\r\n    score += Math.min(0.2, connections * 0.01); // Cap at 0.2 bonus\r\n  }\r\n\r\n  // Cap at 1.0\r\n  return Math.min(1.0, score);\r\n}", "parameters": [{"name": "eventKind", "type": "NarrativeEventKind", "optional": false}, {"name": "subjectId", "type": "string", "optional": false}, {"name": "stateChanges", "type": "StateChangeData[]", "optional": false}, {"name": "context", "type": "SignificanceContext", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/index.ts::getProminenceValue", "name": "getProminenceValue", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/index.ts", "sourceCode": "/**\r\n * Get prominence value for comparison.\r\n * Handles both numeric values (new format) and string labels (legacy format).\r\n */\r\nexport function getProminenceValue(prominence: string | number): number {\r\n  if (typeof prominence === 'number') {\r\n    return prominence;\r\n  }\r\n  // Try parsing as number first (handles \"2.5\" etc)\r\n  const parsed = parseFloat(prominence);\r\n  if (!isNaN(parsed)) {\r\n    return parsed;\r\n  }\r\n  // Fall back to label lookup for legacy data\r\n  return PROMINENCE_VALUES[prominence as ProminenceLabel] || 0;\r\n}", "parameters": [{"name": "prominence", "type": "string | number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/index.ts::generateNarrativeTags", "name": "generateNarrativeTags", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/index.ts", "sourceCode": "/**\r\n * Generate narrative tags for an event\r\n */\r\nexport function generateNarrativeTags(\r\n  eventKind: NarrativeEventKind,\r\n  subject: NarrativeEntityRef,\r\n  object: NarrativeEntityRef | undefined,\r\n  stateChanges: StateChangeData[],\r\n  action: string,\r\n  _context: TagContext\r\n): string[] {\r\n  const tags: Set<string> = new Set();\r\n\r\n  tags.add(eventKind);\r\n\r\n  const kindTags = EVENT_KIND_TAGS[eventKind];\r\n  if (kindTags) {\r\n    for (const tag of kindTags) tags.add(tag);\r\n  }\r\n\r\n  addStateChangeTags(tags, stateChanges);\r\n\r\n  tags.add(subject.kind);\r\n  const subjectTag = ENTITY_KIND_TAGS[subject.kind];\r\n  if (subjectTag) tags.add(subjectTag);\r\n\r\n  if (object) tags.add(`target_${object.kind}`);\r\n\r\n  addActionTags(tags, action);\r\n\r\n  return Array.from(tags);\r\n}", "parameters": [{"name": "eventKind", "type": "NarrativeEventKind", "optional": false}, {"name": "subject", "type": "NarrativeEntityRef", "optional": false}, {"name": "object", "type": "NarrativeEntityRef | undefined", "optional": false}, {"name": "stateChanges", "type": "StateChangeData[]", "optional": false}, {"name": "action", "type": "string", "optional": false}, {"name": "_context", "type": "TagContext", "optional": false}], "returnType": "string[]"}, {"id": "apps/lore-weave/lib/narrative/index.ts::createDefaultNarrativeConfig", "name": "createDefaultNarrativeConfig", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/index.ts", "sourceCode": "/**\r\n * Create a default narrative config (enabled)\r\n */\r\nexport function createDefaultNarrativeConfig(): NarrativeConfig {\r\n  return {\r\n    enabled: true,\r\n    minSignificance: 0,\r\n  };\r\n}", "parameters": [], "returnType": "NarrativeConfig"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::isEntityCreated", "name": "isEntityCreated", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "/**\r\n * Helper type guards for mutation data\r\n */\r\nexport function isEntityCreated(m: TrackedMutation): m is TrackedMutation & { data: EntityCreatedData } {\r\n  return m.type === 'entity_created';\r\n}", "parameters": [{"name": "m", "type": "TrackedMutation", "optional": false}], "returnType": "m is TrackedMutation & { data: EntityCreatedData }"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::isRelationshipCreated", "name": "isRelationshipCreated", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "export function isRelationshipCreated(m: TrackedMutation): m is TrackedMutation & { data: RelationshipCreatedData } {\r\n  return m.type === 'relationship_created';\r\n}", "parameters": [{"name": "m", "type": "TrackedMutation", "optional": false}], "returnType": "m is TrackedMutation & { data: RelationshipCreatedData }"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::isRelationshipArchived", "name": "isRelationshipArchived", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "export function isRelationshipArchived(m: TrackedMutation): m is TrackedMutation & { data: RelationshipArchivedData } {\r\n  return m.type === 'relationship_archived';\r\n}", "parameters": [{"name": "m", "type": "TrackedMutation", "optional": false}], "returnType": "m is TrackedMutation & { data: RelationshipArchivedData }"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::isTagChange", "name": "isTagChange", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "export function isTagChange(m: TrackedMutation): m is TrackedMutation & { data: TagChangeData } {\r\n  return m.type === 'tag_added' || m.type === 'tag_removed';\r\n}", "parameters": [{"name": "m", "type": "TrackedMutation", "optional": false}], "returnType": "m is TrackedMutation & { data: TagChangeData }"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::isFieldChange", "name": "isFieldChange", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "export function isFieldChange(m: TrackedMutation): m is TrackedMutation & { data: FieldChangeData } {\r\n  return m.type === 'field_changed';\r\n}", "parameters": [{"name": "m", "type": "TrackedMutation", "optional": false}], "returnType": "m is TrackedMutation & { data: FieldChangeData }"}, {"id": "apps/lore-weave/lib/narrative/mutationTracker.ts::contextKey", "name": "contextKey", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/mutationTracker.ts", "sourceCode": "/**\r\n * Key for grouping mutations by context\r\n */\r\nexport function contextKey(context: ExecutionContext): string {\r\n  return `${context.source}:${context.sourceId}:${context.tick}`;\r\n}", "parameters": [{"name": "context", "type": "ExecutionContext", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/narrative/narrationTemplate.ts::interpolate", "name": "interpolate", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/narrationTemplate.ts", "sourceCode": "/**\r\n * Interpolate a narration template with context values.\r\n *\r\n * @param template - The template string with {token} placeholders\r\n * @param context - Context providing entity bindings and values\r\n * @returns The interpolated result\r\n *\r\n * @example\r\n * interpolate(\r\n *   \"The {actor.subtype} {actor.name} marched on {target.name}, wresting it from {$previousOwner.name|the realm's grasp}.\",\r\n *   {\r\n *     entities: {\r\n *       actor: { name: 'House Valorn', subtype: 'faction', ... },\r\n *       target: { name: 'Ironhold', ... },\r\n *       $previousOwner: undefined\r\n *     }\r\n *   }\r\n * )\r\n * // => \"The faction House Valorn marched on Ironhold, wresting it from the realm's grasp.\"\r\n */\r\nexport function interpolate(template: string, context: NarrationContext): NarrationResult {\r\n  const tokens = findTokens(template);\r\n  const unresolvedTokens: string[] = [];\r\n  let result = template;\r\n\r\n  for (const tokenStr of tokens) {\r\n    const token = parseToken(tokenStr);\r\n    const resolved = resolveToken(token, context);\r\n\r\n    if (resolved === undefined) {\r\n      unresolvedTokens.push(tokenStr);\r\n      // Leave token in place if no fallback\r\n      continue;\r\n    }\r\n\r\n    result = result.replace(tokenStr, resolved);\r\n  }\r\n\r\n  return {\r\n    text: result,\r\n    complete: unresolvedTokens.length === 0,\r\n    unresolvedTokens,\r\n  };\r\n}", "parameters": [{"name": "template", "type": "string", "optional": false}, {"name": "context", "type": "NarrationContext", "optional": false}], "returnType": "NarrationResult"}, {"id": "apps/lore-weave/lib/narrative/narrationTemplate.ts::createNarrationContext", "name": "createNarrationContext", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/narrationTemplate.ts", "sourceCode": "/**\r\n * Create a NarrationContext from common action/system bindings.\r\n */\r\nexport function createNarrationContext(bindings: {\r\n  actor?: HardState;\r\n  target?: HardState;\r\n  target2?: HardState;\r\n  instigator?: HardState | null;\r\n  variables?: Record<string, VariableValue>;\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}): NarrationContext {\r\n  const entities: Record<string, VariableValue> = {};\r\n\r\n  if (bindings.actor) {\r\n    entities['actor'] = bindings.actor;\r\n  }\r\n  if (bindings.target) {\r\n    entities['target'] = bindings.target;\r\n  }\r\n  if (bindings.target2) {\r\n    entities['target2'] = bindings.target2;\r\n  }\r\n  // Always add instigator key if it was provided (even if null),\r\n  // so templates can resolve to fallback or empty string\r\n  if ('instigator' in bindings) {\r\n    entities['instigator'] = bindings.instigator ?? undefined;\r\n  }\r\n\r\n  // Add variables with $ prefix\r\n  if (bindings.variables) {\r\n    for (const [key, value] of Object.entries(bindings.variables)) {\r\n      // Ensure $ prefix for consistency\r\n      const prefixedKey = key.startsWith('$') ? key : `$${key}`;\r\n      entities[prefixedKey] = value;\r\n    }\r\n  }\r\n\r\n  return {\r\n    entities,\r\n    counts: bindings.counts,\r\n    values: bindings.values,\r\n  };\r\n}", "parameters": [{"name": "bindings", "type": "{\r\n  actor?: HardState;\r\n  target?: HardState;\r\n  target2?: HardState;\r\n  instigator?: HardState | null;\r\n  variables?: Record<string, VariableValue>;\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}", "optional": false}], "returnType": "NarrationContext"}, {"id": "apps/lore-weave/lib/narrative/narrationTemplate.ts::createSystemRuleContext", "name": "createSystemRuleContext", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/narrationTemplate.ts", "sourceCode": "/**\r\n * Helper to create context for system rules (connectionEvolution, etc.)\r\n */\r\nexport function createSystemRuleContext(bindings: {\r\n  self?: HardState;\r\n  member?: HardState;\r\n  member2?: HardState;\r\n  sharedVia?: HardState;\r\n  variables?: Record<string, VariableValue>;\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}): NarrationContext {\r\n  const entities: Record<string, VariableValue> = {};\r\n\r\n  if (bindings.self) {\r\n    entities['self'] = bindings.self;\r\n    entities['$self'] = bindings.self;\r\n  }\r\n  if (bindings.member) {\r\n    entities['member'] = bindings.member;\r\n    entities['$member'] = bindings.member;\r\n  }\r\n  if (bindings.member2) {\r\n    entities['member2'] = bindings.member2;\r\n    entities['$member2'] = bindings.member2;\r\n  }\r\n  if (bindings.sharedVia) {\r\n    entities['sharedVia'] = bindings.sharedVia;\r\n    entities['$sharedVia'] = bindings.sharedVia;\r\n  }\r\n\r\n  if (bindings.variables) {\r\n    for (const [key, value] of Object.entries(bindings.variables)) {\r\n      const prefixedKey = key.startsWith('$') ? key : `$${key}`;\r\n      entities[prefixedKey] = value;\r\n    }\r\n  }\r\n\r\n  return {\r\n    entities,\r\n    counts: bindings.counts,\r\n    values: bindings.values,\r\n  };\r\n}", "parameters": [{"name": "bindings", "type": "{\r\n  self?: HardState;\r\n  member?: HardState;\r\n  member2?: HardState;\r\n  sharedVia?: HardState;\r\n  variables?: Record<string, VariableValue>;\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}", "optional": false}], "returnType": "NarrationContext"}, {"id": "apps/lore-weave/lib/narrative/narrationTemplate.ts::createGeneratorContext", "name": "createGeneratorContext", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/narrationTemplate.ts", "sourceCode": "/**\r\n * Helper to create context for template/generator execution\r\n */\r\nexport function createGeneratorContext(bindings: {\r\n  target?: HardState;\r\n  selected?: HardState;\r\n  variables?: Record<string, VariableValue>;\r\n  entitiesCreated?: HardState[];\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}): NarrationContext {\r\n  const entities: Record<string, VariableValue> = {};\r\n\r\n  if (bindings.target) {\r\n    entities['target'] = bindings.target;\r\n    entities['$target'] = bindings.target;\r\n  }\r\n  if (bindings.selected) {\r\n    entities['selected'] = bindings.selected;\r\n    entities['$selected'] = bindings.selected;\r\n  }\r\n  if (bindings.entitiesCreated) {\r\n    entities['created'] = bindings.entitiesCreated;\r\n    entities['$created'] = bindings.entitiesCreated;\r\n  }\r\n\r\n  if (bindings.variables) {\r\n    for (const [key, value] of Object.entries(bindings.variables)) {\r\n      const prefixedKey = key.startsWith('$') ? key : `$${key}`;\r\n      entities[prefixedKey] = value;\r\n      // Also without prefix for convenience\r\n      entities[key.replace(/^\\$/, '')] = value;\r\n    }\r\n  }\r\n\r\n  return {\r\n    entities,\r\n    counts: bindings.counts,\r\n    values: bindings.values,\r\n  };\r\n}", "parameters": [{"name": "bindings", "type": "{\r\n  target?: HardState;\r\n  selected?: HardState;\r\n  variables?: Record<string, VariableValue>;\r\n  entitiesCreated?: HardState[];\r\n  counts?: Record<string, number>;\r\n  values?: Record<string, ScalarValue>;\r\n}", "optional": false}], "returnType": "NarrationContext"}, {"id": "apps/lore-weave/lib/narrative/narrativeTagGenerator.ts::generateNarrativeTags", "name": "generateNarrativeTags", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/narrativeTagGenerator.ts", "sourceCode": "/**\r\n * Generate narrative tags for an event\r\n */\r\nexport function generateNarrativeTags(\r\n  eventKind: NarrativeEventKind,\r\n  subject: NarrativeEntityRef,\r\n  object: NarrativeEntityRef | undefined,\r\n  stateChanges: StateChangeData[],\r\n  action: string,\r\n  _context: TagContext\r\n): string[] {\r\n  const tags: Set<string> = new Set();\r\n\r\n  tags.add(eventKind);\r\n\r\n  const kindTags = EVENT_KIND_TAGS[eventKind];\r\n  if (kindTags) {\r\n    for (const tag of kindTags) tags.add(tag);\r\n  }\r\n\r\n  addStateChangeTags(tags, stateChanges);\r\n\r\n  tags.add(subject.kind);\r\n  const subjectTag = ENTITY_KIND_TAGS[subject.kind];\r\n  if (subjectTag) tags.add(subjectTag);\r\n\r\n  if (object) tags.add(`target_${object.kind}`);\r\n\r\n  addActionTags(tags, action);\r\n\r\n  return Array.from(tags);\r\n}", "parameters": [{"name": "eventKind", "type": "NarrativeEventKind", "optional": false}, {"name": "subject", "type": "NarrativeEntityRef", "optional": false}, {"name": "object", "type": "NarrativeEntityRef | undefined", "optional": false}, {"name": "stateChanges", "type": "StateChangeData[]", "optional": false}, {"name": "action", "type": "string", "optional": false}, {"name": "_context", "type": "TagContext", "optional": false}], "returnType": "string[]"}, {"id": "apps/lore-weave/lib/narrative/significanceCalculator.ts::calculateSignificance", "name": "calculateSignificance", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/significanceCalculator.ts", "sourceCode": "/**\r\n * Calculate significance score for a narrative event\r\n */\r\nexport function calculateSignificance(\r\n  eventKind: NarrativeEventKind,\r\n  subjectId: string,\r\n  stateChanges: StateChangeData[],\r\n  context: SignificanceContext\r\n): number {\r\n  let score = 0.0;\r\n\r\n  // Base scores by event kind\r\n  const kindScores: Record<NarrativeEventKind, number> = {\r\n    // Core events\r\n    entity_lifecycle: 0.5,         // Deaths, births are significant\r\n    era_transition: 0.9,           // Era changes are very significant\r\n    state_change: 0.3,             // Base for state changes\r\n    relationship_dissolved: 0.4,   // Breaking ties is notable\r\n    relationship_ended: 0.4,       // Lifecycle-driven endings are notable\r\n    succession: 0.6,               // Leadership transitions are significant\r\n    coalescence: 0.5,              // Multiple entities uniting is notable\r\n    // Polarity-based relationship events\r\n    betrayal: 0.7,                 // Breaking positive bonds is dramatic\r\n    reconciliation: 0.5,           // Ending enmity is notable\r\n    rivalry_formed: 0.5,           // New conflicts are significant\r\n    alliance_formed: 0.4,          // New alliances matter\r\n    relationship_formed: 0.35,     // Single relationship formed (base, modified by calculateRelationshipFormationSignificance)\r\n    // Status polarity events\r\n    downfall: 0.6,                 // Negative status transitions are significant\r\n    triumph: 0.5,                  // Positive status transitions are notable\r\n    // Leadership events\r\n    leadership_established: 0.6,   // First leadership is significant\r\n    // War events\r\n    war_started: 0.8,              // Wars starting are dramatic\r\n    war_ended: 0.7,                // Wars ending are significant\r\n    // Authority events\r\n    power_vacuum: 0.7,             // Leadership gaps are dramatic\r\n    // Tag events (base score, modified by calculateTagSignificance)\r\n    tag_gained: 0.3,               // Base for tag gains\r\n    tag_lost: 0.25,                // Base for tag losses\r\n    // Creation events (base score, modified by calculateCreationBatchSignificance)\r\n    creation_batch: 0.3,           // Base for creation batches\r\n  };\r\n  score += kindScores[eventKind] || 0.2;\r\n\r\n  // Prominence multiplier - mythic entities = more significant\r\n  const entity = context.getEntity(subjectId);\r\n  if (entity) {\r\n    score *= getProminenceMultiplier(entity.prominence);\r\n  }\r\n\r\n  // Status change severity\r\n  for (const change of stateChanges) {\r\n    if (change.field === 'status') {\r\n      const newValue = String(change.newValue);\r\n      // Endings are more significant\r\n      if (newValue === 'historical' || newValue === 'dissolved') {\r\n        score += 0.3;\r\n      }\r\n    }\r\n\r\n    // Prominence changes (now using numeric values)\r\n    if (change.field === 'prominence') {\r\n      const oldValue = change.previousValue as number;\r\n      const newValue = change.newValue as number;\r\n      const delta = Math.abs(newValue - oldValue);\r\n      score += delta * 0.1; // Each 1.0 of prominence change adds significance\r\n\r\n      // Bonus for crossing level boundaries\r\n      if (prominenceLabel(oldValue) !== prominenceLabel(newValue)) {\r\n        score += 0.15;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Connected entities - more connections = more significance\r\n  if (entity) {\r\n    const connections = context.getEntityRelationships(subjectId).length;\r\n    score += Math.min(0.2, connections * 0.01); // Cap at 0.2 bonus\r\n  }\r\n\r\n  // Cap at 1.0\r\n  return Math.min(1.0, score);\r\n}", "parameters": [{"name": "eventKind", "type": "NarrativeEventKind", "optional": false}, {"name": "subjectId", "type": "string", "optional": false}, {"name": "stateChanges", "type": "StateChangeData[]", "optional": false}, {"name": "context", "type": "SignificanceContext", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/significanceCalculator.ts::getProminenceValue", "name": "getProminenceValue", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/significanceCalculator.ts", "sourceCode": "/**\r\n * Get prominence value for comparison.\r\n * Handles both numeric values (new format) and string labels (legacy format).\r\n */\r\nexport function getProminenceValue(prominence: string | number): number {\r\n  if (typeof prominence === 'number') {\r\n    return prominence;\r\n  }\r\n  // Try parsing as number first (handles \"2.5\" etc)\r\n  const parsed = parseFloat(prominence);\r\n  if (!isNaN(parsed)) {\r\n    return parsed;\r\n  }\r\n  // Fall back to label lookup for legacy data\r\n  return PROMINENCE_VALUES[prominence as ProminenceLabel] || 0;\r\n}", "parameters": [{"name": "prominence", "type": "string | number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/significanceCalculator.ts::calculateTagSignificance", "name": "calculateTagSignificance", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/significanceCalculator.ts", "sourceCode": "/**\r\n * Calculate significance score for a tag change event.\r\n *\r\n * Uses tag metadata (category, rarity) and entity prominence to determine\r\n * how narratively important the tag change is.\r\n *\r\n * @param tag - The tag that was added or removed\r\n * @param tagMetadata - Registry entry for the tag (if available)\r\n * @param entity - The entity whose tag changed\r\n * @param changeType - Whether the tag was 'added' or 'removed'\r\n * @returns Significance score between 0.0 and 1.0\r\n */\r\nexport function calculateTagSignificance(\r\n  tag: string,\r\n  tagMetadata: TagDefinition | undefined,\r\n  entity: HardState,\r\n  changeType: 'added' | 'removed'\r\n): number {\r\n  // Base significance by category\r\n  const category = tagMetadata?.category || 'trait';\r\n  let base = TAG_CATEGORY_WEIGHTS[category] ?? 0.25;\r\n\r\n  // Rarity modifier\r\n  const rarity = tagMetadata?.rarity || 'common';\r\n  base *= TAG_RARITY_MULTIPLIERS[rarity] ?? 1.0;\r\n\r\n  // Entity prominence modifier - interpolate based on numeric value\r\n  base *= getProminenceMultiplier(entity.prominence);\r\n\r\n  // High-value tag bonus\r\n  if (HIGH_VALUE_TAGS.has(tag)) {\r\n    base += 0.2;\r\n  }\r\n\r\n  // Losing a tag is slightly less significant than gaining it\r\n  if (changeType === 'removed') {\r\n    base *= 0.9;\r\n  }\r\n\r\n  return Math.min(1.0, base);\r\n}", "parameters": [{"name": "tag", "type": "string", "optional": false}, {"name": "tagMetadata", "type": "TagDefinition | undefined", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}, {"name": "changeType", "type": "'added' | 'removed'", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/significanceCalculator.ts::calculateCreationBatchSignificance", "name": "calculateCreationBatchSignificance", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/significanceCalculator.ts", "sourceCode": "/**\r\n * Calculate significance score for a creation batch event.\r\n *\r\n * Uses entity count, relationship count, and primary entity prominence\r\n * to determine how narratively important the creation is.\r\n *\r\n * @param entities - The entities created in this batch\r\n * @param relationshipCount - Number of relationships created\r\n * @returns Significance score between 0.0 and 1.0\r\n */\r\nexport function calculateCreationBatchSignificance(\r\n  entities: HardState[],\r\n  relationshipCount: number\r\n): number {\r\n  if (entities.length === 0) return 0;\r\n\r\n  // Base significance for creation\r\n  let base = 0.3;\r\n\r\n  // Entity count bonus: +0.05 per entity (cap +0.2)\r\n  const entityBonus = Math.min(0.2, (entities.length - 1) * 0.05);\r\n  base += entityBonus;\r\n\r\n  // Relationship count bonus: +0.02 per relationship (cap +0.1)\r\n  const relationshipBonus = Math.min(0.1, relationshipCount * 0.02);\r\n  base += relationshipBonus;\r\n\r\n  // Primary entity prominence multiplier (first entity is the \"subject\")\r\n  const primaryEntity = entities[0];\r\n  base *= getProminenceMultiplier(primaryEntity.prominence);\r\n\r\n  return Math.min(1.0, base);\r\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "relationshipCount", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/significanceCalculator.ts::calculateRelationshipFormationSignificance", "name": "calculateRelationshipFormationSignificance", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/significanceCalculator.ts", "sourceCode": "/**\r\n * Calculate significance score for a relationship formation event.\r\n *\r\n * Uses relationship polarity and entity prominence to determine\r\n * how narratively important the new relationship is.\r\n *\r\n * @param srcEntity - The source entity in the relationship\r\n * @param dstEntity - The destination entity in the relationship\r\n * @param polarity - The polarity of the relationship kind (if any)\r\n * @returns Significance score between 0.0 and 1.0\r\n */\r\nexport function calculateRelationshipFormationSignificance(\r\n  srcEntity: HardState,\r\n  dstEntity: HardState,\r\n  polarity: Polarity | undefined\r\n): number {\r\n  // Base significance\r\n  let base = 0.35;\r\n\r\n  // Polarity modifier - polarized relationships are more narratively interesting\r\n  if (polarity === 'positive') {\r\n    base += 0.1; // Alliances, friendships are notable\r\n  } else if (polarity === 'negative') {\r\n    base += 0.15; // Conflicts, enmities are more dramatic\r\n  }\r\n  // Neutral relationships stay at base\r\n\r\n  // Prominence multiplier (use higher of the two)\r\n  const srcMult = getProminenceMultiplier(srcEntity.prominence);\r\n  const dstMult = getProminenceMultiplier(dstEntity.prominence);\r\n  base *= Math.max(srcMult, dstMult);\r\n\r\n  return Math.min(1.0, base);\r\n}", "parameters": [{"name": "srcEntity", "type": "HardState", "optional": false}, {"name": "dstEntity", "type": "HardState", "optional": false}, {"name": "polarity", "type": "Polarity | undefined", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/narrative/stateChangeTracker.ts::createDefaultNarrativeConfig", "name": "createDefaultNarrativeConfig", "kind": "function", "filePath": "apps/lore-weave/lib/narrative/stateChangeTracker.ts", "sourceCode": "/**\r\n * Create a default narrative config (enabled)\r\n */\r\nexport function createDefaultNarrativeConfig(): NarrativeConfig {\r\n  return {\r\n    enabled: true,\r\n    minSignificance: 0,\r\n  };\r\n}", "parameters": [], "returnType": "NarrativeConfig"}, {"id": "apps/lore-weave/lib/rules/actorMatcher.ts::matchesActorConfig", "name": "matchesActorConfig", "kind": "function", "filePath": "apps/lore-weave/lib/rules/actorMatcher.ts", "sourceCode": "/**\n * Check if an entity matches the actor configuration for an action.\n */\nexport function matchesActorConfig(\n  entity: HardState,\n  actorConfig: ActionActorConfig,\n  graphView: WorldRuntime\n): boolean {\n  const bindings: Record<string, HardState | undefined> = { actor: entity };\n  const ctx = createActionContext(graphView, bindings, entity);\n\n  // Eligibility: actor must appear in selection results (no random picking).\n  const selectionRule = {\n    ...actorConfig.selection,\n    pickStrategy: 'all' as const,\n    maxResults: undefined,\n  };\n\n  const candidates = selectEntities(selectionRule, ctx);\n  if (!candidates.some((candidate) => candidate.id === entity.id)) {\n    return false;\n  }\n\n  // Resolve optional instigator\n  if (actorConfig.instigator) {\n    const instigator = resolveSingleEntity(actorConfig.instigator, ctx);\n    if (!instigator && actorConfig.instigator.required) {\n      return false;\n    }\n    bindings.instigator = instigator;\n  }\n\n  // Evaluate conditions\n  if (actorConfig.conditions && actorConfig.conditions.length > 0) {\n    for (const condition of actorConfig.conditions) {\n      const result = evaluateCondition(condition, ctx, entity);\n      if (!result.passed) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "actorConfig", "type": "ActionActorConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/context.ts::createRuleContext", "name": "createRuleContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/context.ts", "sourceCode": "/**\r\n * Create a RuleContext from a WorldRuntime and EntityResolver.\r\n *\r\n * @param graph - Graph view\r\n * @param resolver - Entity resolver\r\n * @param self - Optional current entity\r\n */\r\nexport function createRuleContext(\n  graph: WorldRuntime,\n  resolver: EntityResolver,\n  self?: HardState\n): RuleContext {\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self,\n    entities: {},\n    values: {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "self", "type": "HardState", "optional": true}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/context.ts::createSystemContext", "name": "createSystemContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/context.ts", "sourceCode": "/**\r\n * Create a RuleContext for system execution (no variable resolution).\r\n *\r\n * @param graph - Graph view\r\n */\r\nexport function createSystemContext(graph: WorldRuntime): RuleContext {\n  const resolver = new SimpleEntityResolver(graph);\n\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self: undefined,\n    entities: {},\n    values: {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/context.ts::createActionContext", "name": "createActionContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/context.ts", "sourceCode": "/**\r\n * Create a RuleContext for action execution.\r\n *\r\n * @param graph - Graph view\r\n * @param actor - The acting entity\n * @param self - Optional current entity being evaluated\n */\nexport function createActionContext(\n  graph: WorldRuntime,\n  bindings: Record<string, HardState | undefined>,\n  self?: HardState,\n  values?: Record<string, string | number | boolean>\n): RuleContext {\n  const resolver = new ActionEntityResolver(graph, bindings);\n\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self,\n    entities: bindings,\n    values: values ?? {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}, {"name": "bindings", "type": "Record<string, HardState | undefined>", "optional": false}, {"name": "self", "type": "HardState", "optional": true}, {"name": "values", "type": "Record<string, string | number | boolean>", "optional": true}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/context.ts::withSelf", "name": "withSelf", "kind": "function", "filePath": "apps/lore-weave/lib/rules/context.ts", "sourceCode": "/**\r\n * Create a RuleContext with a specific entity as self.\r\n *\r\n * @param ctx - Base context\r\n * @param self - Entity to set as self\r\n */\r\nexport function withSelf(ctx: RuleContext, self: HardState): RuleContext {\r\n  return {\r\n    ...ctx,\r\n    self,\r\n  };\r\n}", "parameters": [{"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "self", "type": "HardState", "optional": false}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/graphPath.ts::evaluateGraphPath", "name": "evaluateGraphPath", "kind": "function", "filePath": "apps/lore-weave/lib/rules/graphPath.ts", "sourceCode": "/**\r\n * Evaluate a graph path assertion starting from an entity.\r\n * Returns true if the assertion passes.\r\n */\r\nexport function evaluateGraphPath(\r\n  startEntity: HardState,\r\n  assertion: GraphPathAssertion,\r\n  resolver: EntityResolver,\r\n  options?: GraphPathOptions\r\n): boolean {\r\n  const graphView = resolver.getGraphView();\r\n  const filterEvaluator = options?.filterEvaluator;\r\n\r\n  // Traverse the path, collecting entities at each step\r\n  let currentEntities: HardState[] = [startEntity];\r\n\r\n  for (const step of assertion.path) {\r\n    const nextEntities: HardState[] = [];\r\n\r\n    for (const entity of currentEntities) {\r\n      const related = traverseStep(entity, step, graphView);\r\n      nextEntities.push(...related);\r\n    }\r\n\r\n    let filteredEntities = nextEntities;\r\n    if (step.filters && step.filters.length > 0 && filterEvaluator) {\r\n      filteredEntities = filterEvaluator(nextEntities, step.filters, resolver, options);\r\n    }\r\n\r\n    // Store intermediate results if requested (for constraints like \"not_in\")\r\n    if (step.as) {\r\n      resolver.setPathSet(step.as, new Set(filteredEntities.map(e => e.id)));\r\n    }\r\n    currentEntities = filteredEntities;\r\n  }\r\n\r\n  // Apply constraints to filter final entities\r\n  if (assertion.where) {\r\n    currentEntities = currentEntities.filter(entity =>\r\n      evaluatePathConstraints(entity, startEntity, assertion.where!, resolver)\r\n    );\r\n  }\r\n\r\n  // Evaluate the assertion\r\n  switch (assertion.check) {\r\n    case 'exists':\r\n      return currentEntities.length > 0;\r\n\r\n    case 'not_exists':\r\n      return currentEntities.length === 0;\r\n\r\n    case 'count_min':\r\n      return currentEntities.length >= (assertion.count ?? 1);\r\n\r\n    case 'count_max':\r\n      return currentEntities.length <= (assertion.count ?? 0);\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}", "parameters": [{"name": "startEntity", "type": "HardState", "optional": false}, {"name": "assertion", "type": "GraphPathAssertion", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "options", "type": "GraphPathOptions", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/index.ts::createRuleContext", "name": "createRuleContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Create a RuleContext from a WorldRuntime and EntityResolver.\r\n *\r\n * @param graph - Graph view\r\n * @param resolver - Entity resolver\r\n * @param self - Optional current entity\r\n */\r\nexport function createRuleContext(\n  graph: WorldRuntime,\n  resolver: EntityResolver,\n  self?: HardState\n): RuleContext {\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self,\n    entities: {},\n    values: {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "self", "type": "HardState", "optional": true}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/index.ts::createSystemContext", "name": "createSystemContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Create a RuleContext for system execution (no variable resolution).\r\n *\r\n * @param graph - Graph view\r\n */\r\nexport function createSystemContext(graph: WorldRuntime): RuleContext {\n  const resolver = new SimpleEntityResolver(graph);\n\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self: undefined,\n    entities: {},\n    values: {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/index.ts::createActionContext", "name": "createActionContext", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Create a RuleContext for action execution.\r\n *\r\n * @param graph - Graph view\r\n * @param actor - The acting entity\n * @param self - Optional current entity being evaluated\n */\nexport function createActionContext(\n  graph: WorldRuntime,\n  bindings: Record<string, HardState | undefined>,\n  self?: HardState,\n  values?: Record<string, string | number | boolean>\n): RuleContext {\n  const resolver = new ActionEntityResolver(graph, bindings);\n\n  return {\n    graph,\n    tick: graph.tick,\n    resolver,\n    self,\n    entities: bindings,\n    values: values ?? {},\n    pathSets: new Map(),\n  };\n}", "parameters": [{"name": "graph", "type": "WorldRuntime", "optional": false}, {"name": "bindings", "type": "Record<string, HardState | undefined>", "optional": false}, {"name": "self", "type": "HardState", "optional": true}, {"name": "values", "type": "Record<string, string | number | boolean>", "optional": true}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/index.ts::withSelf", "name": "withSelf", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Create a RuleContext with a specific entity as self.\r\n *\r\n * @param ctx - Base context\r\n * @param self - Entity to set as self\r\n */\r\nexport function withSelf(ctx: RuleContext, self: HardState): RuleContext {\r\n  return {\r\n    ...ctx,\r\n    self,\r\n  };\r\n}", "parameters": [{"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "self", "type": "HardState", "optional": false}], "returnType": "RuleContext"}, {"id": "apps/lore-weave/lib/rules/index.ts::normalizeDirection", "name": "normalizeDirection", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Normalize direction aliases to canonical form.\r\n *\r\n * @param dir - Direction in any supported format\r\n * @returns Canonical direction\r\n */\r\nexport function normalizeDirection(\r\n  dir: 'out' | 'in' | 'any' | 'src' | 'dst' | 'both' | undefined\r\n): Direction {\r\n  switch (dir) {\r\n    case 'out':\r\n      return 'src';\r\n    case 'in':\r\n      return 'dst';\r\n    case 'any':\r\n      return 'both';\r\n    case 'src':\r\n    case 'dst':\r\n    case 'both':\r\n      return dir;\r\n    default:\r\n      return 'both';\r\n  }\r\n}", "parameters": [{"name": "dir", "type": "'out' | 'in' | 'any' | 'src' | 'dst' | 'both' | undefined", "optional": false}], "returnType": "Direction"}, {"id": "apps/lore-weave/lib/rules/index.ts::normalizeOperator", "name": "normalizeOperator", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Normalize comparison operator aliases to canonical form.\r\n *\r\n * @param op - Operator in any supported format\r\n * @returns Canonical operator\r\n */\r\nexport function normalizeOperator(\r\n  op: 'above' | 'below' | '>' | '<' | '>=' | '<=' | '==' | '!=' | undefined\r\n): ComparisonOperator {\r\n  switch (op) {\r\n    case 'above':\r\n      return '>';\r\n    case 'below':\r\n      return '<';\r\n    case '>':\r\n    case '<':\r\n    case '>=':\r\n    case '<=':\r\n    case '==':\r\n    case '!=':\r\n      return op;\r\n    default:\r\n      return '>=';\r\n  }\r\n}", "parameters": [{"name": "op", "type": "'above' | 'below' | '>' | '<' | '>=' | '<=' | '==' | '!=' | undefined", "optional": false}], "returnType": "ComparisonOperator"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyOperator", "name": "applyOperator", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Apply a comparison operator.\r\n *\r\n * @param a - Left operand\r\n * @param op - Comparison operator\r\n * @param b - Right operand\r\n * @returns Result of comparison\r\n */\r\nexport function applyOperator(a: number, op: ComparisonOperator, b: number): boolean {\r\n  switch (op) {\r\n    case '>':\r\n      return a > b;\r\n    case '<':\r\n      return a < b;\r\n    case '>=':\r\n      return a >= b;\r\n    case '<=':\r\n      return a <= b;\r\n    case '==':\r\n      return a === b;\r\n    case '!=':\r\n      return a !== b;\r\n  }\r\n}", "parameters": [{"name": "a", "type": "number", "optional": false}, {"name": "op", "type": "ComparisonOperator", "optional": false}, {"name": "b", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/index.ts::prominenceIndex", "name": "prominenceIndex", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Get prominence index (0-4) from numeric value.\r\n */\r\nexport function prominenceIndex(value: number): number {\r\n  return Math.min(4, Math.max(0, Math.floor(value)));\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::compareProminence", "name": "compareProminence", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Compare two prominence values.\r\n *\r\n * @returns negative if a < b, 0 if equal, positive if a > b\r\n */\r\nexport function compareProminence(a: number, b: number): number {\r\n  return a - b;\r\n}", "parameters": [{"name": "a", "type": "number", "optional": false}, {"name": "b", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::prominenceLabel", "name": "prominenceLabel", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "// recognized\r\n\r\n/**\r\n * Convert numeric prominence value to display label.\r\n *\r\n * Ranges:\r\n * - 0.0-0.99: forgotten\r\n * - 1.0-1.99: marginal\r\n * - 2.0-2.99: recognized\r\n * - 3.0-3.99: renowned\r\n * - 4.0-5.0: mythic\r\n */\r\nexport function prominenceLabel(value: number): ProminenceLabel {\r\n  if (value < 1) return 'forgotten';\r\n  if (value < 2) return 'marginal';\r\n  if (value < 3) return 'recognized';\r\n  if (value < 4) return 'renowned';\r\n  return 'mythic';\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "ProminenceLabel"}, {"id": "apps/lore-weave/lib/rules/index.ts::prominenceThreshold", "name": "prominenceThreshold", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Convert label to numeric threshold (lower bound of range).\r\n */\r\nexport function prominenceThreshold(label: ProminenceLabel): number {\r\n  switch (label) {\r\n    case 'forgotten': return 0;\r\n    case 'marginal': return 1;\r\n    case 'recognized': return 2;\r\n    case 'renowned': return 3;\r\n    case 'mythic': return 4;\r\n  }\r\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::clampProminence", "name": "clampProminence", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Clamp prominence value to valid range [0, 5].\r\n */\r\nexport function clampProminence(value: number): number {\r\n  return Math.max(PROMINENCE_MIN, Math.min(PROMINENCE_MAX, value));\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::evaluateCondition", "name": "evaluateCondition", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function evaluateCondition(\r\n  condition: Condition,\r\n  ctx: RuleContext,\r\n  entity?: HardState\r\n): ConditionResult {\r\n  const self = entity ?? ctx.self;\r\n  const handler = CONDITION_HANDLERS[condition.type];\r\n  if (handler) return handler(condition, ctx, self);\r\n\r\n  return {\r\n    passed: false,\r\n    diagnostic: `unknown condition type: ${condition.type}`,\r\n    details: { condition },\r\n  };\r\n}", "parameters": [{"name": "condition", "type": "Condition", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "entity", "type": "HardState", "optional": true}], "returnType": "ConditionResult"}, {"id": "apps/lore-weave/lib/rules/index.ts::evaluateMetric", "name": "evaluateMetric", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "// =============================================================================\n// MAIN EVALUATOR\n// =============================================================================\n\n/**\n * Evaluate a metric against the current context.\n *\n * @param metric - The metric to evaluate\n * @param ctx - The rule context\n * @param entity - Optional entity for per-entity metrics\n * @returns MetricResult with value and diagnostic info\n */\nexport function evaluateMetric(\n  metric: Metric,\n  ctx: MetricContext,\n  entity?: HardState\n): MetricResult {\n  switch (metric.type) {\n    // =========================================================================\n    // COUNT METRICS\n    // =========================================================================\n\n    case 'entity_count':\n      return evaluateEntityCount(metric, ctx);\n\n    case 'relationship_count':\n      return evaluateRelationshipCount(metric, ctx, entity);\n\n    case 'tag_count':\n      return evaluateTagCount(metric, ctx);\n\n    case 'total_entities':\n      return evaluateTotalEntities(metric, ctx);\n\n    case 'constant':\n      return evaluateConstant(metric);\n\n    case 'connection_count':\n      return evaluateConnectionCount(metric, ctx, entity);\n\n    // =========================================================================\n    // RATIO METRICS\n    // =========================================================================\n\n    case 'ratio':\n      return evaluateRatio(metric, ctx);\n\n    case 'status_ratio':\n      return evaluateStatusRatio(metric, ctx);\n\n    case 'cross_culture_ratio':\n      return evaluateCrossCultureRatio(metric, ctx);\n\n    // =========================================================================\n    // EVOLUTION METRICS\n    // =========================================================================\n\n    case 'shared_relationship':\n      return evaluateSharedRelationship(metric, ctx, entity);\n\n    // =========================================================================\n    // PROMINENCE METRICS\n    // =========================================================================\n\n    case 'prominence_multiplier':\n      return evaluateProminenceMultiplier(metric, entity);\n\n    case 'neighbor_prominence':\n      return evaluateNeighborProminence(metric, ctx, entity);\n\n    // =========================================================================\n    // NEIGHBOR METRICS\n    // =========================================================================\n\n    case 'neighbor_kind_count':\n      return evaluateNeighborKindCount(metric, ctx, entity);\n\n    // =========================================================================\n    // GRAPH TOPOLOGY METRICS\n    // =========================================================================\n\n    case 'component_size':\n      return evaluateComponentSize(metric, ctx, entity);\n\n    // =========================================================================\n    // DECAY/FALLOFF METRICS\n    // =========================================================================\n\n    case 'decay_rate':\n      return evaluateDecayRate(metric);\n\n    case 'falloff':\n      return evaluateFalloff(metric);\n\n    default:\n      return {\n        value: 0,\n        diagnostic: `unknown metric type: ${(metric as Metric).type}`,\n        details: { metric },\n      };\n  }\n}", "parameters": [{"name": "metric", "type": "Metric", "optional": false}, {"name": "ctx", "type": "MetricContext", "optional": false}, {"name": "entity", "type": "HardState", "optional": true}], "returnType": "MetricResult"}, {"id": "apps/lore-weave/lib/rules/index.ts::evaluateSimpleCount", "name": "evaluateSimpleCount", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Evaluate a simple count metric (for use in ratios).\n */\nexport function evaluateSimpleCount(\n  metric: SimpleCountMetric,\n  ctx: MetricContext\n): number {\n  switch (metric.type) {\n    case 'entity_count': {\n      let entities = ctx.graph.findEntities({ kind: metric.kind });\n      if (metric.subtype) {\n        entities = entities.filter((e) => e.subtype === metric.subtype);\n      }\n      if (metric.status) {\n        entities = entities.filter((e) => e.status === metric.status);\n      }\n      return entities.length;\n    }\n\n    case 'relationship_count': {\n      const rels = ctx.graph.getAllRelationships();\n      if (!metric.relationshipKinds || metric.relationshipKinds.length === 0) {\n        return rels.length;\n      }\n      return rels.filter((r) => metric.relationshipKinds!.includes(r.kind)).length;\n    }\n\n    case 'tag_count': {\n      const entities = ctx.graph.getEntities();\n      return entities.filter((e) =>\n        metric.tags.some((tag) => hasTag(e.tags, tag))\n      ).length;\n    }\n\n    case 'total_entities':\n      return ctx.graph.getEntities().length;\n\n    case 'constant':\n      return metric.value;\n\n    default:\n      return 0;\n  }\n}", "parameters": [{"name": "metric", "type": "SimpleCountMetric", "optional": false}, {"name": "ctx", "type": "MetricContext", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::describeMetric", "name": "describeMetric", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function describeMetric(metric: Metric): string {\n  switch (metric.type) {\n    case 'entity_count': {\n      const parts = [metric.kind];\n      if (metric.subtype) parts.push(`:${metric.subtype}`);\n      if (metric.status) parts.push(`(${metric.status})`);\n      return `${parts.join('')} count`;\n    }\n    case 'relationship_count':\n      return `${metric.relationshipKinds?.join('/') ?? 'all'} relationships`;\n    case 'tag_count':\n      return `entities with ${metric.tags.join('/')} tags`;\n    case 'total_entities':\n      return 'total entities';\n    case 'constant':\n      return 'constant';\n    case 'connection_count':\n      return `${metric.relationshipKinds?.join('/') ?? 'all'} connections`;\n    case 'ratio':\n      return `${describeSimpleCount(metric.numerator)}/${describeSimpleCount(metric.denominator)} ratio`;\n    case 'status_ratio':\n      return `${metric.kind} status ratio`;\n    case 'cross_culture_ratio':\n      return `cross-culture ${metric.relationshipKinds.join('/')} ratio`;\n    case 'shared_relationship':\n      return `shared ${Array.isArray(metric.sharedRelationshipKind) ? metric.sharedRelationshipKind.join('/') : metric.sharedRelationshipKind} relationships`;\n    case 'prominence_multiplier':\n      return `prominence multiplier (${metric.mode ?? 'success_chance'})`;\n    case 'neighbor_prominence':\n      return `neighbor prominence (${metric.relationshipKinds?.join('/') ?? 'all'} connections)`;\n    case 'neighbor_kind_count': {\n      const neighborKindSpec = metric.subtype ? `${metric.kind}:${metric.subtype}` : metric.kind;\n      return `neighbor ${neighborKindSpec} count via ${Array.isArray(metric.via) ? metric.via.join('/') : metric.via}`;\n    }\n    case 'component_size':\n      return `component size via ${metric.relationshipKinds.join('/')}`;\n    case 'decay_rate':\n      return `decay rate ${metric.rate}`;\n    case 'falloff':\n      return `${metric.falloffType} falloff`;\n    default:\n      return (metric as { type: string }).type;\n  }\n}", "parameters": [{"name": "metric", "type": "Metric", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/rules/index.ts::getProminenceMultiplierValue", "name": "getProminenceMultiplierValue", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "// forgotten->mythic\n\n/**\n * Get prominence multiplier with interpolation for numeric values.\n * Values between levels are linearly interpolated.\n */\nexport function getProminenceMultiplierValue(\n  prominence: number,\n  mode: ProminenceMultiplierMetric['mode'] = 'success_chance'\n): number {\n  const multipliers = mode === 'action_rate' ? ACTION_MULTIPLIERS : SUCCESS_MULTIPLIERS;\n\n  // Clamp to valid range\n  const clamped = Math.max(0, Math.min(5, prominence));\n  const level = Math.min(4, Math.floor(clamped));\n  const fraction = clamped - level;\n\n  const current = multipliers[level];\n  const next = multipliers[Math.min(level + 1, 4)];\n\n  return current + (next - current) * fraction;\n}", "parameters": [{"name": "prominence", "type": "number", "optional": false}, {"name": "mode", "type": "ProminenceMultiplierMetric['mode']", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/index.ts::prepareMutation", "name": "prepareMutation", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Prepare a mutation for application.\r\n *\r\n * This returns a MutationResult describing what changes should be made,\r\n * without actually modifying the graph. The caller is responsible for\r\n * applying the changes.\r\n *\r\n * @param mutation - The mutation to prepare\r\n * @param ctx - The rule context\r\n * @returns MutationResult with prepared changes\r\n */\r\nexport function prepareMutation(\r\n  mutation: Mutation,\r\n  ctx: RuleContext\r\n): MutationResult {\r\n  const result: MutationResult = {\r\n    applied: true,\r\n    diagnostic: '',\r\n    entityModifications: [],\r\n    relationshipsCreated: [],\r\n    relationshipsAdjusted: [],\r\n    relationshipsToArchive: [],\r\n    pressureChanges: {},\r\n    rateLimitUpdated: false,\r\n  };\r\n\r\n  switch (mutation.type) {\r\n    // =========================================================================\r\n    // TAG MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'set_tag':\r\n      return prepareSetTag(mutation, ctx, result);\r\n\r\n    case 'remove_tag':\r\n      return prepareRemoveTag(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // RELATIONSHIP MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'create_relationship':\r\n      return prepareCreateRelationship(mutation, ctx, result);\r\n\r\n    case 'archive_relationship':\r\n      return prepareArchiveRelationship(mutation, ctx, result);\r\n\r\n    case 'archive_all_relationships':\r\n      // Convert to archive_relationship format (without 'with' = archives all)\r\n      return prepareArchiveRelationship(\r\n        {\r\n          type: 'archive_relationship',\r\n          entity: mutation.entity,\r\n          relationshipKind: mutation.relationshipKind,\r\n          direction: mutation.direction,\r\n        },\r\n        ctx,\r\n        result\r\n      );\r\n\r\n    case 'adjust_relationship_strength':\r\n      return prepareAdjustRelationshipStrength(mutation, ctx, result);\r\n\r\n    case 'transfer_relationship':\r\n      return prepareTransferRelationship(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // ENTITY MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'change_status':\r\n      return prepareChangeStatus(mutation, ctx, result);\r\n\r\n    case 'adjust_prominence':\r\n      return prepareAdjustProminence(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // PRESSURE MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'modify_pressure':\r\n      return prepareModifyPressure(mutation, result);\r\n\r\n    // =========================================================================\r\n    // RATE LIMIT MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'update_rate_limit':\r\n      result.rateLimitUpdated = true;\r\n      result.diagnostic = 'rate limit updated';\r\n      return result;\r\n\r\n    // =========================================================================\r\n    // COMPOUND ACTIONS\r\n    // =========================================================================\r\n\r\n    case 'for_each_related':\r\n      return prepareForEachRelated(mutation, ctx, result);\r\n\r\n    case 'conditional':\r\n      return prepareConditional(mutation, ctx, result);\r\n\r\n    default:\r\n      result.applied = false;\r\n      result.diagnostic = `unknown mutation type: ${(mutation as Mutation).type}`;\r\n      return result;\r\n  }\r\n}", "parameters": [{"name": "mutation", "type": "Mutation", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "MutationResult"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyMutation", "name": "applyMutation", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Prepare and immediately apply a mutation.\r\n * Convenience wrapper for simple cases.\r\n *\r\n * @param mutation - The mutation to apply\r\n * @param ctx - The rule context\r\n * @returns MutationResult describing what was done\r\n */\r\nexport function applyMutation(mutation: Mutation, ctx: RuleContext): MutationResult {\r\n  const result = prepareMutation(mutation, ctx);\r\n  if (result.applied) {\r\n    applyMutationResult(result, ctx);\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "mutation", "type": "Mutation", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "MutationResult"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyMutationResult", "name": "applyMutationResult", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Apply a prepared mutation result to the graph.\r\n *\r\n * @param result - The prepared mutation result\r\n * @param ctx - The rule context\r\n */\r\nexport function applyMutationResult(result: MutationResult, ctx: RuleContext): void {\r\n  // Apply entity modifications\r\n  for (const mod of result.entityModifications) {\r\n    const entity = ctx.graph.getEntity(mod.id);\r\n    if (!entity) continue;\r\n\r\n    if (mod.changes.status !== undefined) {\r\n      ctx.graph.updateEntityStatus(mod.id, mod.changes.status);\r\n    }\r\n\r\n    if (mod.changes.prominence !== undefined) {\r\n      ctx.graph.updateEntity(mod.id, { prominence: mod.changes.prominence });\r\n    }\r\n\r\n    if (mod.changes.tags !== undefined) {\r\n      const newTags = applyTagPatch(entity.tags, mod.changes.tags);\r\n      ctx.graph.updateEntity(mod.id, { tags: newTags });\r\n    }\r\n  }\r\n\r\n  // Create relationships\r\n  for (const rel of result.relationshipsCreated) {\r\n    ctx.graph.createRelationship(rel.kind, rel.src, rel.dst, rel.strength);\r\n  }\r\n\r\n  // Adjust relationships\r\n  for (const rel of result.relationshipsAdjusted) {\r\n    ctx.graph.modifyRelationshipStrength(rel.src, rel.dst, rel.kind, rel.delta);\r\n  }\r\n\r\n  // Archive relationships\r\n  for (const rel of result.relationshipsToArchive) {\r\n    ctx.graph.archiveRelationship(rel.src, rel.dst, rel.kind);\r\n  }\r\n\r\n  // Apply pressure changes\r\n  for (const [pressureId, delta] of Object.entries(result.pressureChanges)) {\r\n    ctx.graph.modifyPressure(pressureId, delta);\r\n  }\r\n\r\n  // Update rate limit state if needed\r\n  if (result.rateLimitUpdated && ctx.graph.rateLimitState) {\r\n    ctx.graph.rateLimitState.lastCreationTick = ctx.tick;\r\n    ctx.graph.rateLimitState.creationsThisEpoch++;\r\n  }\r\n}", "parameters": [{"name": "result", "type": "MutationResult", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyTagPatch", "name": "applyTagPatch", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function applyTagPatch(\r\n  base: Record<string, TagValue> | undefined,\r\n  patch: TagPatch\r\n): Record<string, TagValue> {\r\n  const merged: Record<string, TagValue> = { ...(base ?? {}) };\r\n\r\n  for (const [tag, value] of Object.entries(patch)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (value === undefined) {\r\n      delete merged[tag];\r\n    } else {\r\n      merged[tag] = value;\r\n    }\r\n  }\r\n\r\n  if ('undefined' in merged) {\r\n    delete merged['undefined'];\r\n  }\r\n  if ('' in merged) {\r\n    delete merged[''];\r\n  }\r\n\r\n  return merged;\r\n}", "parameters": [{"name": "base", "type": "Record<string, TagValue> | undefined", "optional": false}, {"name": "patch", "type": "TagPatch", "optional": false}], "returnType": "Record<string, TagValue>"}, {"id": "apps/lore-weave/lib/rules/index.ts::buildTagPatch", "name": "buildTagPatch", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function buildTagPatch(\r\n  before: Record<string, TagValue> | undefined,\r\n  after: Record<string, TagValue>\r\n): TagPatch {\r\n  const base = before ?? {};\r\n  const patch: TagPatch = {};\r\n\r\n  for (const [tag, value] of Object.entries(after)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (base[tag] !== value) {\r\n      patch[tag] = value;\r\n    }\r\n  }\r\n\r\n  for (const tag of Object.keys(base)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (!(tag in after)) {\r\n      patch[tag] = undefined;\r\n    }\r\n  }\r\n\r\n  return patch;\r\n}", "parameters": [{"name": "before", "type": "Record<string, TagValue> | undefined", "optional": false}, {"name": "after", "type": "Record<string, TagValue>", "optional": false}], "returnType": "TagPatch"}, {"id": "apps/lore-weave/lib/rules/index.ts::applySelectionFilter", "name": "applySelectionFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Apply a single selection filter to a list of entities.\r\n */\r\nexport function applySelectionFilter(\r\n  entities: HardState[],\r\n  filter: SelectionFilter,\r\n  resolver: EntityResolver,\r\n  graphPathOptions?: GraphPathOptions\r\n): HardState[] {\r\n  switch (filter.type) {\r\n    case 'exclude': {\r\n      const excludeIds = new Set(\r\n        filter.entities\r\n          .map(ref => resolver.resolveEntity(ref)?.id)\r\n          .filter((id): id is string => id !== undefined)\r\n      );\r\n      return entities.filter(e => !excludeIds.has(e.id));\r\n    }\r\n\r\n    case 'has_relationship': {\r\n      const graphView = resolver.getGraphView();\r\n      const withEntity = filter.with ? resolver.resolveEntity(filter.with) : undefined;\r\n      return entities.filter(entity => {\r\n        const relationships = graphView.getRelationships(entity.id, filter.kind);\r\n        return relationships.some(link => {\r\n          if (filter.direction === 'src' && link.src !== entity.id) return false;\r\n          if (filter.direction === 'dst' && link.dst !== entity.id) return false;\r\n          if (withEntity) {\r\n            const otherId = link.src === entity.id ? link.dst : link.src;\r\n            return otherId === withEntity.id;\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n    }\r\n\r\n    case 'lacks_relationship': {\r\n      const graphView = resolver.getGraphView();\r\n      const withEntity = filter.with ? resolver.resolveEntity(filter.with) : undefined;\r\n      return entities.filter(entity => {\r\n        const relationships = graphView.getRelationships(entity.id, filter.kind);\r\n        const hasRel = relationships.some(link => {\r\n          if (withEntity) {\r\n            const otherId = link.src === entity.id ? link.dst : link.src;\r\n            return otherId === withEntity.id;\r\n          }\r\n          return true;\r\n        });\r\n        return !hasRel;\r\n      });\r\n    }\r\n\r\n    case 'has_tag': {\r\n      return entities.filter(entity => {\r\n        if (!hasTag(entity.tags, filter.tag)) return false;\r\n        if (filter.value === undefined) return true;\r\n        return getTagValue(entity.tags, filter.tag) === filter.value;\r\n      });\r\n    }\r\n\r\n    case 'has_tags': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => tagList.every(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'has_any_tag': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => tagList.some(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'lacks_tag': {\r\n      return entities.filter(entity => {\r\n        if (!hasTag(entity.tags, filter.tag)) return true; // Doesn't have tag, include\r\n        if (filter.value === undefined) return false; // Has tag, exclude\r\n        // Has tag, only exclude if value matches\r\n        return getTagValue(entity.tags, filter.tag) !== filter.value;\r\n      });\r\n    }\r\n\r\n    case 'lacks_any_tag': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => !tagList.some(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'has_culture': {\r\n      return entities.filter(e => e.culture === filter.culture);\r\n    }\r\n\r\n    case 'not_has_culture': {\r\n      return entities.filter(e => e.culture !== filter.culture);\r\n    }\r\n\r\n    case 'matches_culture': {\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n      return entities.filter(e => e.culture === refEntity.culture);\r\n    }\r\n\r\n    case 'not_matches_culture': {\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n      return entities.filter(e => e.culture !== refEntity.culture);\r\n    }\r\n\r\n    case 'has_status': {\r\n      return entities.filter(e => e.status === filter.status);\r\n    }\r\n\r\n    case 'has_prominence': {\r\n      const minValue = prominenceThreshold(filter.minProminence);\r\n      return entities.filter(e => e.prominence >= minValue);\r\n    }\r\n\r\n    case 'shares_related': {\r\n      // Find entities that share a common related entity with the reference\r\n      const graphView = resolver.getGraphView();\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n\r\n      const refRelated = graphView\r\n        .getConnectedEntities(refEntity.id, filter.relationshipKind, 'both')\r\n        .map(entity => entity.id);\r\n\r\n      if (refRelated.length === 0) return [];\r\n\r\n      const refRelatedSet = new Set(refRelated);\r\n\r\n      return entities.filter(entity => {\r\n        const entityRelated = graphView\r\n          .getConnectedEntities(entity.id, filter.relationshipKind, 'both')\r\n          .map(related => related.id);\r\n        return entityRelated.some(id => refRelatedSet.has(id));\r\n      });\r\n    }\r\n\r\n    case 'graph_path': {\r\n      const options = resolveGraphPathOptions(graphPathOptions);\r\n      return entities.filter(entity =>\r\n        evaluateGraphPath(entity, filter.assert, resolver, options)\r\n      );\r\n    }\r\n\r\n    case 'component_size': {\r\n      const graphView = resolver.getGraphView();\r\n      const rels = graphView.getAllRelationships();\r\n      const minStrength = filter.minStrength ?? 0;\r\n\r\n      // Build adjacency index for the specified relationship kinds\r\n      const adjacency = new Map<string, Set<string>>();\r\n      for (const link of rels) {\r\n        if (!filter.relationshipKinds.includes(link.kind)) continue;\r\n        if ((link.strength ?? 0) < minStrength) continue;\r\n\r\n        // Bidirectional edges (undirected graph)\r\n        if (!adjacency.has(link.src)) adjacency.set(link.src, new Set());\r\n        if (!adjacency.has(link.dst)) adjacency.set(link.dst, new Set());\r\n        adjacency.get(link.src)!.add(link.dst);\r\n        adjacency.get(link.dst)!.add(link.src);\r\n      }\r\n\r\n      return entities.filter(entity => {\r\n        // DFS to find component size\r\n        const visited = new Set<string>([entity.id]);\r\n        const stack = [entity.id];\r\n\r\n        while (stack.length > 0) {\r\n          const current = stack.pop()!;\r\n          const neighbors = adjacency.get(current);\r\n          if (neighbors) {\r\n            for (const neighborId of neighbors) {\r\n              if (!visited.has(neighborId)) {\r\n                visited.add(neighborId);\r\n                stack.push(neighborId);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const componentSize = visited.size;\r\n        const minOk = filter.min === undefined || componentSize >= filter.min;\r\n        const maxOk = filter.max === undefined || componentSize <= filter.max;\r\n        return minOk && maxOk;\r\n      });\r\n    }\r\n\r\n    default:\r\n      return entities;\r\n  }\r\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filter", "type": "SelectionFilter", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "graphPathOptions", "type": "GraphPathOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::applySelectionFilters", "name": "applySelectionFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Apply a list of selection filters to entities.\r\n * Filters are applied in sequence (AND logic).\r\n */\r\nexport function applySelectionFilters(\r\n  entities: HardState[],\r\n  filters: SelectionFilter[] | undefined,\r\n  resolver: EntityResolver,\r\n  graphPathOptions?: GraphPathOptions\r\n): HardState[] {\r\n  if (!filters || filters.length === 0) return entities;\r\n\r\n  let result = entities;\r\n  const options = resolveGraphPathOptions(graphPathOptions);\r\n\r\n  for (const filter of filters) {\r\n    result = applySelectionFilter(result, filter, resolver, options);\r\n  }\r\n\r\n  return result;\r\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "graphPathOptions", "type": "GraphPathOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::entityPassesFilter", "name": "entityPassesFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Check if an entity passes a single filter.\r\n * Useful for checking individual entities without creating a list.\r\n */\r\nexport function entityPassesFilter(\r\n  entity: HardState,\r\n  filter: SelectionFilter,\r\n  resolver: EntityResolver\r\n): boolean {\r\n  const result = applySelectionFilter([entity], filter, resolver);\r\n  return result.length > 0;\r\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "filter", "type": "SelectionFilter", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/index.ts::entityPassesAllFilters", "name": "entityPassesAllFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Check if an entity passes all filters.\r\n */\r\nexport function entityPassesAllFilters(\r\n  entity: HardState,\r\n  filters: SelectionFilter[] | undefined,\r\n  resolver: EntityResolver\r\n): boolean {\r\n  if (!filters || filters.length === 0) return true;\r\n\r\n  for (const filter of filters) {\r\n    if (!entityPassesFilter(entity, filter, resolver)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/index.ts::selectEntities", "name": "selectEntities", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Select entities using a SelectionRule.\n */\nexport function selectEntities(\n  rule: SelectionRule,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  const graphView = ctx.graph;\n  let entities: HardState[];\n  let kinds: string[];\n  if (rule.kinds && rule.kinds.length > 0) {\n    kinds = rule.kinds;\n  } else if (rule.kind) {\n    kinds = [rule.kind];\n  } else {\n    kinds = [];\n  }\n  const kindLabel = kinds.length > 0 ? kinds.join('|') : 'any';\n\n  // Include historical entities if the rule explicitly asks for them\n  const needsHistorical = rule.status === 'historical' || rule.statuses?.includes('historical');\n\n  const getCandidatesByKind = (): HardState[] => {\n    if (kinds.length === 0 || kinds.includes('any')) {\n      return graphView.getEntities({ includeHistorical: needsHistorical });\n    }\n    if (kinds.length === 1 && rule.kind && (!rule.kinds || rule.kinds.length === 0)) {\n      return graphView.findEntities({ kind: rule.kind, includeHistorical: needsHistorical });\n    }\n    return graphView.getEntities({ includeHistorical: needsHistorical }).filter((e) => kinds.includes(e.kind));\n  };\n\n  switch (rule.strategy) {\n    case 'by_kind': {\n      entities = getCandidatesByKind();\n      pushTrace(trace, `kind=${kindLabel}`, entities.length);\n      break;\n    }\n\n    case 'by_preference_order': {\n      entities = [];\n      const allEntities = getCandidatesByKind();\n      for (const subtype of rule.subtypePreferences || []) {\n        const matches = allEntities.filter((e) => e.subtype === subtype);\n        if (matches.length > 0) {\n          entities = matches;\n          break;\n        }\n      }\n      if (entities.length === 0) {\n        entities = allEntities;\n      }\n      pushTrace(trace, `preference_order=${kindLabel}`, entities.length);\n      break;\n    }\n\n    case 'by_relationship': {\n      const allEntities = getCandidatesByKind();\n      const direction = normalizeDirection(rule.direction);\n      const mustHave = rule.mustHave === true;\n      entities = allEntities.filter((entity) => {\n        const relationships = ctx.graph.getRelationships(entity.id, rule.relationshipKind);\n        const hasRel = relationships.some((link) => {\n          if (direction === 'src') return link.src === entity.id;\n          if (direction === 'dst') return link.dst === entity.id;\n          return link.src === entity.id || link.dst === entity.id;\n        });\n        return mustHave ? hasRel : !hasRel;\n      });\n      pushTrace(trace, `relationship=${rule.relationshipKind ?? 'any'}`, entities.length);\n      break;\n    }\n\n    case 'by_proximity': {\n      const refEntity = ctx.resolver.resolveEntity(rule.referenceEntity || '$target');\n      if (!refEntity?.coordinates) {\n        entities = [];\n        pushTrace(trace, 'proximity: no reference coordinates', 0);\n        break;\n      }\n      const maxDist = rule.maxDistance || 50;\n      entities = getCandidatesByKind().filter((e) => {\n        if (!e.coordinates) return false;\n        const dx = e.coordinates.x - refEntity.coordinates.x;\n        const dy = e.coordinates.y - refEntity.coordinates.y;\n        const dz = e.coordinates.z - refEntity.coordinates.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz) <= maxDist;\n      });\n      pushTrace(trace, `proximity<=${maxDist}`, entities.length);\n      break;\n    }\n\n    case 'by_prominence': {\n      const minLabel = (rule.minProminence || 'marginal') as ProminenceLabel;\n      const minThreshold = prominenceThreshold(minLabel);\n      entities = getCandidatesByKind().filter((e) => {\n        return e.prominence >= minThreshold;\n      });\n      pushTrace(trace, `prominence>=${rule.minProminence ?? 'marginal'}`, entities.length);\n      break;\n    }\n\n    default:\n      entities = [];\n      pushTrace(trace, 'unknown strategy', 0);\n  }\n\n  if (rule.subtypes && rule.subtypes.length > 0) {\n    entities = entities.filter((e) => rule.subtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype in [${rule.subtypes.join(', ')}]`, entities.length);\n  }\n\n  if (rule.excludeSubtypes && rule.excludeSubtypes.length > 0) {\n    entities = entities.filter((e) => !rule.excludeSubtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype not in [${rule.excludeSubtypes.join(', ')}]`, entities.length);\n  }\n\n  if (rule.status) {\n    entities = entities.filter((e) => e.status === rule.status);\n    pushTrace(trace, `status=${rule.status}`, entities.length);\n  }\n\n  if (rule.statuses && rule.statuses.length > 0) {\n    entities = entities.filter((e) => rule.statuses!.includes(e.status));\n    pushTrace(trace, `status in [${rule.statuses.join(', ')}]`, entities.length);\n  }\n\n  if (rule.notStatus) {\n    entities = entities.filter((e) => e.status !== rule.notStatus);\n    pushTrace(trace, `status!=${rule.notStatus}`, entities.length);\n  }\n\n  if (rule.filters && rule.filters.length > 0) {\n    for (const filter of rule.filters) {\n      entities = applySelectionFilters(entities, [filter], ctx.resolver);\n      pushTrace(trace, describeSelectionFilter(filter), entities.length);\n    }\n  }\n\n  entities = applySaturationLimits(entities, rule.saturationLimits, ctx);\n\n  return applyPickStrategyWithBias(entities, rule, ctx);\n}", "parameters": [{"name": "rule", "type": "SelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::selectVariableEntities", "name": "selectVariableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Select candidates for a variable selection rule.\n */\nexport function selectVariableEntities(\n  select: VariableSelectionRule,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  const graphView = ctx.graph;\n  let entities: HardState[];\n\n  // Include historical entities if the rule explicitly asks for them\n  const needsHistorical = select.status === 'historical' || select.statuses?.includes('historical');\n\n  if (select.from && select.from !== 'graph') {\n    // Check if this is a path-based traversal\n    if (isPathBasedSpec(select.from)) {\n      // Path-based traversal: follow multiple hops\n      const steps = select.from.path;\n      if (steps.length === 0) {\n        pushTrace(trace, 'empty path', 0);\n        return [];\n      }\n\n      // Get starting entities from first step's 'from' field\n      const firstStep = steps[0];\n      let startEntities: HardState[];\n\n      if (firstStep.from) {\n        const startEntity = ctx.resolver.resolveEntity(firstStep.from);\n        if (!startEntity) {\n          pushTrace(trace, `path start ${firstStep.from} (not found)`, 0);\n          return [];\n        }\n        startEntities = [startEntity];\n        pushTrace(trace, `path start: ${startEntity.name || startEntity.id}`, 1);\n      } else {\n        // No 'from' on first step - use all entities matching kind filters\n        startEntities = graphView.getEntities({ includeHistorical: needsHistorical });\n        pushTrace(trace, 'path start: all entities', startEntities.length);\n      }\n\n      // Traverse the path\n      entities = traversePath(startEntities, steps, ctx, trace);\n    } else {\n      // Single-hop related entities (legacy format)\n      const relatedTo = ctx.resolver.resolveEntity(select.from.relatedTo);\n      if (!relatedTo) {\n        pushTrace(trace, `related to ${select.from.relatedTo} (not found)`, 0);\n        return [];\n      }\n      const direction = normalizeDirection(select.from.direction);\n      entities = graphView.getConnectedEntities(\n        relatedTo.id,\n        select.from.relationshipKind,\n        direction\n      );\n      pushTrace(trace, `via ${select.from.relationshipKind} from ${relatedTo.name || relatedTo.id}`, entities.length);\n    }\n  } else {\n    if (select.kinds && select.kinds.length > 0) {\n      entities = graphView.getEntities({ includeHistorical: needsHistorical }).filter((e) => select.kinds!.includes(e.kind));\n      pushTrace(trace, `${select.kinds.join('|')} entities`, entities.length);\n    } else if (select.kind) {\n      entities = graphView.findEntities({ kind: select.kind, includeHistorical: needsHistorical });\n      pushTrace(trace, `${select.kind} entities`, entities.length);\n    } else {\n      entities = graphView.getEntities({ includeHistorical: needsHistorical });\n      pushTrace(trace, 'all entities', entities.length);\n    }\n  }\n\n  if (select.kinds && select.kinds.length > 0) {\n    entities = entities.filter((e) => select.kinds!.includes(e.kind));\n    pushTrace(trace, `kind in [${select.kinds.join(', ')}]`, entities.length);\n  } else if (select.kind) {\n    entities = entities.filter((e) => e.kind === select.kind);\n    pushTrace(trace, `kind=${select.kind}`, entities.length);\n  }\n\n  if (select.subtypes && select.subtypes.length > 0) {\n    entities = entities.filter((e) => select.subtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype in [${select.subtypes.join(', ')}]`, entities.length);\n  }\n\n  if (select.status) {\n    entities = entities.filter((e) => e.status === select.status);\n    pushTrace(trace, `status=${select.status}`, entities.length);\n  }\n\n  if (select.statuses && select.statuses.length > 0) {\n    entities = entities.filter((e) => select.statuses!.includes(e.status));\n    pushTrace(trace, `status in [${select.statuses.join(', ')}]`, entities.length);\n  }\n\n  if (select.notStatus) {\n    entities = entities.filter((e) => e.status !== select.notStatus);\n    pushTrace(trace, `status!=${select.notStatus}`, entities.length);\n  }\n\n  if (select.filters && select.filters.length > 0) {\n    for (const filter of select.filters) {\n      entities = applySelectionFilters(entities, [filter], ctx.resolver);\n      pushTrace(trace, describeSelectionFilter(filter), entities.length);\n    }\n  }\n\n  return applyPreferFilters(entities, select.preferFilters, ctx, trace);\n}", "parameters": [{"name": "select", "type": "VariableSelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::resolveSingleVariable", "name": "resolveSingleVariable", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Resolve a single variable selection.\n *\n * This is the core variable resolution function used by both templateInterpreter\n * and thresholdTrigger systems.\n *\n * @param select - Variable selection rule\n * @param ctx - Rule context with graph, resolver, and any bound entities\n * @returns Single entity, array of entities, or undefined if no matches\n */\nexport function resolveSingleVariable(\n  select: VariableSelectionRule,\n  ctx: RuleContext\n): HardState | HardState[] | undefined {\n  const candidates = selectVariableEntities(select, ctx);\n\n  if (candidates.length === 0) {\n    return undefined;\n  }\n\n  const pickStrategy = select.pickStrategy ?? 'random';\n  const picked = applyPickStrategy(candidates, pickStrategy, select.maxResults);\n\n  if (pickStrategy === 'all' || (select.maxResults && select.maxResults > 1)) {\n    return picked;\n  }\n  return picked[0];\n}", "parameters": [{"name": "select", "type": "VariableSelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "HardState | HardState[] | undefined"}, {"id": "apps/lore-weave/lib/rules/index.ts::resolveVariablesForEntity", "name": "resolveVariablesForEntity", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Resolve a set of variables for a given self entity.\n *\n * Variables are resolved in order, and each resolved variable becomes available\n * to subsequent variable selections (allowing $var1 to reference $var2 if $var2\n * was defined earlier).\n *\n * This is a convenience wrapper around resolveSingleVariable for systems that\n * need to resolve all variables at once.\n *\n * @param variables - Map of variable names to definitions\n * @param baseCtx - Base rule context (should have graph and resolver)\n * @param self - The entity to bind as $self\n * @returns Record of resolved variables, or null if any required variable couldn't be resolved\n */\nexport function resolveVariablesForEntity(\n  variables: Record<string, VariableDefinitionForResolution>,\n  baseCtx: RuleContext,\n  self: HardState\n): Record<string, HardState> | null {\n  const resolved: Record<string, HardState> = {};\n\n  // Create a resolver that can resolve $self and previously resolved variables\n  const createResolvingContext = (): RuleContext => ({\n    ...baseCtx,\n    self,\n    entities: { ...baseCtx.entities, self, ...resolved },\n    resolver: {\n      resolveEntity: (ref: string): HardState | undefined => {\n        if (ref === '$self') return self;\n        if (ref.startsWith('$')) {\n          const name = ref.slice(1);\n          if (resolved[name]) return resolved[name];\n          if (name === 'self') return self;\n        }\n        return baseCtx.resolver.resolveEntity(ref);\n      },\n      getGraphView: () => baseCtx.resolver.getGraphView(),\n      setPathSet: (name: string, ids: Set<string>) => baseCtx.resolver.setPathSet(name, ids),\n      getPathSet: (name: string) => baseCtx.resolver.getPathSet(name),\n    },\n  });\n\n  // Resolve variables in order\n  for (const [varName, varDef] of Object.entries(variables)) {\n    // Strip leading $ from variable name for storage\n    const cleanName = varName.startsWith('$') ? varName.slice(1) : varName;\n\n    const ctx = createResolvingContext();\n    const result = resolveSingleVariable(varDef.select, ctx);\n\n    if (!result || (Array.isArray(result) && result.length === 0)) {\n      if (varDef.required) {\n        // Required variable not found - skip this entity\n        return null;\n      }\n      // Optional variable not found - continue without it\n      continue;\n    }\n\n    // For system variables, we only support single entities\n    resolved[cleanName] = Array.isArray(result) ? result[0] : result;\n  }\n\n  return resolved;\n}", "parameters": [{"name": "variables", "type": "Record<string, VariableDefinitionForResolution>", "optional": false}, {"name": "baseCtx", "type": "RuleContext", "optional": false}, {"name": "self", "type": "HardState", "optional": false}], "returnType": "Record<string, HardState> | null"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyEntityCriteria", "name": "applyEntityCriteria", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Apply base selection criteria to a set of entities.\n */\nexport function applyEntityCriteria(\n  entities: HardState[],\n  criteria: EntitySelectionCriteria\n): HardState[] {\n  let result = entities;\n\n  if (criteria.kind) {\n    result = result.filter((e) => e.kind === criteria.kind);\n  }\n\n  if (criteria.kinds && criteria.kinds.length > 0) {\n    result = result.filter((e) => criteria.kinds!.includes(e.kind));\n  }\n\n  if (criteria.subtypes && criteria.subtypes.length > 0) {\n    result = result.filter((e) => criteria.subtypes!.includes(e.subtype));\n  }\n\n  if (criteria.excludeSubtypes && criteria.excludeSubtypes.length > 0) {\n    result = result.filter((e) => !criteria.excludeSubtypes!.includes(e.subtype));\n  }\n\n  if (criteria.status) {\n    result = result.filter((e) => e.status === criteria.status);\n  }\n\n  if (criteria.statuses && criteria.statuses.length > 0) {\n    result = result.filter((e) => criteria.statuses!.includes(e.status));\n  }\n\n  if (criteria.notStatus) {\n    result = result.filter((e) => e.status !== criteria.notStatus);\n  }\n\n  if (criteria.hasTag) {\n    result = result.filter((e) => hasTag(e.tags, criteria.hasTag!));\n  }\n\n  if (criteria.notHasTag) {\n    result = result.filter((e) => !hasTag(e.tags, criteria.notHasTag!));\n  }\n\n  return result;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "criteria", "type": "EntitySelectionCriteria", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyPreferFilters", "name": "applyPreferFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Apply prefer filters to an entity list, falling back to the original list.\n */\nexport function applyPreferFilters(\n  entities: HardState[],\n  filters: SelectionFilter[] | undefined,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  if (!filters || filters.length === 0) return entities;\n\n  let preferred = entities;\n  for (const filter of filters) {\n    preferred = applySelectionFilters(preferred, [filter], ctx.resolver);\n  }\n\n  if (preferred.length > 0) {\n    pushTrace(trace, 'prefer filters matched', preferred.length);\n    return preferred;\n  }\n\n  pushTrace(trace, 'prefer filters (no match, using all)', entities.length);\n  return entities;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::applyPickStrategy", "name": "applyPickStrategy", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function applyPickStrategy(\n  entities: HardState[],\n  pickStrategy: SelectionRule['pickStrategy']   | undefined,\n  maxResults?: number\n): HardState[] {\n  const limit = maxResults && maxResults > 0 ? Math.min(maxResults, entities.length) : undefined;\n\n  switch (pickStrategy) {\n    case 'random': {\n      if (limit) return sampleRandom(entities, limit);\n      return entities.length > 0 ? [pickRandom(entities)] : [];\n    }\n    case 'weighted':\n      if (limit) return sampleWeighted(entities, limit);\n      const picked = pickWeighted(entities);\n      return picked ? [picked] : [];\n    case 'first':\n      return limit ? entities.slice(0, limit) : entities.slice(0, 1);\n    case 'all':\n      return limit ? entities.slice(0, limit) : entities;\n    default:\n      return limit ? entities.slice(0, limit) : entities;\n  }\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "pickStrategy", "type": "SelectionRule['pickStrategy']   | undefined", "optional": false}, {"name": "maxResults", "type": "number", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::applySaturationLimits", "name": "applySaturationLimits", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Apply saturation limits to filter out entities that have too many relationships.\n * Counts unique connected entities, not raw relationships.\n * This handles bidirectional relationships correctly (A\u2192B and B\u2192A count as one connection).\n */\nexport function applySaturationLimits(\n  entities: HardState[],\n  limits: SaturationLimit[] | undefined,\n  ctx: RuleContext\n): HardState[] {\n  if (!limits || limits.length === 0) return entities;\n\n  return entities.filter((entity) => {\n    for (const limit of limits) {\n      const relationships = ctx.graph.getRelationships(entity.id, limit.relationshipKind);\n\n      // Use a Set to count unique connected entities, not raw relationships\n      // This correctly handles bidirectional relationships stored as two records\n      const connectedEntities = new Set<string>();\n\n      for (const rel of relationships) {\n        const otherId = rel.src === entity.id ? rel.dst : rel.src;\n        if (limit.fromKind) {\n          const otherEntity = ctx.graph.getEntity(otherId);\n          if (!otherEntity || otherEntity.kind !== limit.fromKind) continue;\n          if (limit.fromSubtype && otherEntity.subtype !== limit.fromSubtype) continue;\n        }\n        connectedEntities.add(otherId);\n      }\n\n      if (connectedEntities.size >= limit.maxCount) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "limits", "type": "SaturationLimit[] | undefined", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/index.ts::describeSelectionFilter", "name": "describeSelectionFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "export function describeSelectionFilter(filter: SelectionFilter): string {\n  switch (filter.type) {\n    case 'exclude':\n      return `exclude [${filter.entities.join(', ')}]`;\n    case 'has_relationship':\n      return `has_relationship '${filter.kind}'${filter.with ? ' with ' + filter.with : ''}`;\n    case 'lacks_relationship':\n      return `lacks_relationship '${filter.kind}'${filter.with ? ' with ' + filter.with : ''}`;\n    case 'has_tag':\n      return `has_tag '${filter.tag}'${filter.value !== undefined ? ' = ' + filter.value : ''}`;\n    case 'has_tags':\n      return `has_tags [${filter.tags.join(', ')}]`;\n    case 'has_any_tag':\n      return `has_any_tag [${filter.tags.join(', ')}]`;\n    case 'lacks_tag':\n      return `lacks_tag '${filter.tag}'${filter.value !== undefined ? ' = ' + filter.value : ''}`;\n    case 'lacks_any_tag':\n      return `lacks_any_tag [${filter.tags.join(', ')}]`;\n    case 'has_culture':\n      return `has_culture '${filter.culture}'`;\n    case 'matches_culture':\n      return `matches_culture with ${filter.with}`;\n    case 'not_matches_culture':\n      return `not_matches_culture with ${filter.with}`;\n    case 'has_status':\n      return `has_status '${filter.status}'`;\n    case 'has_prominence':\n      return `has_prominence >= ${filter.minProminence}`;\n    case 'shares_related':\n      return `shares_related '${filter.relationshipKind}' with ${filter.with}`;\n    case 'graph_path':\n      return `graph_path ${filter.assert.check}`;\n    default:\n      return 'unknown filter';\n  }\n}", "parameters": [{"name": "filter", "type": "SelectionFilter", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/rules/index.ts::evaluateGraphPath", "name": "evaluateGraphPath", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\r\n * Evaluate a graph path assertion starting from an entity.\r\n * Returns true if the assertion passes.\r\n */\r\nexport function evaluateGraphPath(\r\n  startEntity: HardState,\r\n  assertion: GraphPathAssertion,\r\n  resolver: EntityResolver,\r\n  options?: GraphPathOptions\r\n): boolean {\r\n  const graphView = resolver.getGraphView();\r\n  const filterEvaluator = options?.filterEvaluator;\r\n\r\n  // Traverse the path, collecting entities at each step\r\n  let currentEntities: HardState[] = [startEntity];\r\n\r\n  for (const step of assertion.path) {\r\n    const nextEntities: HardState[] = [];\r\n\r\n    for (const entity of currentEntities) {\r\n      const related = traverseStep(entity, step, graphView);\r\n      nextEntities.push(...related);\r\n    }\r\n\r\n    let filteredEntities = nextEntities;\r\n    if (step.filters && step.filters.length > 0 && filterEvaluator) {\r\n      filteredEntities = filterEvaluator(nextEntities, step.filters, resolver, options);\r\n    }\r\n\r\n    // Store intermediate results if requested (for constraints like \"not_in\")\r\n    if (step.as) {\r\n      resolver.setPathSet(step.as, new Set(filteredEntities.map(e => e.id)));\r\n    }\r\n    currentEntities = filteredEntities;\r\n  }\r\n\r\n  // Apply constraints to filter final entities\r\n  if (assertion.where) {\r\n    currentEntities = currentEntities.filter(entity =>\r\n      evaluatePathConstraints(entity, startEntity, assertion.where!, resolver)\r\n    );\r\n  }\r\n\r\n  // Evaluate the assertion\r\n  switch (assertion.check) {\r\n    case 'exists':\r\n      return currentEntities.length > 0;\r\n\r\n    case 'not_exists':\r\n      return currentEntities.length === 0;\r\n\r\n    case 'count_min':\r\n      return currentEntities.length >= (assertion.count ?? 1);\r\n\r\n    case 'count_max':\r\n      return currentEntities.length <= (assertion.count ?? 0);\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}", "parameters": [{"name": "startEntity", "type": "HardState", "optional": false}, {"name": "assertion", "type": "GraphPathAssertion", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "options", "type": "GraphPathOptions", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/index.ts::matchesActorConfig", "name": "matchesActorConfig", "kind": "function", "filePath": "apps/lore-weave/lib/rules/index.ts", "sourceCode": "/**\n * Check if an entity matches the actor configuration for an action.\n */\nexport function matchesActorConfig(\n  entity: HardState,\n  actorConfig: ActionActorConfig,\n  graphView: WorldRuntime\n): boolean {\n  const bindings: Record<string, HardState | undefined> = { actor: entity };\n  const ctx = createActionContext(graphView, bindings, entity);\n\n  // Eligibility: actor must appear in selection results (no random picking).\n  const selectionRule = {\n    ...actorConfig.selection,\n    pickStrategy: 'all' as const,\n    maxResults: undefined,\n  };\n\n  const candidates = selectEntities(selectionRule, ctx);\n  if (!candidates.some((candidate) => candidate.id === entity.id)) {\n    return false;\n  }\n\n  // Resolve optional instigator\n  if (actorConfig.instigator) {\n    const instigator = resolveSingleEntity(actorConfig.instigator, ctx);\n    if (!instigator && actorConfig.instigator.required) {\n      return false;\n    }\n    bindings.instigator = instigator;\n  }\n\n  // Evaluate conditions\n  if (actorConfig.conditions && actorConfig.conditions.length > 0) {\n    for (const condition of actorConfig.conditions) {\n      const result = evaluateCondition(condition, ctx, entity);\n      if (!result.passed) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "actorConfig", "type": "ActionActorConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/types.ts::normalizeDirection", "name": "normalizeDirection", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Normalize direction aliases to canonical form.\r\n *\r\n * @param dir - Direction in any supported format\r\n * @returns Canonical direction\r\n */\r\nexport function normalizeDirection(\r\n  dir: 'out' | 'in' | 'any' | 'src' | 'dst' | 'both' | undefined\r\n): Direction {\r\n  switch (dir) {\r\n    case 'out':\r\n      return 'src';\r\n    case 'in':\r\n      return 'dst';\r\n    case 'any':\r\n      return 'both';\r\n    case 'src':\r\n    case 'dst':\r\n    case 'both':\r\n      return dir;\r\n    default:\r\n      return 'both';\r\n  }\r\n}", "parameters": [{"name": "dir", "type": "'out' | 'in' | 'any' | 'src' | 'dst' | 'both' | undefined", "optional": false}], "returnType": "Direction"}, {"id": "apps/lore-weave/lib/rules/types.ts::normalizeOperator", "name": "normalizeOperator", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Normalize comparison operator aliases to canonical form.\r\n *\r\n * @param op - Operator in any supported format\r\n * @returns Canonical operator\r\n */\r\nexport function normalizeOperator(\r\n  op: 'above' | 'below' | '>' | '<' | '>=' | '<=' | '==' | '!=' | undefined\r\n): ComparisonOperator {\r\n  switch (op) {\r\n    case 'above':\r\n      return '>';\r\n    case 'below':\r\n      return '<';\r\n    case '>':\r\n    case '<':\r\n    case '>=':\r\n    case '<=':\r\n    case '==':\r\n    case '!=':\r\n      return op;\r\n    default:\r\n      return '>=';\r\n  }\r\n}", "parameters": [{"name": "op", "type": "'above' | 'below' | '>' | '<' | '>=' | '<=' | '==' | '!=' | undefined", "optional": false}], "returnType": "ComparisonOperator"}, {"id": "apps/lore-weave/lib/rules/types.ts::applyOperator", "name": "applyOperator", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Apply a comparison operator.\r\n *\r\n * @param a - Left operand\r\n * @param op - Comparison operator\r\n * @param b - Right operand\r\n * @returns Result of comparison\r\n */\r\nexport function applyOperator(a: number, op: ComparisonOperator, b: number): boolean {\r\n  switch (op) {\r\n    case '>':\r\n      return a > b;\r\n    case '<':\r\n      return a < b;\r\n    case '>=':\r\n      return a >= b;\r\n    case '<=':\r\n      return a <= b;\r\n    case '==':\r\n      return a === b;\r\n    case '!=':\r\n      return a !== b;\r\n  }\r\n}", "parameters": [{"name": "a", "type": "number", "optional": false}, {"name": "op", "type": "ComparisonOperator", "optional": false}, {"name": "b", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/types.ts::prominenceLabel", "name": "prominenceLabel", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "// recognized\r\n\r\n/**\r\n * Convert numeric prominence value to display label.\r\n *\r\n * Ranges:\r\n * - 0.0-0.99: forgotten\r\n * - 1.0-1.99: marginal\r\n * - 2.0-2.99: recognized\r\n * - 3.0-3.99: renowned\r\n * - 4.0-5.0: mythic\r\n */\r\nexport function prominenceLabel(value: number): ProminenceLabel {\r\n  if (value < 1) return 'forgotten';\r\n  if (value < 2) return 'marginal';\r\n  if (value < 3) return 'recognized';\r\n  if (value < 4) return 'renowned';\r\n  return 'mythic';\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "ProminenceLabel"}, {"id": "apps/lore-weave/lib/rules/types.ts::prominenceThreshold", "name": "prominenceThreshold", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Convert label to numeric threshold (lower bound of range).\r\n */\r\nexport function prominenceThreshold(label: ProminenceLabel): number {\r\n  switch (label) {\r\n    case 'forgotten': return 0;\r\n    case 'marginal': return 1;\r\n    case 'recognized': return 2;\r\n    case 'renowned': return 3;\r\n    case 'mythic': return 4;\r\n  }\r\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/types.ts::prominenceIndex", "name": "prominenceIndex", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Get prominence index (0-4) from numeric value.\r\n */\r\nexport function prominenceIndex(value: number): number {\r\n  return Math.min(4, Math.max(0, Math.floor(value)));\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/types.ts::clampProminence", "name": "clampProminence", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Clamp prominence value to valid range [0, 5].\r\n */\r\nexport function clampProminence(value: number): number {\r\n  return Math.max(PROMINENCE_MIN, Math.min(PROMINENCE_MAX, value));\r\n}", "parameters": [{"name": "value", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/types.ts::compareProminence", "name": "compareProminence", "kind": "function", "filePath": "apps/lore-weave/lib/rules/types.ts", "sourceCode": "/**\r\n * Compare two prominence values.\r\n *\r\n * @returns negative if a < b, 0 if equal, positive if a > b\r\n */\r\nexport function compareProminence(a: number, b: number): number {\r\n  return a - b;\r\n}", "parameters": [{"name": "a", "type": "number", "optional": false}, {"name": "b", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateEntityKindCounts", "name": "calculateEntityKindCounts", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Distribution Calculations Module\n *\n * Pure functions for calculating distribution statistics from graph data.\n * Extracted from StatisticsCollector for reusability and testability.\n *\n * @module distributionCalculations\n */\n\n/**\n * Calculate entity count by kind\n *\n * @param entities - Array of entities to count\n * @returns Record mapping entity kind to count\n *\n * @example\n * const counts = calculateEntityKindCounts([npc1, npc2, faction1]);\n * // { npc: 2, faction: 1 }\n */\nexport function calculateEntityKindCounts(entities: HardState[]): Record<string, number> {\n  const counts: Record<string, number> = {};\n  entities.forEach(e => {\n    counts[e.kind] = (counts[e.kind] || 0) + 1;\n  });\n  return counts;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "Record<string, number>"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateRatios", "name": "calculateRatios", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Calculate ratios from counts\n *\n * @param counts - Record of counts by key\n * @param total - Total count for normalization\n * @returns Record mapping keys to ratios (0-1)\n */\nexport function calculateRatios(\n  counts: Record<string, number>,\n  total: number\n): Record<string, number> {\n  const ratios: Record<string, number> = {};\n  Object.keys(counts).forEach(key => {\n    ratios[key] = total > 0 ? counts[key] / total : 0;\n  });\n  return ratios;\n}", "parameters": [{"name": "counts", "type": "Record<string, number>", "optional": false}, {"name": "total", "type": "number", "optional": false}], "returnType": "Record<string, number>"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateProminenceDistribution", "name": "calculateProminenceDistribution", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Calculate prominence distribution\n */\nexport function calculateProminenceDistribution(entities: HardState[]): {\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n} {\n  const counts: Record<string, number> = {\n    forgotten: 0,\n    marginal: 0,\n    recognized: 0,\n    renowned: 0,\n    mythic: 0\n  };\n\n  entities.forEach(e => {\n    counts[e.prominence]++;\n  });\n\n  const ratios = calculateRatios(counts, entities.length);\n\n  return { counts, ratios };\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "{\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n}"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateRelationshipDistribution", "name": "calculateRelationshipDistribution", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Calculate relationship type distribution\n */\nexport function calculateRelationshipDistribution(graph: Graph): {\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n  diversity: number;\n} {\n  const counts: Record<string, number> = {};\n  graph.getRelationships().forEach(r => {\n    counts[r.kind] = (counts[r.kind] || 0) + 1;\n  });\n\n  const ratios = calculateRatios(counts, graph.getRelationshipCount());\n\n  // Shannon entropy for diversity\n  let diversity = 0;\n  Object.values(ratios).forEach(ratio => {\n    if (ratio > 0) {\n      diversity -= ratio * Math.log2(ratio);\n    }\n  });\n\n  return { counts, ratios, diversity };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "{\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n  diversity: number;\n}"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateConnectivityMetrics", "name": "calculateConnectivityMetrics", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Calculate graph connectivity metrics\n */\nexport function calculateConnectivityMetrics(graph: Graph): {\n  isolatedNodes: number;\n  avgConnections: number;\n  maxConnections: number;\n  minConnections: number;\n} {\n  const connectionCounts = new Map<string, number>();\n\n  graph.getRelationships().forEach(r => {\n    connectionCounts.set(r.src, (connectionCounts.get(r.src) || 0) + 1);\n    connectionCounts.set(r.dst, (connectionCounts.get(r.dst) || 0) + 1);\n  });\n\n  const isolatedNodes = graph.getEntities().filter(entity =>\n    !connectionCounts.has(entity.id)\n  ).length;\n\n  const connectionValues = Array.from(connectionCounts.values());\n  const avgConnections = connectionValues.length > 0\n    ? connectionValues.reduce((sum, c) => sum + c, 0) / connectionValues.length\n    : 0;\n\n  const maxConnections = connectionValues.length > 0\n    ? Math.max(...connectionValues)\n    : 0;\n\n  const minConnections = connectionValues.length > 0\n    ? Math.min(...connectionValues)\n    : 0;\n\n  return {\n    isolatedNodes,\n    avgConnections,\n    maxConnections,\n    minConnections\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "{\n  isolatedNodes: number;\n  avgConnections: number;\n  maxConnections: number;\n  minConnections: number;\n}"}, {"id": "apps/lore-weave/lib/statistics/distributionCalculations.ts::calculateSubtypeDistribution", "name": "calculateSubtypeDistribution", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/distributionCalculations.ts", "sourceCode": "/**\n * Calculate subtype distribution\n */\nexport function calculateSubtypeDistribution(entities: HardState[]): {\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n} {\n  const counts: Record<string, number> = {};\n\n  entities.forEach(e => {\n    const subtypeKey = `${e.kind}:${e.subtype}`;\n    counts[subtypeKey] = (counts[subtypeKey] || 0) + 1;\n  });\n\n  const ratios = calculateRatios(counts, entities.length);\n\n  return { counts, ratios };\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "{\n  counts: Record<string, number>;\n  ratios: Record<string, number>;\n}"}, {"id": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts::getTagMetadata", "name": "getTagMetadata", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts", "sourceCode": "/**\n * Get tag metadata by tag name\n */\nexport function getTagMetadata(registry: TagMetadata[], tag: string): TagMetadata | undefined {\n  return registry.find(t => t.tag === tag);\n}", "parameters": [{"name": "registry", "type": "TagMetadata[]", "optional": false}, {"name": "tag", "type": "string", "optional": false}], "returnType": "TagMetadata | undefined"}, {"id": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts::getTagsByCategory", "name": "getTagsByCategory", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts", "sourceCode": "/**\n * Get all tags in a category\n */\nexport function getTagsByCategory(registry: TagMetadata[], category: TagMetadata['category']): TagMetadata[] {\n  return registry.filter(t => t.category === category);\n}", "parameters": [{"name": "registry", "type": "TagMetadata[]", "optional": false}, {"name": "category", "type": "TagMetadata['category']", "optional": false}], "returnType": "TagMetadata[]"}, {"id": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts::getConsolidationSuggestions", "name": "getConsolidationSuggestions", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts", "sourceCode": "/**\n * Get consolidation suggestions (tags that should be merged)\n */\nexport function getConsolidationSuggestions(registry: TagMetadata[]): Array<{ from: string; to: string }> {\n  return registry\n    .filter(t => t.consolidateInto)\n    .map(t => ({ from: t.tag, to: t.consolidateInto! }));\n}", "parameters": [{"name": "registry", "type": "TagMetadata[]", "optional": false}], "returnType": "Array<{ from: string; to: string }>"}, {"id": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts::tagsConflict", "name": "tagsConflict", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts", "sourceCode": "/**\n * Check if two tags conflict\n */\nexport function tagsConflict(registry: TagMetadata[], tag1: string, tag2: string): boolean {\n  const metadata1 = getTagMetadata(registry, tag1);\n  const metadata2 = getTagMetadata(registry, tag2);\n\n  if (!metadata1 || !metadata2) return false;\n\n  return (metadata1.conflictingTags?.includes(tag2) ||\n          metadata2.conflictingTags?.includes(tag1)) ?? false;\n}", "parameters": [{"name": "registry", "type": "TagMetadata[]", "optional": false}, {"name": "tag1", "type": "string", "optional": false}, {"name": "tag2", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts::validateEntityTags", "name": "validateEntityTags", "kind": "function", "filePath": "apps/lore-weave/lib/statistics/tagRegistryHelpers.ts", "sourceCode": "/**\n * Validate that an entity's tags don't have conflicts.\n * Accepts EntityTags (KVP format) and checks tag keys for conflicts.\n */\nexport function validateEntityTags(\n  registry: TagMetadata[],\n  tags: EntityTags | undefined\n): { valid: boolean; conflicts: string[] } {\n  const conflicts: string[] = [];\n\n  if (!tags) {\n    return { valid: true, conflicts: [] };\n  }\n\n  const tagKeys = Object.keys(tags);\n\n  for (let i = 0; i < tagKeys.length; i++) {\n    for (let j = i + 1; j < tagKeys.length; j++) {\n      if (tagsConflict(registry, tagKeys[i], tagKeys[j])) {\n        conflicts.push(`${tagKeys[i]} conflicts with ${tagKeys[j]}`);\n      }\n    }\n  }\n\n  return {\n    valid: conflicts.length === 0,\n    conflicts\n  };\n}", "parameters": [{"name": "registry", "type": "TagMetadata[]", "optional": false}, {"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "{ valid: boolean; conflicts: string[] }"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::getAgentsByCategory", "name": "getAgentsByCategory", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Get all entities that can act (have catalyst.canAct = true)\n * @param graph - The world graph\n * @param category - Filter by agent category\n * @returns Array of agent entities\n */\nexport function getAgentsByCategory(\n  graph: Graph,\n  category: 'first-order' | 'second-order' | 'all' = 'all'\n): HardState[] {\n  const agents = graph.getEntities()\n    .filter(e => e.catalyst?.canAct === true);\n\n  if (category === 'all') {\n    return agents;\n  }\n\n  // First-order agents: npc, faction, ability, location (rare)\n  // Second-order agents: occurrence\n  if (category === 'first-order') {\n    return agents.filter(e => e.kind !== FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  } else {\n    return agents.filter(e => e.kind === FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "category", "type": "'first-order' | 'second-order' | 'all'", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::canPerformAction", "name": "canPerformAction", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Check if an entity can perform actions\n * @param entity - The entity to check\n * @returns True if entity can act\n */\nexport function canPerformAction(entity: HardState): boolean {\n  return entity.catalyst?.canAct === true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::recordCatalyst", "name": "recordCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Record catalyst attribution on a relationship\n * @param relationship - The relationship to attribute\n * @param catalystId - ID of the agent that caused this\n * @returns The relationship with attribution added\n */\nexport function recordCatalyst(\n  relationship: Relationship,\n  catalystId: string\n): Relationship {\n  return {\n    ...relationship,\n    catalyzedBy: catalystId\n  };\n}", "parameters": [{"name": "relationship", "type": "Relationship", "optional": false}, {"name": "catalystId", "type": "string", "optional": false}], "returnType": "Relationship"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::getCatalyzedEvents", "name": "getCatalyzedEvents", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Get all events (relationships/entities) catalyzed by an entity\n * @param graph - The world graph\n * @param entityId - ID of the catalyst entity\n * @returns Array of relationships and entities caused by this catalyst\n */\nexport function getCatalyzedEvents(\n  graph: Graph,\n  entityId: string\n): (Relationship | HardState)[] {\n  const results: (Relationship | HardState)[] = [];\n\n  // Find relationships catalyzed by this entity\n  graph.getRelationships().forEach(rel => {\n    if (rel.catalyzedBy === entityId) {\n      results.push(rel);\n    }\n  });\n\n  // Find entities catalyzed by this entity (e.g., occurrences triggered by NPCs)\n  graph.forEachEntity(entity => {\n    const triggeredByRel = graph.getEntityRelationships(entity.id, 'src')\n      .find(rel => rel.kind === 'triggered_by' && rel.dst === entityId);\n    if (triggeredByRel) {\n      results.push(entity);\n    }\n  });\n\n  return results;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "(Relationship | HardState)[]"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Check if entity has a specific relationship\n * @param entity - The entity to check\n * @param relationshipKind - The relationship kind to look for\n * @param direction - Check as 'src' or 'dst' or 'both'\n * @returns True if relationship exists\n */\nexport function hasRelationship(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction: 'src' | 'dst' | 'both' = 'both'\n): boolean {\n  return graph.getEntityRelationships(entityId, direction).some(link => link.kind === relationshipKind);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::calculateAttemptChance", "name": "calculateAttemptChance", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Calculate action attempt chance based on entity prominence\n * @param entity - The entity attempting action\n * @param baseRate - Base action attempt rate (from system parameters)\n * @returns Probability of action attempt this tick\n */\nexport function calculateAttemptChance(\n  entity: HardState,\n  baseRate: number\n): number {\n  if (!entity.catalyst?.canAct) {\n    return 0;\n  }\n\n  const multiplier = getProminenceMultiplierValue(entity.prominence, 'action_rate');\n  const chance = baseRate * multiplier;\n\n  // Clamp to [0, 1]\n  return Math.max(0, Math.min(1, chance));\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "baseRate", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::initializeCatalyst", "name": "initializeCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Initialize or update catalyst properties for an entity\n * This is a helper for domain code to set up catalyst properties\n * @param entity - The entity to initialize\n * @param canAct - Can this entity perform actions?\n */\nexport function initializeCatalyst(\n  entity: HardState,\n  canAct: boolean\n): void {\n  entity.catalyst = {\n    canAct\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "canAct", "type": "boolean", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/systems/catalystHelpers.ts::initializeCatalystSmart", "name": "initializeCatalystSmart", "kind": "function", "filePath": "apps/lore-weave/lib/systems/catalystHelpers.ts", "sourceCode": "/**\n * Initialize catalyst properties for entities of actor kinds.\n * All entities of eligible kinds can act - prominence affects action\n * success chance and attempt rate, not eligibility.\n *\n * @param entity - The entity to initialize\n */\nexport function initializeCatalystSmart(entity: HardState): void {\n  // Entity kinds that can act\n  const actorKinds = ['npc', 'faction', 'ability', 'occurrence', 'location', 'artifact', 'rule'];\n  if (!actorKinds.includes(entity.kind)) {\n    return;\n  }\n\n  entity.catalyst = {\n    canAct: true\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/systems/clusterFormation.ts::createClusterFormationSystem", "name": "createClusterFormationSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/clusterFormation.ts", "sourceCode": "// =============================================================================\n// SYSTEM FACTORY\n// =============================================================================\n\n/**\n * Create a SimulationSystem from a ClusterFormationConfig\n */\nexport function createClusterFormationSystem(\n  config: ClusterFormationConfig\n): SimulationSystem {\n  // Convert declarative criteria to runtime criteria\n  const clusterConfig: ClusterConfig = {\n    minSize: config.clustering.minSize,\n    maxSize: config.clustering.maxSize,\n    criteria: toClusterCriteria(config.clustering.criteria),\n    minimumScore: config.clustering.minimumScore\n  };\n\n  return {\n    id: config.id,\n    name: config.name,\n\n    apply: async (graphView: WorldRuntime, _modifier: number = 1.0): Promise<SystemResult> => {\n      // Check epoch end if required\n      if (config.runAtEpochEnd) {\n        const ticksPerEpoch = graphView.config.ticksPerEpoch || 15;\n        if (graphView.tick % ticksPerEpoch !== 0) {\n          return {\n            relationshipsAdded: [],\n            entitiesModified: [],\n            pressureChanges: {},\n            description: `${config.name}: not epoch end, skipping`\n          };\n        }\n      }\n\n      // Find entities eligible for clustering\n      const selectionCtx = createSystemContext(graphView);\n      let entities = selectEntities(config.selection, selectionCtx);\n\n      // Filter out historical and meta-entities\n      entities = filterClusterableEntities(entities);\n\n      if (entities.length < clusterConfig.minSize) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${config.name}: not enough entities (${entities.length})`\n        };\n      }\n\n      // Detect clusters\n      const clusters = detectClusters(entities, clusterConfig, graphView);\n\n      const relationshipsAdded: Array<Relationship & { narrativeGroupId?: string }> = [];\n      const entitiesModified: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\n      const metaEntitiesCreated: string[] = [];\n      const factionsCreated: string[] = [];\n      const narrationsByGroup: Record<string, string> = {};\n\n      // Form meta-entities from valid clusters\n      for (const cluster of clusters) {\n        if (cluster.score < clusterConfig.minimumScore) continue;\n\n        // Create the meta-entity partial\n        const metaEntityPartial = await createMetaEntity(cluster.entities, config.metaEntity, graphView);\n\n        // Enter narration context BEFORE creating the entity (narration added after we have the name)\n        const tracker = graphView.mutationTracker;\n        const contextId = `${config.id}:${metaEntitiesCreated.length}`;\n        if (config.narrationTemplate && tracker) {\n          tracker.enterContext('system', contextId);\n        }\n\n        // Now create the entity (will be recorded under the narration context)\n        const metaEntityId = await graphView.addEntity(metaEntityPartial);\n        const metaEntity = graphView.getEntity(metaEntityId)!;\n        metaEntitiesCreated.push(metaEntityId);\n\n        // Generate narration now that we have the full entity with name\n        // and SET IT ON THE CURRENT CONTEXT so the event builder finds it\n        let generatedNarration: string | undefined;\n        if (config.narrationTemplate && tracker) {\n          const entityNames = cluster.entities.map(e => e.name).join(', ');\n          const templateWithReplacements = config.narrationTemplate\n            .replace('{count}', String(cluster.entities.length))\n            .replace('{names}', entityNames);\n          const narrationCtx = createSystemRuleContext({ self: metaEntity });\n          const narrationResult = interpolate(templateWithReplacements, narrationCtx);\n          if (narrationResult.complete) {\n            generatedNarration = narrationResult.text;\n            narrationsByGroup[metaEntityId] = generatedNarration;\n            // Update the context's narration directly\n            const currentContext = tracker.getCurrentContext();\n            if (currentContext) {\n              currentContext.narration = generatedNarration;\n            }\n          }\n        }\n\n        // Get cluster entity IDs\n        const clusterIds = cluster.entities.map(e => e.id);\n\n        // Handle practitioner relationships based on masterSelection config\n        if (config.masterSelection) {\n          // Collect all practitioners of cluster members\n          const allPractitioners: HardState[] = [];\n          const seenIds = new Set<string>();\n          for (const memberId of clusterIds) {\n            const practitioners = graphView.getConnectedEntities(memberId, 'practitioner_of', 'dst');\n            for (const p of practitioners) {\n              if (!seenIds.has(p.id)) {\n                seenIds.add(p.id);\n                allPractitioners.push(p);\n              }\n            }\n          }\n\n          // Select masters using the simplified selection logic\n          const masters = selectMasters(allPractitioners, metaEntity, config.masterSelection);\n\n          // Create practitioner_of relationships only for masters\n          for (const master of masters) {\n            graphView.createRelationship('practitioner_of', master.id, metaEntityId);\n            relationshipsAdded.push({\n              kind: 'practitioner_of',\n              src: master.id,\n              dst: metaEntityId,\n              strength: 1.0,\n              narrativeGroupId: metaEntityId\n            });\n            // Archive the old practitioner_of relationships for this master\n            for (const memberId of clusterIds) {\n              graphView.archiveRelationship(master.id, memberId, 'practitioner_of');\n            }\n          }\n\n          // Find origin location from absorbed abilities' manifests_at relationships\n          const locationCounts = new Map<string, number>();\n          for (const memberId of clusterIds) {\n            const locations = graphView.getConnectedEntities(memberId, 'manifests_at', 'src');\n            for (const loc of locations) {\n              locationCounts.set(loc.id, (locationCounts.get(loc.id) || 0) + 1);\n            }\n          }\n\n          // Create originated_in link to most common location\n          if (locationCounts.size > 0) {\n            const originLocationId = getMajority(locationCounts, '');\n            if (originLocationId) {\n              graphView.createRelationship('originated_in', metaEntityId, originLocationId);\n              relationshipsAdded.push({\n                kind: 'originated_in',\n                src: metaEntityId,\n                dst: originLocationId,\n                strength: 1.0,\n                narrativeGroupId: metaEntityId\n              });\n            }\n          }\n\n          graphView.log('info', `${config.name}: selected ${masters.length} masters from ${allPractitioners.length} practitioners`);\n        } else {\n          // Original behavior: transfer all relationships\n          graphView.transferRelationships(\n            clusterIds,\n            metaEntityId,\n            {\n              excludeKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n              archiveOriginals: true\n            }\n          );\n        }\n\n        // Create subsumes relationships (meta-entity subsumes member)\n        // This makes it explicit that the meta-entity absorbs the cluster members\n        clusterIds.forEach((id, index) => {\n          graphView.createRelationship('subsumes', metaEntityId, id);\n          relationshipsAdded.push({\n            kind: 'subsumes',\n            src: metaEntityId,\n            dst: id,\n            strength: 1.0,\n            // Link first relationship to narration for this cluster\n            narrativeGroupId: index === 0 ? metaEntityId : undefined\n          });\n        });\n\n        // Post-process: create emergent region if configured\n        if (config.postProcess?.createEmergentRegion && metaEntityPartial.coordinates) {\n          const regionLabel = (config.postProcess.emergentRegionLabel || '{name} Region')\n            .replace('{name}', metaEntity.name);\n          const regionDescription = (config.postProcess.emergentRegionDescription || 'A semantic cluster formed around {name}')\n            .replace('{name}', metaEntity.name);\n\n          const regionResult = graphView.createEmergentRegion(\n            config.metaEntity.kind,\n            metaEntityPartial.coordinates,\n            regionLabel,\n            regionDescription,\n            metaEntity.culture,\n            metaEntityId\n          );\n\n          if (regionResult.success && regionResult.region) {\n            graphView.log('info', `Created emergent region \"${regionResult.region.label}\" for meta-entity \"${metaEntity.name}\"`);\n          }\n        }\n\n        // Post-process: create governance faction if configured\n        if (config.postProcess?.createGovernanceFaction) {\n          const { factionId, relationships } = await createGovernanceFaction(\n            graphView,\n            metaEntityId,\n            metaEntity,\n            config.postProcess\n          );\n\n          relationshipsAdded.push(...relationships);\n          if (factionId) {\n            factionsCreated.push(factionId);\n          }\n        }\n\n        // Apply member updates or fall back to archiving\n        if (config.memberUpdates && config.memberUpdates.length > 0) {\n          // Find the status mutation if present\n          const statusMutation = config.memberUpdates.find(\n            m => m.type === 'change_status'\n          ) as { type: 'change_status'; newStatus: string } | undefined;\n\n          const newStatus = statusMutation?.newStatus ?? FRAMEWORK_STATUS.SUBSUMED;\n\n          // Apply status change to each cluster member\n          for (const memberId of clusterIds) {\n            graphView.updateEntityStatus(memberId, newStatus);\n\n            entitiesModified.push({\n              id: memberId,\n              changes: { status: newStatus }\n            });\n          }\n        } else {\n          // Original behavior: archive as historical\n          graphView.archiveEntities(\n            clusterIds,\n            {\n              archiveRelationships: false,\n              excludeRelationshipKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF]\n            }\n          );\n\n          // Track modifications\n          clusterIds.forEach(id => {\n            entitiesModified.push({\n              id,\n              changes: { status: 'historical' }\n            });\n          });\n        }\n\n        // Exit narration context if we entered one\n        if (config.narrationTemplate && tracker) {\n          tracker.exitContext();\n        }\n      }\n\n      // Pressure changes\n      const pressureChanges = metaEntitiesCreated.length > 0\n        ? (config.postProcess?.pressureChanges ?? { stability: 2 })\n        : {};\n\n      return {\n        relationshipsAdded,\n        entitiesModified,\n        pressureChanges,\n        description: `${config.name}: ${metaEntitiesCreated.length} meta-entities formed` +\n          (factionsCreated.length > 0 ? `, ${factionsCreated.length} factions` : ''),\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "ClusterFormationConfig", "optional": false}], "returnType": "SimulationSystem"}]