[{"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkProgressBar", "name": "BulkProgressBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared progress bar component for bulk operations\n */\nexport function BulkProgressBar({\n  processed,\n  total,\n  status\n}) {\n  const pct = total > 0 ? Math.round(processed / total * 100) : 0;\n  let fillClass = \"bulk-progress-fill-ok\";\n  if (status === \"failed\") fillClass = \"bulk-progress-fill-failed\";else if (status === \"cancelled\") fillClass = \"bulk-progress-fill-cancelled\";\n  return <div className=\"bulk-progress-section\">\n      <div className=\"bulk-progress-header\">\n        <span className=\"bulk-progress-label\">\n          {Math.min(processed + 1, total)} / {total}\n        </span>\n        <span className=\"bulk-progress-pct\">{pct}%</span>\n      </div>\n      <div className=\"bulk-progress-track\">\n        <div className={`bulk-progress-fill ${fillClass}`} style={{\n        \"--bulk-progress-width\": `${pct}%`\n      }} />\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  processed,\n  total,\n  status\n}", "type": "{ processed: any; total: any; status: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useFloatingPillStore", "useFloatingPillStore.getState"]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkTerminalMessage", "name": "BulkTerminalMessage", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared terminal message component for bulk operations\n */\nexport function BulkTerminalMessage({\n  status,\n  children\n}) {\n  return <div className={`bulk-terminal-msg bulk-terminal-msg-${status}`}>\n      {children}\n    </div>;\n}", "parameters": [{"name": "{\n  status,\n  children\n}", "type": "{ status: any; children: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useFloatingPillStore", "useFloatingPillStore.getState"]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkFailedList", "name": "BulkFailedList", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared failed items list component for bulk operations\n */\nexport function BulkFailedList({\n  items,\n  labelKey = \"title\",\n  errorKey = \"error\"\n}) {\n  if (!items || items.length === 0) return null;\n  return <div className=\"bulk-failed-section\">\n      <div className=\"bulk-failed-label\">Failed ({items.length})</div>\n      <div className=\"bulk-failed-list\">\n        {items.map((item, i) => <div key={item.id || item.chronicleId || item.entityId || i} className=\"bulk-failed-item\">\n            <span className=\"bulk-failed-item-title\">{item[labelKey]}</span>\n            <span className=\"bulk-failed-item-error\">{item[errorKey]}</span>\n          </div>)}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  items,\n  labelKey = \"title\",\n  errorKey = \"error\"\n}", "type": "{ items: any; labelKey?: string; errorKey?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useFloatingPillStore", "useFloatingPillStore.getState"]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkCost", "name": "BulkCost", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared cost display for bulk operations\n */\nexport function BulkCost({\n  cost\n}) {\n  if (!cost || cost <= 0) return null;\n  return <div className=\"bulk-cost\">Cost: ${cost.toFixed(4)}</div>;\n}", "parameters": [{"name": "{\n  cost\n}", "type": "{ cost: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useFloatingPillStore", "useFloatingPillStore.getState"]}, {"id": "apps/illuminator/webui/src/components/CoverImageControls.jsx::CoverImagePreview", "name": "CoverImagePreview", "kind": "component", "filePath": "apps/illuminator/webui/src/components/CoverImageControls.jsx", "sourceCode": "export function CoverImagePreview({\n  imageId,\n  onImageClick\n}) {\n  const {\n    url,\n    loading,\n    error\n  } = useImageUrl(imageId);\n  if (!imageId) return null;\n  if (loading) {\n    return <div className=\"cic-loading\">Loading image...</div>;\n  }\n  if (error || !url) {\n    return <div className=\"cic-error\">Failed to load image{error ? `: ${error}` : \"\"}</div>;\n  }\n  return <div className=\"cic-preview-wrapper\">\n      <img src={url} alt=\"Cover\" onClick={onImageClick ? () => onImageClick(imageId, \"Cover Image\") : undefined} className={`cic-preview-img${onImageClick ? \" cic-preview-img-clickable\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }} />\n    </div>;\n}", "parameters": [{"name": "{\n  imageId,\n  onImageClick\n}", "type": "{ imageId: any; onImageClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useImageUrl", "count": 1}], "imports": [{"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CoverImageControls.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/CoverImageControls.jsx::CoverImageControls", "name": "CoverImageControls", "kind": "component", "filePath": "apps/illuminator/webui/src/components/CoverImageControls.jsx", "sourceCode": "export function CoverImageControls({\n  item,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  isGenerating,\n  labelWeight = 500\n}) {\n  return <div className=\"cic-layout\">\n      <div className=\"cic-info\">\n        <div className=\"cic-label\" style={{\n        \"--cic-label-weight\": labelWeight\n      }}>\n          Cover Image\n        </div>\n        <div className=\"cic-description\">\n          Generate a montage-style cover image for this chronicle.\n        </div>\n        {!item.coverImage && <div className=\"cic-status cic-status-empty\">Not run yet</div>}\n        {item.coverImage && item.coverImage.status === \"pending\" && <div className=\"cic-status cic-status-pending\">\n            Scene ready - click Generate Image to create\n          </div>}\n        {item.coverImage && item.coverImage.status === \"generating\" && <div className=\"cic-status cic-status-generating\">Generating image...</div>}\n        {item.coverImage && item.coverImage.status === \"complete\" && <div className=\"cic-status cic-status-complete\">Complete</div>}\n        {item.coverImage && item.coverImage.status === \"failed\" && <div className=\"cic-status cic-status-failed\">\n            Failed{item.coverImage.error ? `: ${item.coverImage.error}` : \"\"}\n          </div>}\n        {item.coverImage?.sceneDescription && <div className=\"cic-scene-description\">{item.coverImage.sceneDescription}</div>}\n        <CoverImagePreview imageId={item.coverImage?.generatedImageId} onImageClick={onImageClick} />\n      </div>\n      <div className=\"cic-actions\">\n        <div className=\"cic-button-row\">\n          {onGenerateCoverImageScene && <button onClick={onGenerateCoverImageScene} disabled={isGenerating} className=\"cic-action-btn\">\n              {item.coverImage ? \"Regen Scene\" : \"Gen Scene\"}\n            </button>}\n          {onGenerateCoverImage && item.coverImage && (item.coverImage.status === \"pending\" || item.coverImage.status === \"complete\" || item.coverImage.status === \"failed\") && <button onClick={onGenerateCoverImage} disabled={isGenerating} className=\"cic-action-btn\">\n                {item.coverImage.status === \"complete\" ? \"Regen Image\" : \"Gen Image\"}\n              </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  isGenerating,\n  labelWeight = 500\n}", "type": "{ item: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; isGenerating: any; labelWeight?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "CoverImagePreview", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CoverImageControls.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/FloatingPills.tsx::FloatingPills", "name": "FloatingPills", "kind": "component", "filePath": "apps/illuminator/webui/src/components/FloatingPills.tsx", "sourceCode": "export function FloatingPills({ onNavigate }: Readonly<{ onNavigate?: (tabId: string) => void }>) {\n  const pills = useFloatingPillStore((s) => s.pills);\n\n  if (pills.size === 0) return null;\n\n  return (\n    <div className=\"fp-container\">\n      {Array.from(pills.values()).map((pill) => (\n        <Pill key={pill.id} pill={pill} onNavigate={onNavigate} />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ onNavigate }", "type": "Readonly<{ onNavigate?: (tabId: string) => void }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "Pill", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useFloatingPillStore", "count": 1}], "imports": [{"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore", "FloatingPill"], "category": "internal"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./FloatingPills.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useFloatingPillStore", "useThinkingStore", "useThinkingStore.getState"]}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::ImageSettingsSummary", "name": "ImageSettingsSummary", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Summary line component (used by EntityBrowser / ChronicleImagePanel) \u2500\n\nexport function ImageSettingsSummary({\n  settings,\n  styleLibrary,\n  onOpenSettings\n}: Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onOpenSettings: () => void;\n}>) {\n  const resolve = (id: string, list: Array<{\n    id: string;\n    name: string;\n  }> | undefined) => {\n    if (id === RANDOM_ID) return \"Random\";\n    if (id === NONE_ID) return \"None\";\n    return list?.find(s => s.id === id)?.name || id;\n  };\n  const artistic = resolve(settings.artisticStyleId, styleLibrary?.artisticStyles);\n  const composition = resolve(settings.compositionStyleId, styleLibrary?.compositionStyles);\n  const palette = resolve(settings.colorPaletteId, styleLibrary?.colorPalettes);\n\n  // Find swatch colors for current palette\n  const currentPalette = styleLibrary?.colorPalettes.find(p => p.id === settings.colorPaletteId);\n  const swatchColors = currentPalette?.swatchColors;\n  return <div className=\"isd-summary\">\n      <span className=\"isd-summary-label\">Image:</span>\n      <span className=\"isd-summary-value\">\n        {artistic} &middot; {composition} &middot; {palette}\n      </span>\n      {swatchColors && swatchColors.length > 0 && <SwatchStrip colors={swatchColors} />}\n      <button onClick={onOpenSettings} className=\"isd-summary-settings-btn\">\n        Settings\n      </button>\n    </div>;\n}", "parameters": [{"name": "{\n  settings,\n  styleLibrary,\n  onOpenSettings\n}", "type": "Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onOpenSettings: () => void;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "SwatchStrip", "children": [], "isMap": false, "isConditional": true}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/imageSettings", "specifiers": ["getSizeOptions", "getQualityOptions"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS", "filterStylesForComposition", "filterCompositionsForStyle"], "category": "external"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./ImageSettingsDrawer.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::ImageSettingsTrigger", "name": "ImageSettingsTrigger", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Sidebar trigger button \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport function ImageSettingsTrigger({\n  settings,\n  styleLibrary,\n  onClick\n}: Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onClick: () => void;\n}>) {\n  const resolve = (id: string, list: Array<{\n    id: string;\n    name: string;\n  }> | undefined) => {\n    if (id === RANDOM_ID) return \"Random\";\n    if (id === NONE_ID) return \"\\u2014\";\n    return list?.find(s => s.id === id)?.name || id;\n  };\n  const artistic = resolve(settings.artisticStyleId, styleLibrary?.artisticStyles);\n  const palette = resolve(settings.colorPaletteId, styleLibrary?.colorPalettes);\n  const currentPalette = styleLibrary?.colorPalettes.find(p => p.id === settings.colorPaletteId);\n  const swatchColors = currentPalette?.swatchColors;\n  return <button onClick={onClick} className=\"isd-trigger\" title=\"Open image generation settings\">\n      <div className=\"isd-trigger-header\">\n        <span className=\"isd-trigger-title\">Image Settings</span>\n      </div>\n      <div className=\"isd-trigger-detail\">\n        {swatchColors && settings.colorPaletteId !== RANDOM_ID && settings.colorPaletteId !== NONE_ID ? <SwatchStrip colors={swatchColors.slice(0, 3)} /> : null}\n        <span className=\"isd-trigger-text\">\n          {artistic} &middot; {palette}\n        </span>\n      </div>\n    </button>;\n}", "parameters": [{"name": "{\n  settings,\n  styleLibrary,\n  onClick\n}", "type": "Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onClick: () => void;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "button", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "SwatchStrip", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/imageSettings", "specifiers": ["getSizeOptions", "getQualityOptions"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS", "filterStylesForComposition", "filterCompositionsForStyle"], "category": "external"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./ImageSettingsDrawer.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ThinkingViewer.tsx::ThinkingViewer", "name": "ThinkingViewer", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ThinkingViewer.tsx", "sourceCode": "export function ThinkingViewer() {\n  const viewingTaskId = useThinkingStore((s) => s.viewingTaskId);\n  const entry = useThinkingStore((s) => (viewingTaskId ? s.entries.get(viewingTaskId) : undefined));\n  const closeViewer = useThinkingStore((s) => s.closeViewer);\n  const [activeTab, setActiveTab] = useState<ViewerTab>(\"thinking\");\n  const preRef = useRef<HTMLPreElement>(null);\n  const mouseDownOnOverlay = useRef(false);\n\n  const content = activeTab === \"thinking\" ? entry?.thinking : entry?.text;\n\n  // Auto-scroll to bottom when new content arrives\n  useEffect(() => {\n    if (preRef.current && entry?.isActive) {\n      preRef.current.scrollTop = preRef.current.scrollHeight;\n    }\n  }, [content, entry?.isActive]);\n\n  // Auto-switch to response tab when thinking finishes but text is still streaming\n  useEffect(() => {\n    if (entry && !entry.thinking && entry.text && activeTab === \"thinking\") {\n      setActiveTab(\"response\");\n    }\n  }, [entry?.thinking, entry?.text, activeTab]);\n\n  const handleCopy = useCallback(() => {\n    if (content) {\n      void navigator.clipboard.writeText(content);\n    }\n  }, [content]);\n\n  const handleOverlayMouseDown = useCallback((e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n        closeViewer();\n      }\n    },\n    [closeViewer]\n  );\n\n  if (!viewingTaskId || !entry) return null;\n\n  const thinkingLen = entry.thinking.length;\n  const textLen = entry.text.length;\n\n  return (\n    <div\n      className=\"tv-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div\n        className=\"tv-dialog\"\n      >\n        {/* Header */}\n        <div\n          className=\"tv-header\"\n        >\n          <div className=\"tv-header-left\">\n            <h3 className=\"tv-header-title\">LLM Stream</h3>\n            {entry.isActive && (\n              <span\n                className=\"tv-streaming-label\"\n              >\n                streaming...\n              </span>\n            )}\n          </div>\n          <div className=\"tv-header-actions\">\n            <button\n              onClick={handleCopy}\n              className=\"illuminator-button tv-copy-button\"\n              disabled={!content}\n            >\n              Copy\n            </button>\n            <button\n              onClick={closeViewer}\n              className=\"illuminator-button tv-close-button\"\n            >\n              &times;\n            </button>\n          </div>\n        </div>\n\n        {/* Subtitle + tabs */}\n        <div\n          className=\"tv-subtitle-bar\"\n        >\n          <span className=\"tv-subtitle-label\">\n            {entry.entityName} &middot; {entry.taskType}\n          </span>\n          <div className=\"tv-tab-group\">\n            <button\n              onClick={() => setActiveTab(\"thinking\")}\n              className={`tv-tab-button ${activeTab === \"thinking\" ? \"tv-tab-button-active\" : \"tv-tab-button-inactive\"}`}\n            >\n              Thinking{\" \"}\n              {thinkingLen > 0 && <span className=\"tv-size-label\">({formatSize(thinkingLen)})</span>}\n            </button>\n            <button\n              onClick={() => setActiveTab(\"response\")}\n              className={`tv-tab-button ${activeTab === \"response\" ? \"tv-tab-button-active\" : \"tv-tab-button-inactive\"}`}\n            >\n              Response{\" \"}\n              {textLen > 0 && <span className=\"tv-size-label\">({formatSize(textLen)})</span>}\n            </button>\n          </div>\n        </div>\n\n        {/* Body */}\n        <pre\n          ref={preRef}\n          className=\"tv-body\"\n        >\n          {content || (() => {\n            if (entry.isActive) {\n              return activeTab === \"thinking\"\n                ? \"Waiting for thinking content...\"\n                : \"Waiting for response text...\";\n            }\n            return activeTab === \"thinking\"\n              ? \"No thinking content (thinking may be disabled for this call type).\"\n              : \"No response text received.\";\n          })()}\n        </pre>\n      </div>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "pre", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useThinkingStore", "count": 3}, {"name": "useState", "count": 1}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 3}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useCallback", "useEffect"], "category": "framework"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "./ThinkingViewer.css", "specifiers": [], "category": "internal"}], "storeAccess": ["useThinkingStore"]}, {"id": "apps/illuminator/webui/src/hooks/useBackportFlow.js::useBackportFlow", "name": "useBackportFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBackportFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useBackportFlow({\n  projectId,\n  simulationRunId,\n  getEntityContextsForRevision,\n  reloadEntities,\n  setChronicleRefreshTrigger,\n}) {\n  const {\n    run: backportRun,\n    isActive: isBackportActive,\n    chronicleId: backportChronicleId,\n    startBackport,\n    togglePatchDecision: toggleBackportPatchDecision,\n    updateAnchorPhrase: updateBackportAnchorPhrase,\n    applyAccepted: applyAcceptedBackportPatches,\n    cancelBackport,\n  } = useChronicleLoreBackport(getEntityContextsForRevision);\n\n  const assembleContextForChronicle = useCallback(\n    (chronicleId) =>\n      assembleChronicleContext(\n        projectId,\n        simulationRunId,\n        chronicleId,\n        getEntityContextsForRevision\n      ),\n    [projectId, simulationRunId, getEntityContextsForRevision]\n  );\n\n  const [backportConfig, setBackportConfig] = useState(null);\n  const backportSentEntityIdsRef = useRef(null);\n\n  const handleBackportLore = useCallback(\n    async (chronicleId) => {\n      const context = await assembleContextForChronicle(chronicleId);\n      if (!context) {\n        console.warn(\"[Backport] Could not assemble context for chronicle:\", chronicleId);\n        return;\n      }\n      setBackportConfig(context);\n    },\n    [assembleContextForChronicle]\n  );\n\n  const handleBackportConfigStart = useCallback(\n    (selectedEntityIds, customInstructions) => {\n      runBackportConfigStart(\n        backportConfig,\n        projectId,\n        simulationRunId,\n        selectedEntityIds,\n        customInstructions,\n        backportSentEntityIdsRef,\n        startBackport,\n        setBackportConfig\n      );\n    },\n    [backportConfig, projectId, simulationRunId, startBackport]\n  );\n\n  const handleAcceptBackport = useCallback(async () => {\n    await runAcceptBackport(\n      backportChronicleId,\n      applyAcceptedBackportPatches,\n      reloadEntities,\n      backportSentEntityIdsRef,\n      setChronicleRefreshTrigger\n    );\n  }, [\n    applyAcceptedBackportPatches,\n    backportChronicleId,\n    reloadEntities,\n    setChronicleRefreshTrigger,\n  ]);\n\n  const handleMarkEntityNotNeeded = useCallback(\n    async (entityIds) => {\n      await runMarkEntityNotNeeded(\n        backportConfig,\n        entityIds,\n        setBackportConfig,\n        setChronicleRefreshTrigger\n      );\n    },\n    [backportConfig, setChronicleRefreshTrigger]\n  );\n\n  const {\n    bulkBackportProgress,\n    isBulkBackportActive,\n    showBulkBackportModal,\n    handleStartBulkBackport,\n    handleConfirmBulkBackport,\n    handleCancelBulkBackport,\n    handleCloseBulkBackport,\n  } = useBulkBackportSetup({\n    assembleContextForChronicle,\n    reloadEntities,\n    setChronicleRefreshTrigger,\n    simulationRunId,\n    projectId,\n  });\n\n  return {\n    backportRun,\n    isBackportActive,\n    backportChronicleId,\n    toggleBackportPatchDecision,\n    updateBackportAnchorPhrase,\n    cancelBackport,\n    backportConfig,\n    setBackportConfig,\n    handleBackportLore,\n    handleBackportConfigStart,\n    handleAcceptBackport,\n    handleMarkEntityNotNeeded,\n    bulkBackportProgress,\n    isBulkBackportActive,\n    showBulkBackportModal,\n    handleStartBulkBackport,\n    handleConfirmBulkBackport,\n    handleCancelBulkBackport,\n    handleCloseBulkBackport,\n    assembleContextForChronicle,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  getEntityContextsForRevision,\n  reloadEntities,\n  setChronicleRefreshTrigger,\n}", "type": "{ projectId: any; simulationRunId: any; getEntityContextsForRevision: any; reloadEntities: any; setChronicleRefreshTrigger: any; }", "optional": false}], "returnType": "{ backportRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isBackportActive: boolean; backportChronicleId: string; toggleBackportPatchDecision: (entityId: string, accepted: boolean) => Promise<void>; updateBackportAnchorPhrase: (entityId: string, anchorPhrase: string) => Promise<void>; cancelBackport: () => void; backportConfig: any; setBackportConfig: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<any>; handleBackportLore: (chronicleId: any) => Promise<void>; handleBackportConfigStart: (selectedEntityIds: any, customInstructions: any) => void; handleAcceptBackport: () => Promise<void>; handleMarkEntityNotNeeded: (entityIds: any) => Promise<void>; bulkBackportProgress: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useBulkBackport\").BulkBackportProgress; isBulkBackportActive: boolean; showBulkBackportModal: boolean; handleStartBulkBackport: () => Promise<void>; handleConfirmBulkBackport: () => void; handleCancelBulkBackport: () => void; handleCloseBulkBackport: () => void; assembleContextForChronicle: (chronicleId: any) => Promise<{ chronicleId: any; chronicleTitle: string; entities: any[]; chronicleText: string; perspectiveSynthesisJson: string; perEntityStatus: {}; }>; }", "jsxTree": null, "hookCalls": [{"name": "useChronicleLoreBackport", "count": 1}, {"name": "useCallback", "count": 5}, {"name": "useState", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useBulkBackportSetup", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "./useChronicleLoreBackport", "specifiers": ["useChronicleLoreBackport"], "category": "internal"}, {"source": "./useBulkBackport", "specifiers": ["useBulkBackport"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "updateChronicleEntityBackportStatus"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["computeBackportProgress"], "category": "internal"}], "storeAccess": ["useEntityStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useBulkBackport.ts::useBulkBackport", "name": "useBulkBackport", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBulkBackport.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useBulkBackport(deps: {\n  assembleContextForChronicle: (chronicleId: string) => Promise<BackportContext | null>;\n  applyPatches: (\n    patches: SummaryRevisionPatch[],\n    chronicleId: string,\n    sentEntityIds: string[]\n  ) => Promise<void>;\n  getEligibleChronicleIds: (\n    simulationRunId: string\n  ) => Promise<Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>>;\n}): UseBulkBackportReturn {\n  const [progress, setProgress] = useState<BulkBackportProgress>(IDLE_PROGRESS);\n  const cancelledRef = useRef(false);\n  const activeRef = useRef(false);\n\n  // Keep a ref to deps so the async loop always calls the latest callbacks\n  const depsRef = useRef(deps);\n  useEffect(() => {\n    depsRef.current = deps;\n  }, [deps]);\n\n  // Stash scan results so confirmBulkBackport can use them\n  const scanRef = useRef<{\n    simulationRunId: string;\n    projectId: string;\n    eligible: Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>;\n    chronicleContexts: Array<{\n      context: BackportContext;\n      pendingEntities: RevisionEntityContext[];\n    }>;\n  } | null>(null);\n\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__chronicle_lore_backport__\",\n        name: \"Chronicle Lore Backport\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"chronicleLoreBackport\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  const pollForCompletion = useCallback(\n    async (runId: string): Promise<{ patches: SummaryRevisionPatch[]; cost: number } | null> => {\n      while (true) {\n        if (cancelledRef.current) return null;\n        await sleep(POLL_INTERVAL_MS);\n        if (cancelledRef.current) return null;\n\n        const run = await getRevisionRun(runId);\n        if (!run) return null;\n\n        if (run.status === \"run_reviewing\" || run.status === \"batch_reviewing\") {\n          const patches: SummaryRevisionPatch[] = [];\n          for (const batch of run.batches) {\n            for (const patch of batch.patches) {\n              patches.push(patch);\n            }\n          }\n          const cost = run.totalActualCost || 0;\n          await deleteRevisionRun(runId);\n          return { patches, cost };\n        }\n\n        if (run.status === \"failed\") {\n          const error = run.batches[0]?.error || \"Unknown error\";\n          await deleteRevisionRun(runId);\n          throw new Error(error);\n        }\n      }\n    },\n    []\n  );\n\n  // Phase 1: Scan all eligible chronicles and build entity summary for confirmation\n  const prepareBulkBackport = useCallback(async (simulationRunId: string, projectId: string) => {\n    if (activeRef.current) return;\n\n    const eligible = await depsRef.current.getEligibleChronicleIds(simulationRunId);\n    if (eligible.length === 0) return;\n\n    // Scan each chronicle to get actual pending entities\n    const entityChronicleCount = new Map<\n      string,\n      { entity: RevisionEntityContext; count: number }\n    >();\n    const chronicleContexts: Array<{\n      context: BackportContext;\n      pendingEntities: RevisionEntityContext[];\n    }> = [];\n\n    for (const { chronicleId } of eligible) {\n      const context = await depsRef.current.assembleContextForChronicle(chronicleId);\n      if (!context) continue;\n\n      const pendingEntities = context.entities.filter((e) => !context.perEntityStatus[e.id]);\n      if (pendingEntities.length === 0) continue;\n\n      chronicleContexts.push({ context, pendingEntities });\n\n      for (const entity of pendingEntities) {\n        const existing = entityChronicleCount.get(entity.id);\n        if (existing) {\n          existing.count++;\n        } else {\n          entityChronicleCount.set(entity.id, { entity, count: 1 });\n        }\n      }\n    }\n\n    if (chronicleContexts.length === 0) return;\n\n    // Build entity summary sorted by chronicle count (descending), then name\n    const entitySummary: BulkBackportEntitySummary[] = Array.from(entityChronicleCount.values())\n      .map(({ entity, count }) => ({\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n        entitySubtype: entity.subtype,\n        chronicleCount: count,\n      }))\n      .sort(\n        (a, b) => b.chronicleCount - a.chronicleCount || a.entityName.localeCompare(b.entityName)\n      );\n\n    const chronicleProgress: BulkBackportChronicleProgress[] = chronicleContexts.map(\n      ({ context, pendingEntities }) => ({\n        chronicleId: context.chronicleId,\n        chronicleTitle: context.chronicleTitle,\n        totalEntities: pendingEntities.length,\n        processedEntities: 0,\n        totalBatches: Math.ceil(pendingEntities.length / MAX_BATCH_SIZE),\n        completedBatches: 0,\n        status: \"pending\" as const,\n      })\n    );\n\n    const totalEntities = chronicleProgress.reduce((sum, c) => sum + c.totalEntities, 0);\n\n    // Stash for confirmBulkBackport\n    scanRef.current = { simulationRunId, projectId, eligible, chronicleContexts };\n\n    setProgress({\n      status: \"confirming\",\n      chronicles: chronicleProgress,\n      currentChronicleIndex: 0,\n      totalEntities,\n      processedEntities: 0,\n      totalCost: 0,\n      entitySummary,\n    });\n  }, []);\n\n  // Phase 2: User confirmed \u2014 run the processing loop\n  const confirmBulkBackport = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    // Clear entity summary and transition to running\n    setProgress((p) => ({ ...p, status: \"running\", entitySummary: undefined }));\n\n    // Run the async processing loop\n    void (async () => {\n      try {\n        const { simulationRunId, projectId, chronicleContexts } = scan;\n\n        // Re-read progress for chronicle list (was set in prepare)\n        const chronicleProgress: BulkBackportChronicleProgress[] = chronicleContexts.map(\n          ({ context, pendingEntities }) => ({\n            chronicleId: context.chronicleId,\n            chronicleTitle: context.chronicleTitle,\n            totalEntities: pendingEntities.length,\n            processedEntities: 0,\n            totalBatches: Math.ceil(pendingEntities.length / MAX_BATCH_SIZE),\n            completedBatches: 0,\n            status: \"pending\" as const,\n          })\n        );\n\n        let globalProcessed = 0;\n        let globalCost = 0;\n\n        for (let ci = 0; ci < chronicleContexts.length; ci++) {\n          if (cancelledRef.current) break;\n\n          const { context: originalContext } = chronicleContexts[ci];\n          const chronicleId = originalContext.chronicleId;\n\n          // Assemble fresh context (entity descriptions may have been updated by prior batches)\n          const context = await depsRef.current.assembleContextForChronicle(chronicleId);\n          if (!context) {\n            chronicleProgress[ci] = {\n              ...chronicleProgress[ci],\n              status: \"complete\",\n              totalEntities: 0,\n              totalBatches: 0,\n            };\n            setProgress((p) => ({\n              ...p,\n              chronicles: [...chronicleProgress],\n              currentChronicleIndex: ci,\n            }));\n            continue;\n          }\n\n          const pendingEntities = context.entities.filter((e) => !context.perEntityStatus[e.id]);\n          if (pendingEntities.length === 0) {\n            chronicleProgress[ci] = {\n              ...chronicleProgress[ci],\n              status: \"complete\",\n              totalEntities: 0,\n              totalBatches: 0,\n            };\n            setProgress((p) => ({\n              ...p,\n              chronicles: [...chronicleProgress],\n              currentChronicleIndex: ci,\n            }));\n            continue;\n          }\n\n          const chunks = chunkEntities(pendingEntities, MAX_BATCH_SIZE);\n\n          chronicleProgress[ci] = {\n            ...chronicleProgress[ci],\n            status: \"running\",\n            totalEntities: pendingEntities.length,\n            totalBatches: chunks.length,\n            completedBatches: 0,\n            processedEntities: 0,\n          };\n          setProgress((p) => ({\n            ...p,\n            chronicles: [...chronicleProgress],\n            currentChronicleIndex: ci,\n          }));\n\n          let chronicleFailed = false;\n\n          for (let bi = 0; bi < chunks.length; bi++) {\n            if (cancelledRef.current) break;\n\n            const chunk = chunks[bi];\n            const runId = generateRevisionRunId();\n\n            await createRevisionRun(\n              runId,\n              projectId,\n              simulationRunId,\n              [\n                {\n                  culture: \"cast\",\n                  entityIds: chunk.map((e) => e.id),\n                  status: \"pending\" as const,\n                  patches: [],\n                },\n              ],\n              {\n                worldDynamicsContext: context.chronicleText,\n                staticPagesContext: context.perspectiveSynthesisJson,\n                schemaContext: \"\",\n                revisionGuidance: \"\",\n              }\n            );\n\n            dispatchBatch(runId, chunk);\n\n            try {\n              const result = await pollForCompletion(runId);\n              if (cancelledRef.current || !result) break;\n\n              const batchEntityIds = chunk.map((e) => e.id);\n              if (result.patches.length > 0) {\n                await depsRef.current.applyPatches(result.patches, chronicleId, batchEntityIds);\n              } else {\n                await depsRef.current.applyPatches([], chronicleId, batchEntityIds);\n              }\n\n// ... (truncated)", "parameters": [{"name": "deps", "type": "{\n  assembleContextForChronicle: (chronicleId: string) => Promise<BackportContext | null>;\n  applyPatches: (\n    patches: SummaryRevisionPatch[],\n    chronicleId: string,\n    sentEntityIds: string[]\n  ) => Promise<void>;\n  getEligibleChronicleIds: (\n    simulationRunId: string\n  ) => Promise<Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>>;\n}", "optional": false}], "returnType": "UseBulkBackportReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 4}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 5}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useBulkHistorian.ts::useBulkHistorian", "name": "useBulkHistorian", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBulkHistorian.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useBulkHistorian(deps: {\n  buildReviewContext: (\n    entityId: string,\n    tone: HistorianTone\n  ) => Promise<HistorianReviewConfig | null>;\n  buildEditionContext: (\n    entityId: string,\n    tone: HistorianTone,\n    reEdition?: boolean\n  ) => Promise<HistorianEditionConfig | null>;\n  applyReviewNotes: (entityId: string, notes: HistorianNote[]) => Promise<void>;\n  applyEditionPatches: (patches: SummaryRevisionPatch[]) => Promise<string[]>;\n  reloadEntities: (entityIds: string[]) => Promise<void>;\n  getEntityNav: (entityId: string) => EntityNavItem | undefined;\n}): UseBulkHistorianReturn {\n  const [progress, setProgress] = useState<BulkHistorianProgress>(IDLE_PROGRESS);\n  const cancelledRef = useRef(false);\n  const activeRef = useRef(false);\n\n  const depsRef = useRef(deps);\n  useEffect(() => {\n    depsRef.current = deps;\n  }, [deps]);\n\n  // Stash scan results so confirmBulkHistorian can use them\n  const scanRef = useRef<{\n    operation: BulkHistorianOperation;\n    tone: HistorianTone;\n    entities: BulkHistorianEntitySummary[];\n    reEdition?: boolean;\n  } | null>(null);\n\n  // Cancellation check for shared poll helper\n  const isCancelled = useCallback(() => cancelledRef.current, []);\n\n  // Dispatch a historian edition task\n  const dispatchEditionTask = useCallback((runId: string) => {\n    getEnqueue()([\n      {\n        entity: {\n          id: \"__historian_edition__\",\n          name: \"Historian Edition\",\n          kind: \"system\",\n          subtype: \"\",\n          prominence: \"\",\n          culture: \"\",\n          status: \"active\",\n          description: \"\",\n          tags: {},\n        },\n        type: \"historianEdition\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: runId,\n      },\n    ]);\n  }, []);\n\n  // Poll edition run for completion\n  const pollEditionCompletion = useCallback(\n    async (runId: string): Promise<{ patches: SummaryRevisionPatch[]; cost: number } | null> => {\n      while (true) {\n        if (cancelledRef.current) return null;\n        await sleep(POLL_INTERVAL_MS);\n        if (cancelledRef.current) return null;\n\n        const run = await getRevisionRun(runId);\n        if (!run) return null;\n\n        if (run.status === \"run_reviewing\" || run.status === \"batch_reviewing\") {\n          const patches: SummaryRevisionPatch[] = [];\n          for (const batch of run.batches) {\n            for (const patch of batch.patches) {\n              patches.push(patch);\n            }\n          }\n          const cost = run.totalActualCost || 0;\n          await deleteRevisionRun(runId);\n          return { patches, cost };\n        }\n\n        if (run.status === \"failed\") {\n          const error = run.batches[0]?.error || \"Unknown error\";\n          await deleteRevisionRun(runId);\n          throw new Error(error);\n        }\n      }\n    },\n    []\n  );\n\n  // Phase 1: Build entity summary for confirmation\n  const prepareBulkHistorian = useCallback(\n    (\n      operation: BulkHistorianOperation,\n      tone: HistorianTone,\n      entityIds: string[],\n      reEdition?: boolean\n    ) => {\n      if (activeRef.current) return;\n\n      // Resolve nav items and build summary\n      const resolved: Array<{ nav: EntityNavItem; summary: BulkHistorianEntitySummary }> = [];\n      for (const id of entityIds) {\n        const nav = depsRef.current.getEntityNav(id);\n        if (!nav) continue;\n        // Clear: needs historian notes. Review/edition: needs a description.\n        if (operation === \"clear\" ? !nav.hasHistorianNotes : !nav.hasDescription) continue;\n        resolved.push({\n          nav,\n          summary: {\n            entityId: nav.id,\n            entityName: nav.name,\n            entityKind: nav.kind,\n            entitySubtype: nav.subtype,\n            tokenEstimate:\n              operation === \"edition\"\n                ? Math.ceil((nav.descriptionWordCount || 0) * 1.35)\n                : undefined,\n          },\n        });\n      }\n\n      // For review: assign tones via stratified cycling.\n      // Sort by (kind, culture, prominence) so similar entities are adjacent,\n      // then cycle tones globally \u2014 each stratum starts where the previous left off,\n      // preventing any tone from being over-represented within a stratum.\n      if (operation === \"review\") {\n        resolved.sort(\n          (a, b) =>\n            a.nav.kind.localeCompare(b.nav.kind) ||\n            a.nav.culture.localeCompare(b.nav.culture) ||\n            a.nav.prominence - b.nav.prominence\n        );\n        for (let i = 0; i < resolved.length; i++) {\n          resolved[i].summary.tone = TONE_CYCLE[i % TONE_CYCLE.length];\n        }\n      }\n\n      const entities = resolved.map((r) => r.summary);\n\n      if (entities.length === 0) return;\n\n      scanRef.current = { operation, tone, entities, reEdition };\n\n      setProgress({\n        status: \"confirming\",\n        operation,\n        tone,\n        entities,\n        totalEntities: entities.length,\n        processedEntities: 0,\n        currentEntityName: \"\",\n        totalCost: 0,\n        failedEntities: [],\n      });\n    },\n    []\n  );\n\n  // Allow tone change during confirmation (edition mode)\n  const setTone = useCallback((tone: HistorianTone) => {\n    if (scanRef.current) {\n      scanRef.current.tone = tone;\n    }\n    setProgress((p) => (p.status === \"confirming\" ? { ...p, tone } : p));\n  }, []);\n\n  // Phase 2: Process all entities sequentially\n  const confirmBulkHistorian = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    setProgress((p) => ({ ...p, status: \"running\" }));\n\n    void (async () => {\n      try {\n        const { operation, tone, entities, reEdition } = scan;\n\n        let globalProcessed = 0;\n        let globalCost = 0;\n        const failedEntities: Array<{ entityId: string; entityName: string; error: string }> = [];\n\n        if (operation === \"clear\") {\n          // Clear all historian notes \u2014 no enrichment dispatch, just DB writes\n          for (const entity of entities) {\n            if (cancelledRef.current) break;\n\n            setProgress((p) => ({ ...p, currentEntityName: entity.entityName }));\n\n            try {\n              await depsRef.current.applyReviewNotes(entity.entityId, []);\n              await depsRef.current.reloadEntities([entity.entityId]);\n              globalProcessed++;\n              setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n            } catch (err) {\n              globalProcessed++;\n              failedEntities.push({\n                entityId: entity.entityId,\n                entityName: entity.entityName,\n                error: err instanceof Error ? err.message : String(err),\n              });\n              setProgress((p) => ({\n                ...p,\n                processedEntities: globalProcessed,\n                failedEntities: [...failedEntities],\n              }));\n            }\n          }\n        } else {\n          // Review or edition \u2014 shuffle then process sequentially\n          const shuffled = [...entities];\n          for (let s = shuffled.length - 1; s > 0; s--) {\n            // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for processing order\n            const j = Math.floor(Math.random() * (s + 1));\n            [shuffled[s], shuffled[j]] = [shuffled[j], shuffled[s]];\n          }\n\n          for (let i = 0; i < shuffled.length; i++) {\n            if (cancelledRef.current) break;\n\n            const entity = shuffled[i];\n            const entityTone = operation === \"review\" && entity.tone ? entity.tone : tone;\n\n            setProgress((p) => ({\n              ...p,\n              currentEntityName: entity.entityName,\n              currentEntityTone: entityTone,\n            }));\n\n            try {\n              if (operation === \"review\") {\n                const config = await depsRef.current.buildReviewContext(\n                  entity.entityId,\n                  entityTone\n                );\n                if (!config) {\n                  globalProcessed++;\n                  setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n                  continue;\n                }\n\n                const runId = generateHistorianRunId();\n                const now = Date.now();\n\n                await createHistorianRun({\n                  runId,\n                  projectId: config.projectId,\n                  simulationRunId: config.simulationRunId,\n                  status: \"pending\",\n                  tone: config.tone,\n                  targetType: config.targetType,\n                  targetId: config.targetId,\n                  targetName: config.targetName,\n                  sourceText: config.sourceText,\n                  notes: [],\n                  noteDecisions: {},\n                  contextJson: config.contextJson,\n                  previousNotesJson: config.previousNotesJson,\n                  historianConfigJson: JSON.stringify(config.historianConfig),\n                  inputTokens: 0,\n                  outputTokens: 0,\n                  actualCost: 0,\n                  createdAt: now,\n                  updatedAt: now,\n                });\n\n                sharedDispatchReview(runId);\n\n                const result = await sharedPollReview(runId, isCancelled);\n                if (cancelledRef.current || !result) break;\n\n                if (result.notes.length > 0) {\n                  await depsRef.current.applyReviewNotes(entity.entityId, result.notes);\n                }\n                globalCost += result.cost;\n              } else {\n                // edition\n                const config = await depsRef.current.buildEditionContext(\n                  entity.entityId,\n                  entityTone,\n                  reEdition\n                );\n                if (!config) {\n                  globalProcessed++;\n                  setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n                  continue;\n                }\n\n                const runId = generateRevisionRunId();\n\n                await createRevisionRun(\n                  runId,\n                  config.projectId,\n// ... (truncated)", "parameters": [{"name": "deps", "type": "{\n  buildReviewContext: (\n    entityId: string,\n    tone: HistorianTone\n  ) => Promise<HistorianReviewConfig | null>;\n  buildEditionContext: (\n    entityId: string,\n    tone: HistorianTone,\n    reEdition?: boolean\n  ) => Promise<HistorianEditionConfig | null>;\n  applyReviewNotes: (entityId: string, notes: HistorianNote[]) => Promise<void>;\n  applyEditionPatches: (patches: SummaryRevisionPatch[]) => Promise<string[]>;\n  reloadEntities: (entityIds: string[]) => Promise<void>;\n  getEntityNav: (e...", "optional": false}], "returnType": "UseBulkHistorianReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 4}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 7}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone", "HistorianNote"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionPatch"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "generateHistorianRunId"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}, {"source": "../lib/db/historianRunHelpers", "specifiers": ["dispatchReviewTask as sharedDispatchReview", "pollReviewCompletion as sharedPollReview", "sleep", "POLL_INTERVAL_MS"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useChronicleActions.ts::useChronicleActions", "name": "useChronicleActions", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleActions.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useChronicleActions() {\n  const getChronicle = useCallback(\n    (chronicleId: string): ChronicleRecord | undefined =>\n      useChronicleStore.getState().cache.get(chronicleId),\n    []\n  );\n\n  const generateV2 = useCallback(\n    (\n      chronicleId: string,\n      context: ChronicleGenerationContext,\n      metadata: ChronicleMetadata | undefined\n    ) => {\n      if (!context.focus) {\n        console.error(\"[Chronicle V2] Focus context required\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle V2] Narrative style required for generation\");\n        return;\n      }\n\n      const chronicle = getChronicle(chronicleId);\n      const entity = buildEntityRefFromContext(chronicleId, context, chronicle);\n\n      getEnqueue()([\n        {\n          entity,\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"generate_v2\",\n          chronicleId: metadata?.chronicleId || chronicleId,\n          chronicleMetadata: metadata,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateSummary = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent) {\n        console.error(\"[Chronicle] Summary refinements are only available before acceptance\");\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to summarize\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required to generate summary\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromContext(chronicleId, context, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"summary\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateTitle = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      const content = chronicle.finalContent || chronicle.assembledContent;\n      if (!content) {\n        console.error(\"[Chronicle] No content to generate title from\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"title\" as ChronicleStep,\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateImageRefs = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent) {\n        console.error(\"[Chronicle] Image refs are only available before acceptance\");\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to draft image refs\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required to generate image refs\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromContext(chronicleId, context, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"image_refs\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const regenerateWithSampling = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent || chronicle.status === \"complete\") {\n        console.error(\"[Chronicle] Sampling regeneration is only available before acceptance\");\n        return;\n      }\n      if (!chronicle.generationSystemPrompt || !chronicle.generationUserPrompt) {\n        console.error(\"[Chronicle] Stored prompts missing; cannot regenerate\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"regenerate_temperature\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const compareVersions = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to compare\");\n        return;\n      }\n      const historyCount = chronicle.generationHistory?.length || 0;\n      if (historyCount < 2) {\n        console.error(\"[Chronicle] Need at least 2 versions to compare\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"compare\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const combineVersions = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to combine\");\n        return;\n      }\n      const historyCount = chronicle.generationHistory?.length || 0;\n      if (historyCount < 2) {\n        console.error(\"[Chronicle] Need at least 2 versions to combine\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"combine\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const copyEdit = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to copy-edit\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"copy_edit\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const temporalCheck = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content for temporal check\");\n        return;\n      }\n      if (!chronicle.perspectiveSynthesis?.temporalNarrative) {\n        console.error(\"[Chronicle] No temporal narrative available for temporal check\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"temporal_check\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  /**\n   * Full regeneration with new perspective synthesis.\n   * Creates a new version by running the complete generation pipeline.\n   * Unlike sampling regeneration, this generates fresh perspective synthesis.\n   */\n  const regenerateFull = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent || chronicle.status === \"complete\") {\n        console.error(\"[Chronicle] Full regeneration requires unpublishing first\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required for full regeneration\");\n        return;\n// ... (truncated)", "parameters": [], "returnType": "{ generateV2: (chronicleId: string, context: ChronicleGenerationContext, metadata: ChronicleMetadata | undefined) => void; generateSummary: (chronicleId: string, context: ChronicleGenerationContext) => void; generateTitle: (chronicleId: string) => void; generateImageRefs: (chronicleId: string, context: ChronicleGenerationContext) => void; regenerateWithSampling: (chronicleId: string) => void; regenerateFull: (chronicleId: string, context: ChronicleGenerationContext) => void; regenerateCreative: (chronicleId: string, context: ChronicleGenerationContext) => void; compareVersions: (chronicleId: string) => void; combineVersions: (chronicleId: string) => void; copyEdit: (chronicleId: string) => void; temporalCheck: (chronicleId: string) => void; quickCheck: (chronicleId: string) => void; }", "jsxTree": null, "hookCalls": [{"name": "useCallback", "count": 13}], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleSampling"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType", "ChronicleStep"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}], "storeAccess": ["useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useChronicleLoreBackport.ts::useChronicleLoreBackport", "name": "useChronicleLoreBackport", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleLoreBackport.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useChronicleLoreBackport(\n  getEntityContexts: (entityIds: string[]) => RevisionEntityContext[]\n): UseChronicleLoreBackportReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const [chronicleId, setChronicleId] = useState<string | null>(null);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for the single batch\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__chronicle_lore_backport__\",\n        name: \"Chronicle Lore Backport\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"chronicleLoreBackport\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new backport session\n  const startBackport = useCallback(\n    async (config: ChronicleLoreBackportConfig) => {\n      const runId = generateRevisionRunId();\n\n      // Single batch with all cast entity IDs\n      const batches = [\n        {\n          culture: \"cast\",\n          entityIds: config.entities.map((e) => e.id),\n          status: \"pending\" as const,\n          patches: [],\n        },\n      ];\n\n      // Create run in IndexedDB\n      // Repurpose context fields: worldDynamicsContext = chronicle text, staticPagesContext = perspective JSON\n      // revisionGuidance = custom user instructions for the backport\n      const newRun = await createRevisionRun(\n        runId,\n        config.projectId,\n        config.simulationRunId,\n        batches,\n        {\n          worldDynamicsContext: config.chronicleText,\n          staticPagesContext: config.perspectiveSynthesisJson,\n          schemaContext: \"\",\n          revisionGuidance: config.customInstructions || \"\",\n        }\n      );\n\n      setRun(newRun);\n      setIsActive(true);\n      setChronicleId(config.chronicleId);\n\n      // Dispatch the single batch \u2014 use config.entities directly to preserve isLens flags\n      dispatchBatch(runId, config.entities);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchBatch, startPolling, getEntityContexts]\n  );\n\n  // Toggle accept/reject for a specific entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Update anchor phrase for a patch (user override)\n  const updateAnchorPhrase = useCallback(\n    async (entityId: string, anchorPhrase: string) => {\n      if (!run) return;\n\n      // Update the patch in the batch\n      const updatedBatches = run.batches.map((batch) => ({\n        ...batch,\n        patches: batch.patches.map((p) => (p.entityId === entityId ? { ...p, anchorPhrase } : p)),\n      }));\n      await updateRevisionRun(run.runId, { batches: updatedBatches });\n      setRun((prev) => (prev ? { ...prev, batches: updatedBatches } : null));\n    },\n    [run]\n  );\n\n  // Apply all accepted patches and return them\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect all patches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    setChronicleId(null);\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelBackport = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    setChronicleId(null);\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    chronicleId,\n    startBackport,\n    togglePatchDecision,\n    updateAnchorPhrase,\n    applyAccepted,\n    cancelBackport,\n  };\n}", "parameters": [{"name": "getEntityContexts", "type": "(entityIds: string[]) => RevisionEntityContext[]", "optional": false}], "returnType": "UseChronicleLoreBackportReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 8}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useChronicleQueueWatcher.ts::useChronicleQueueWatcher", "name": "useChronicleQueueWatcher", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleQueueWatcher.ts", "sourceCode": "export function useChronicleQueueWatcher(queue: QueueItem[]): void {\n  const processedRef = useRef<Map<string, ProcessedStatus>>(new Map());\n  const activeRef = useRef(true);\n\n  useEffect(() => {\n    activeRef.current = true;\n    return () => {\n      activeRef.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const processed = processedRef.current;\n\n    // Clear processed markers if task is retried (queued/running again).\n    for (const item of queue) {\n      if ((item.status === \"queued\" || item.status === \"running\") && processed.has(item.id)) {\n        processed.delete(item.id);\n      }\n    }\n\n    // Prune processed entries for tasks no longer in queue.\n    const queueIds = new Set(queue.map((item) => item.id));\n    for (const id of processed.keys()) {\n      if (!queueIds.has(id)) processed.delete(id);\n    }\n\n    const chronicleTasks = queue.filter(\n      (item) =>\n        item.type === \"entityChronicle\" ||\n        item.type === \"historianPrep\" ||\n        (item.type === \"image\" &&\n          (item.imageType === \"chronicle\" || item.imageType === \"era_narrative\"))\n    );\n\n    const completedTasks = chronicleTasks.filter(\n      (item) =>\n        (item.status === \"complete\" || item.status === \"error\") &&\n        processed.get(item.id) !== item.status\n    );\n\n    if (completedTasks.length > 0) {\n      console.log(\n        \"[ChronicleQueueWatcher] Processing\",\n        completedTasks.length,\n        \"completed tasks:\",\n        completedTasks.map((t) => ({\n          id: t.id,\n          type: t.type,\n          step: t.chronicleStep,\n          chronicleId: t.chronicleId,\n          resultChronicleId: t.result?.chronicleId,\n        }))\n      );\n      const chronicleIds = new Set<string>();\n      const updates: Promise<unknown>[] = [];\n      let refreshAll = false;\n\n      for (const task of completedTasks) {\n        processed.set(task.id, task.status as ProcessedStatus);\n\n        if (task.type === \"image\" && task.imageType === \"chronicle\") {\n          if (!task.chronicleId || !task.imageRefId) continue;\n          const chronicleId = task.chronicleId;\n          const isCover = task.imageRefId === \"__cover_image__\";\n          const imageId = task.result?.imageId || \"\";\n\n          if (task.status === \"complete\") {\n            if (!imageId) {\n              const error = \"Image generation returned no image id\";\n              if (isCover) {\n                updates.push(\n                  updateChronicleCoverImageStatus(chronicleId, {\n                    status: \"failed\",\n                    error,\n                  })\n                );\n              } else {\n                updates.push(\n                  updateChronicleImageRef(chronicleId, task.imageRefId, {\n                    status: \"failed\",\n                    error,\n                  })\n                );\n              }\n            } else if (isCover) {\n              updates.push(\n                updateChronicleCoverImageStatus(chronicleId, {\n                  status: \"complete\",\n                  generatedImageId: imageId,\n                })\n              );\n            } else {\n              updates.push(\n                updateChronicleImageRef(chronicleId, task.imageRefId, {\n                  status: \"complete\",\n                  generatedImageId: imageId,\n                })\n              );\n            }\n          } else {\n            const error = task.error || \"Image generation failed\";\n            if (isCover) {\n              updates.push(\n                updateChronicleCoverImageStatus(chronicleId, {\n                  status: \"failed\",\n                  error,\n                })\n              );\n            } else {\n              updates.push(\n                updateChronicleImageRef(chronicleId, task.imageRefId, {\n                  status: \"failed\",\n                  error,\n                })\n              );\n            }\n          }\n\n          chronicleIds.add(chronicleId);\n          continue;\n        }\n\n        // Era narrative images \u2014 chronicleId is repurposed as narrativeId\n        if (task.type === \"image\" && task.imageType === \"era_narrative\") {\n          const narrativeId = task.chronicleId;\n          if (!narrativeId || !task.imageRefId) continue;\n          const isCover = task.imageRefId === \"__cover_image__\";\n          const imageId = task.result?.imageId || \"\";\n\n          if (task.status === \"complete\") {\n            if (!imageId) {\n              const error = \"Image generation returned no image id\";\n              if (isCover) {\n                updates.push(\n                  updateEraNarrativeCoverImageStatus(narrativeId, \"failed\", undefined, error)\n                );\n              } else {\n                updates.push(\n                  updateEraNarrativeImageRefStatus(\n                    narrativeId,\n                    task.imageRefId,\n                    \"failed\",\n                    undefined,\n                    error\n                  )\n                );\n              }\n            } else if (isCover) {\n              updates.push(updateEraNarrativeCoverImageStatus(narrativeId, \"complete\", imageId));\n            } else {\n              updates.push(\n                updateEraNarrativeImageRefStatus(narrativeId, task.imageRefId, \"complete\", imageId)\n              );\n            }\n          } else {\n            const error = task.error || \"Image generation failed\";\n            if (isCover) {\n              updates.push(\n                updateEraNarrativeCoverImageStatus(narrativeId, \"failed\", undefined, error)\n              );\n            } else {\n              updates.push(\n                updateEraNarrativeImageRefStatus(\n                  narrativeId,\n                  task.imageRefId,\n                  \"failed\",\n                  undefined,\n                  error\n                )\n              );\n            }\n          }\n          // No chronicle refresh needed \u2014 EraNarrativeViewer polls directly\n          continue;\n        }\n\n        if (task.type === \"historianPrep\") {\n          if (task.chronicleId) chronicleIds.add(task.chronicleId);\n          continue;\n        }\n\n        if (task.type === \"entityChronicle\") {\n          // Prefer result's chronicleId (the actual ID that was updated) over input chronicleId\n          const chronicleId = task.result?.chronicleId || task.chronicleId;\n          if (chronicleId) {\n            chronicleIds.add(chronicleId);\n          } else {\n            console.log(\n              \"[ChronicleQueueWatcher] No chronicleId found on task, triggering refreshAll\"\n            );\n            refreshAll = true;\n          }\n        }\n      }\n\n      const store = useChronicleStore.getState();\n      const refresh = () => {\n        if (!activeRef.current) {\n          console.log(\"[ChronicleQueueWatcher] Skipping refresh - component inactive\");\n          return;\n        }\n        console.log(\"[ChronicleQueueWatcher] Refreshing:\", {\n          refreshAll,\n          chronicleIds: Array.from(chronicleIds),\n        });\n        if (refreshAll) {\n          void store.refreshAll();\n        }\n        for (const id of chronicleIds) {\n          console.log(\"[ChronicleQueueWatcher] Calling refreshChronicle for:\", id);\n          void store.refreshChronicle(id);\n        }\n      };\n\n      if (updates.length > 0) {\n        void Promise.allSettled(updates).then(refresh);\n      } else {\n        refresh();\n      }\n    }\n  }, [queue]);\n}", "parameters": [{"name": "queue", "type": "QueueItem[]", "optional": false}], "returnType": "void", "jsxTree": null, "hookCalls": [{"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}], "imports": [{"source": "react", "specifiers": ["useEffect", "useRef"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["QueueItem"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["updateChronicleCoverImageStatus", "updateChronicleImageRef"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["updateEraNarrativeCoverImageStatus", "updateEraNarrativeImageRefStatus"], "category": "internal"}], "storeAccess": ["useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useDataSync.js::useDataSync", "name": "useDataSync", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDataSync.js", "sourceCode": "// --- Main hook ---\n\nexport function useDataSync({\n  projectId,\n  activeSlotIndex,\n  worldData,\n  hasHardState,\n  slotRecord,\n  setSlotRecord,\n  simulationRunId,\n  eraTemporalInfo,\n}) {\n  const [dataSyncStatus, setDataSyncStatus] = useState(null);\n  const [isDataSyncing, setIsDataSyncing] = useState(false);\n\n  const reloadEntities = useCallback(\n    (invalidateIds, overrideRunId) =>\n      createReloadEntities(simulationRunId)(invalidateIds, overrideRunId),\n    [simulationRunId]\n  );\n  const reloadEntitiesAndEvents = useCallback(\n    (invalidateIds, overrideRunId) =>\n      createReloadEntitiesAndEvents(simulationRunId)(invalidateIds, overrideRunId),\n    [simulationRunId]\n  );\n\n  const handleDataSync = useCallback(\n    async (mode) => {\n      const result = validateDataSyncPreconditions(mode, worldData, hasHardState, slotRecord);\n      if (result.error) {\n        setDataSyncStatus({ type: \"error\", message: result.error });\n        return;\n      }\n      if (result.cancelled) return;\n      setIsDataSyncing(true);\n      setDataSyncStatus(null);\n      try {\n        const message =\n          mode === \"overwrite\"\n            ? await performOverwriteSync(result.hardRunId, worldData)\n            : await performPatchSync(result.hardRunId, worldData);\n        setDataSyncStatus({ type: \"success\", message });\n        await syncAncillaryData(result.hardRunId, projectId, worldData);\n        const nextSlot = buildNextSlotRecord(\n          result.hardRunId,\n          projectId,\n          activeSlotIndex,\n          worldData,\n          slotRecord\n        );\n        await slotRepo.upsertSlot(nextSlot);\n        setSlotRecord(nextSlot);\n        await reinitializeStoresAfterSync(result.hardRunId);\n      } catch (err) {\n        setDataSyncStatus({\n          type: \"error\",\n          message: err instanceof Error ? err.message : String(err),\n        });\n      } finally {\n        setIsDataSyncing(false);\n      }\n    },\n    [activeSlotIndex, hasHardState, projectId, slotRecord, worldData, setSlotRecord]\n  );\n\n  const handleEntityUpdate = useCallback(\n    async (entityId, output) => {\n      await applyEntityEnrichment(entityId, output);\n      await reloadEntities([entityId]);\n    },\n    [reloadEntities]\n  );\n\n  const handleRefreshEraSummaries = useCallback(async () => {\n    if (!simulationRunId || !eraTemporalInfo.length) return 0;\n    const count = await refreshEraSummariesInChronicles(simulationRunId, eraTemporalInfo);\n    if (count > 0) await useChronicleStore.getState().refreshAll();\n    return count;\n  }, [simulationRunId, eraTemporalInfo]);\n\n  useEffect(() => {\n    const handler = (event) => {\n      if (!simulationRunId) return;\n      reloadEntities(event?.detail?.entityIds);\n    };\n    window.addEventListener(\"entities-updated\", handler);\n    return () => window.removeEventListener(\"entities-updated\", handler);\n  }, [reloadEntities, simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n    initializeStoresForRun(simulationRunId).catch((err) =>\n      console.warn(\"[Illuminator] DAL load failed:\", err)\n    );\n  }, [simulationRunId]);\n\n  return {\n    dataSyncStatus,\n    isDataSyncing,\n    handleDataSync,\n    handleEntityUpdate,\n    handleRefreshEraSummaries,\n    reloadEntities,\n    reloadEntitiesAndEvents,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  worldData,\n  hasHardState,\n  slotRecord,\n  setSlotRecord,\n  simulationRunId,\n  eraTemporalInfo,\n}", "type": "{ projectId: any; activeSlotIndex: any; worldData: any; hasHardState: any; slotRecord: any; setSlotRecord: any; simulationRunId: any; eraTemporalInfo: any; }", "optional": false}], "returnType": "{ dataSyncStatus: any; isDataSyncing: boolean; handleDataSync: (mode: any) => Promise<void>; handleEntityUpdate: (entityId: any, output: any) => Promise<void>; handleRefreshEraSummaries: () => Promise<number>; reloadEntities: (invalidateIds: any, overrideRunId: any) => Promise<void>; reloadEntitiesAndEvents: (invalidateIds: any, overrideRunId: any) => Promise<void>; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 5}, {"name": "useEffect", "count": 2}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/eventRepository", "specifiers": ["* as eventRepo"], "category": "internal"}, {"source": "../lib/db/relationshipRepository", "specifiers": ["* as relationshipRepo"], "category": "internal"}, {"source": "../lib/db/slotRepository", "specifiers": ["* as slotRepo"], "category": "internal"}, {"source": "../lib/db/schemaRepository", "specifiers": ["* as schemaRepo"], "category": "internal"}, {"source": "../lib/db/coordinateStateRepository", "specifiers": ["* as coordinateStateRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "../lib/db/narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}, {"source": "../lib/db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["refreshEraSummariesInChronicles"], "category": "internal"}, {"source": "../lib/db/indexComputation", "specifiers": ["computeRunIndexes"], "category": "internal"}, {"source": "../lib/db/indexRepository", "specifiers": ["upsertRunIndexes"], "category": "internal"}], "storeAccess": ["useEntityStore.getState", "useIndexStore.getState", "useNarrativeEventStore.getState", "useRelationshipStore.getState", "useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useDynamicsFlow.js::useDynamicsFlow", "name": "useDynamicsFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDynamicsFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useDynamicsFlow({\n  projectId,\n  simulationRunId,\n  worldContext,\n  worldSchema,\n  entityNavMap,\n  relationships,\n  updateWorldContext,\n}) {\n  // Handle accepted dynamics from LLM\n  const handleDynamicsAccepted = useCallback(\n    (proposedDynamics) => {\n      if (!proposedDynamics?.length) return;\n      const newDynamics = mapProposedDynamics(proposedDynamics);\n      const existing = worldContext?.worldDynamics || [];\n      updateWorldContext({ worldDynamics: [...existing, ...newDynamics] });\n    },\n    [worldContext, updateWorldContext]\n  );\n\n  const {\n    run: dynamicsRun,\n    isActive: isDynamicsActive,\n    startGeneration: startDynamicsGeneration,\n    submitFeedback: submitDynamicsFeedback,\n    acceptDynamics,\n    cancelGeneration: cancelDynamicsGeneration,\n  } = useDynamicsGeneration(handleDynamicsAccepted);\n\n  // Launch dynamics generation with full world context\n  const handleGenerateDynamics = useCallback(async () => {\n    if (!projectId || !simulationRunId) return;\n\n    const staticPagesContext = await loadStaticPagesContext(projectId);\n    const schemaContext = buildSchemaContext(worldSchema);\n\n    // Build entity context -- load full entities from Dexie (needs description, tags)\n    const allEntities = await entityRepo.getEntitiesForRun(simulationRunId);\n    const entityContexts = buildEntityContexts(allEntities);\n    const relationshipsPayload = buildRelationshipsPayload(relationships, entityNavMap);\n\n    startDynamicsGeneration({\n      projectId,\n      simulationRunId,\n      staticPagesContext,\n      schemaContext,\n      entities: entityContexts,\n      relationships: relationshipsPayload,\n    });\n  }, [\n    projectId,\n    simulationRunId,\n    worldSchema,\n    entityNavMap,\n    relationships,\n    startDynamicsGeneration,\n  ]);\n\n  return {\n    dynamicsRun,\n    isDynamicsActive,\n    handleGenerateDynamics,\n    submitDynamicsFeedback,\n    acceptDynamics,\n    cancelDynamicsGeneration,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  worldContext,\n  worldSchema,\n  entityNavMap,\n  relationships,\n  updateWorldContext,\n}", "type": "{ projectId: any; simulationRunId: any; worldContext: any; worldSchema: any; entityNavMap: any; relationships: any; updateWorldContext: any; }", "optional": false}], "returnType": "{ dynamicsRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/dynamicsGenerationTypes\").DynamicsRun; isDynamicsActive: boolean; handleGenerateDynamics: () => Promise<void>; submitDynamicsFeedback: (feedback: string) => Promise<void>; acceptDynamics: () => void; cancelDynamicsGeneration: () => void; }", "jsxTree": null, "hookCalls": [{"name": "useCallback", "count": 2}, {"name": "useDynamicsGeneration", "count": 1}], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "./useDynamicsGeneration", "specifiers": ["useDynamicsGeneration"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getPublishedStaticPagesForProject"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useDynamicsGeneration.ts::useDynamicsGeneration", "name": "useDynamicsGeneration", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDynamicsGeneration.ts", "sourceCode": "export function useDynamicsGeneration(\n  onDynamicsAccepted?: (dynamics: DynamicsRun[\"proposedDynamics\"]) => void\n): UseDynamicsGenerationReturn {\n  const [run, setRun] = useState<DynamicsRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getDynamicsRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on terminal states\n          if (\n            updated.status === \"awaiting_review\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Dispatch a worker task for one LLM turn\n  const dispatchWorkerTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__dynamics__\",\n      name: \"World Dynamics\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"dynamicsGeneration\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: runId, // Repurpose chronicleId for runId\n      },\n    ]);\n  }, []);\n\n  // Start a new generation session\n  const startGeneration = useCallback(\n    async (config: DynamicsGenerationConfig) => {\n      const runId = generateRunId();\n\n      // Create run with full world context as system message\n      const initialMessage: DynamicsMessage = {\n        role: \"system\",\n        content: buildInitialContext(config),\n        timestamp: Date.now(),\n      };\n\n      const newRun = await createDynamicsRun(runId, config.projectId, config.simulationRunId);\n      await updateDynamicsRun(runId, {\n        messages: [initialMessage],\n        status: \"pending\",\n      });\n\n      const updatedRun = await getDynamicsRun(runId);\n      setRun(updatedRun || newRun);\n      setIsActive(true);\n\n      // Dispatch first worker turn\n      dispatchWorkerTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchWorkerTask, startPolling]\n  );\n\n  // Submit user feedback and trigger next turn\n  const submitFeedback = useCallback(\n    async (feedback: string) => {\n      if (!run) return;\n\n      await updateDynamicsRun(run.runId, {\n        userFeedback: feedback,\n        status: \"pending\",\n      });\n\n      // Dispatch next worker turn\n      dispatchWorkerTask(run.runId);\n\n      // Resume polling\n      startPolling(run.runId);\n    },\n    [run, dispatchWorkerTask, startPolling]\n  );\n\n  // Accept proposed dynamics\n  const acceptDynamics = useCallback(() => {\n    if (!run?.proposedDynamics) return;\n\n    onDynamicsAccepted?.(run.proposedDynamics);\n    setIsActive(false);\n    stopPolling();\n\n    // Clean up the run record\n    if (run.runId) {\n      deleteDynamicsRun(run.runId).catch(() => {});\n    }\n  }, [run, onDynamicsAccepted, stopPolling]);\n\n  // Cancel\n  const cancelGeneration = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteDynamicsRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startGeneration,\n    submitFeedback,\n    acceptDynamics,\n    cancelGeneration,\n  };\n}", "parameters": [{"name": "onDynamicsAccepted", "type": "(dynamics: DynamicsRun[\"proposedDynamics\"]) => void", "optional": true}], "returnType": "UseDynamicsGenerationReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsMessage"], "category": "internal"}, {"source": "../lib/db/dynamicsRepository", "specifiers": ["createDynamicsRun", "getDynamicsRun", "updateDynamicsRun", "generateRunId", "deleteDynamicsRun"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useEnrichmentQueue.ts::useEnrichmentQueue", "name": "useEnrichmentQueue", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEnrichmentQueue.ts", "sourceCode": "export function useEnrichmentQueue(\n  onEntityUpdate: (entityId: string, output: ApplyEnrichmentOutput) => void,\n  projectId?: string,\n  simulationRunId?: string\n): UseEnrichmentQueueReturn {\n  const [queue, setQueue] = useState<QueueItem[]>([]);\n  const [isWorkerReady, setIsWorkerReady] = useState(false);\n  const workersRef = useRef<WorkerState[]>([]);\n  const configRef = useRef<WorkerConfig | null>(null);\n  const numWorkersRef = useRef<number>(4);\n  const projectIdRef = useRef<string | undefined>(projectId);\n  const simulationRunIdRef = useRef<string | undefined>(simulationRunId);\n  const reconnectInProgressRef = useRef(false);\n  const autoReconnectAttemptsRef = useRef<Map<string, number>>(new Map());\n  const pendingAutoRetryRef = useRef<Set<string>>(new Set());\n  // Track tasks currently executing in the browser (not on a worker).\n  // Prevents re-entry: queueRef.current is stale until React re-renders,\n  // so without this guard the same task can be picked up multiple times.\n  const browserRunningTasksRef = useRef<Set<string>>(new Set());\n\n  // Keep projectId ref in sync\n  useEffect(() => {\n    projectIdRef.current = projectId;\n  }, [projectId]);\n\n  // Keep simulationRunId ref in sync\n  useEffect(() => {\n    simulationRunIdRef.current = simulationRunId;\n  }, [simulationRunId]);\n\n  // Track which tasks are assigned to which worker\n  const taskWorkerMapRef = useRef<Map<string, number>>(new Map());\n\n  // Refs for accessing latest values in callbacks (avoid stale closures)\n  const queueRef = useRef<QueueItem[]>([]);\n  const onEntityUpdateRef = useRef(onEntityUpdate);\n  const initializeRef = useRef<((config: WorkerConfig) => void) | null>(null);\n\n  // Keep refs in sync\n  useEffect(() => {\n    queueRef.current = queue;\n  }, [queue]);\n\n  useEffect(() => {\n    onEntityUpdateRef.current = onEntityUpdate;\n  }, [onEntityUpdate]);\n\n  // Calculate stats\n  const stats: QueueStats = {\n    queued: queue.filter((item) => item.status === \"queued\").length,\n    running: queue.filter((item) => item.status === \"running\").length,\n    completed: queue.filter((item) => item.status === \"complete\").length,\n    errored: queue.filter((item) => item.status === \"error\").length,\n    total: queue.length,\n  };\n\n  // Process next item for a specific worker (uses refs to avoid stale closures)\n  const processNextForWorker = useCallback(\n    (workerId: number) => {\n      const workerState = workersRef.current.find((w) => w.workerId === workerId);\n      if (!workerState || !workerState.isReady || workerState.currentTaskId) return;\n\n      // Use ref to get latest queue\n      const currentQueue = queueRef.current;\n\n      // Find next queued task assigned to this worker\n      // Also exclude tasks already running in the browser \u2014 queueRef is stale\n      // until React re-renders, so status may still read 'queued'.\n      const nextItem = currentQueue.find(\n        (item) =>\n          item.status === \"queued\" &&\n          taskWorkerMapRef.current.get(item.id) === workerId &&\n          !browserRunningTasksRef.current.has(item.id)\n      );\n\n      if (!nextItem) return;\n\n      workerState.currentTaskId = nextItem.id;\n      workerState.pendingTaskIds.delete(nextItem.id);\n\n      // Update status to running\n      setQueue((prev) =>\n        prev.map((item) =>\n          item.id === nextItem.id\n            ? { ...item, status: \"running\" as const, startedAt: Date.now() }\n            : item\n        )\n      );\n\n      // Build task payload \u2014 strip runtime-only fields via rest destructuring\n      /* eslint-disable @typescript-eslint/no-unused-vars, sonarjs/no-unused-vars, sonarjs/no-dead-store */\n      const {\n        status: _status,\n        queuedAt: _queuedAt,\n        startedAt: _startedAt,\n        completedAt: _completedAt,\n        result: _result,\n        error: _error,\n        debug: _debug,\n        estimatedCost: _estimatedCost,\n        ...taskPayload\n      } = nextItem;\n      /* eslint-enable @typescript-eslint/no-unused-vars, sonarjs/no-unused-vars, sonarjs/no-dead-store */\n      const latestLlmSettings = getResolvedLLMCallSettings();\n      if (configRef.current) {\n        configRef.current = { ...configRef.current, llmCallSettings: latestLlmSettings };\n      }\n      const task: WorkerTask = {\n        ...taskPayload,\n        projectId: projectIdRef.current || \"unknown\",\n        llmCallSettings: latestLlmSettings,\n      };\n\n      // Check if this task should run in the browser instead of the service worker\n      if (shouldRunInBrowser(task.type, latestLlmSettings) && configRef.current) {\n        // Release the worker slot \u2014 this task runs in the main thread\n        workerState.currentTaskId = null;\n        browserRunningTasksRef.current.add(nextItem.id);\n\n        console.log(\"[EnrichmentQueue] Executing in browser\", { taskId: task.id, type: task.type });\n\n        // Initialize thinking entry (same as 'started' message handler)\n        useThinkingStore.getState().startTask(task.id, nextItem.entityName, nextItem.type);\n\n        void executeBrowserTask(task, configRef.current, {\n          onThinkingDelta: (taskId, delta) =>\n            useThinkingStore.getState().appendDelta(taskId, delta),\n          onTextDelta: (taskId, delta) =>\n            useThinkingStore.getState().appendTextDelta(taskId, delta),\n        }).then((taskResult) => {\n          browserRunningTasksRef.current.delete(task.id);\n          taskWorkerMapRef.current.delete(task.id);\n          if (taskResult.success) {\n            setQueue(patchQueueItem(task.id, {\n              status: \"complete\" as const,\n              completedAt: Date.now(),\n              result: taskResult.result,\n              debug: taskResult.debug,\n            }));\n            if (taskResult.result) {\n              const queueItem = queueRef.current.find((item) => item.id === task.id);\n              const isChronicleImage = queueItem?.imageType === \"chronicle\";\n              if (!isChronicleImage) {\n                const output = applyEnrichmentResult(\n                  {},\n                  task.type,\n                  taskResult.result,\n                  queueItem?.entityLockedSummary\n                );\n                onEntityUpdateRef.current(task.entityId, output);\n              }\n            }\n          } else {\n            setQueue(patchQueueItem(task.id, {\n              status: \"error\" as const,\n              completedAt: Date.now(),\n              error: taskResult.error,\n              debug: taskResult.debug,\n            }));\n          }\n          useThinkingStore.getState().finishTask(task.id);\n          // Process next tasks \u2014 browser execution freed this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n        });\n\n        // Process next task for this worker immediately (it's not blocked)\n        setTimeout(() => processNextForWorker(workerId), 0);\n        return;\n      }\n\n      workerState.worker.postMessage({ type: \"execute\", task });\n    },\n    [] // No dependencies - uses refs\n  );\n\n  // Handle worker messages (uses refs to avoid stale closures)\n  const handleMessage = useCallback(\n    (workerId: number) => (event: MessageEvent<WorkerOutbound>) => {\n      const message = event.data;\n      const workerState = workersRef.current.find((w) => w.workerId === workerId);\n\n      switch (message.type) {\n        case \"ready\":\n          if (workerState) {\n            workerState.isReady = true;\n          }\n          // Check if all workers are ready\n          if (workersRef.current.every((w) => w.isReady)) {\n            setIsWorkerReady(true);\n          }\n          break;\n\n        case \"started\": {\n          // Already updated status when we sent the task\n          // Initialize thinking entry for this task\n          const startedItem = queueRef.current.find((item) => item.id === message.taskId);\n          if (startedItem) {\n            useThinkingStore\n              .getState()\n              .startTask(message.taskId, startedItem.entityName, startedItem.type);\n          }\n          break;\n        }\n\n        case \"thinking_delta\":\n          useThinkingStore.getState().appendDelta(message.taskId, message.delta);\n          break;\n\n        case \"text_delta\":\n          useThinkingStore.getState().appendTextDelta(message.taskId, message.delta);\n          break;\n\n        case \"complete\": {\n          const result = message.result;\n\n          if (workerState) {\n            workerState.currentTaskId = null;\n          }\n\n          autoReconnectAttemptsRef.current.delete(result.id);\n          pendingAutoRetryRef.current.delete(result.id);\n\n          // Clean up task-worker mapping\n          taskWorkerMapRef.current.delete(result.id);\n\n          // Worker already saved image to IndexedDB, just update queue and notify parent\n          setQueue(patchQueueItem(result.id, {\n            status: \"complete\" as const,\n            completedAt: Date.now(),\n            result: result.result,\n            debug: result.debug,\n          }));\n\n          // Notify parent to update entity (skip for chronicle images - they have their own storage)\n          if (result.result) {\n            const queueItem = queueRef.current.find((item) => item.id === result.id);\n            const isChronicleImage = queueItem?.imageType === \"chronicle\";\n            if (!isChronicleImage) {\n              const output = applyEnrichmentResult(\n                {},\n                result.type,\n                result.result,\n                queueItem?.entityLockedSummary\n              );\n              onEntityUpdateRef.current(result.entityId, output);\n            }\n          }\n\n          useThinkingStore.getState().finishTask(result.id);\n\n          // Process next task for this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n          break;\n        }\n\n        case \"error\": {\n          if (workerState) {\n            workerState.currentTaskId = null;\n          }\n\n          // Clean up task-worker mapping\n          taskWorkerMapRef.current.delete(message.taskId);\n\n          setQueue(patchQueueItem(message.taskId, {\n            status: \"error\" as const,\n            completedAt: Date.now(),\n            error: message.error,\n            debug: message.debug,\n          }));\n\n          useThinkingStore.getState().finishTask(message.taskId);\n\n          if (message.error?.includes(\"Worker not initialized\")) {\n            const attempts = autoReconnectAttemptsRef.current.get(message.taskId) || 0;\n            if (attempts < MAX_AUTO_RECONNECT_ATTEMPTS) {\n              autoReconnectAttemptsRef.current.set(message.taskId, attempts + 1);\n              pendingAutoRetryRef.current.add(message.taskId);\n              if (workerState) {\n                workerState.isReady = false;\n              }\n              const config = configRef.current;\n              if (config && !reconnectInProgressRef.current) {\n                reconnectInProgressRef.current = true;\n                resetWorkerPool();\n                initializeRef.current?.(config);\n              }\n            }\n          }\n\n          // Process next task for this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n          break;\n        }\n      }\n    },\n    [processNextForWorker] // Only depends on processNextForWorker (which has no deps)\n  );\n\n  // Process queue when it changes - try to start work on idle workers\n  useEffect(() => {\n// ... (truncated)", "parameters": [{"name": "onEntityUpdate", "type": "(entityId: string, output: ApplyEnrichmentOutput) => void", "optional": false}, {"name": "projectId", "type": "string", "optional": true}, {"name": "simulationRunId", "type": "string", "optional": true}], "returnType": "UseEnrichmentQueueReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 13}, {"name": "useEffect", "count": 8}, {"name": "useCallback", "count": 9}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["QueueItem", "EnrichmentTaskPayload", "WorkerTask", "EntityEnrichment", "ApplyEnrichmentOutput"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["applyEnrichmentResult"], "category": "internal"}, {"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}, {"source": "../lib/workerFactory", "specifiers": ["createWorkerPool", "resetWorkerPool", "WorkerHandle"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getResolvedLLMCallSettings", "ResolvedLLMCallSettings"], "category": "internal"}, {"source": "../lib/llmCallTypes", "specifiers": ["LLMCallType"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "../lib/browserTaskExecutor", "specifiers": ["executeBrowserTask"], "category": "internal"}], "storeAccess": ["useThinkingStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useEntityCrud.ts::useEntityCrud", "name": "useEntityCrud", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEntityCrud.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useEntityCrud() {\n  const handleAssignImage = useCallback(\n    async (\n      entityId: string,\n      imageId: string,\n      imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string }\n    ) => {\n      await entityRepo.assignImage(entityId, imageId, imageMetadata);\n      await reloadEntities([entityId]);\n    },\n    []\n  );\n\n  const handleUpdateBackrefs = useCallback(\n    async (entityId: string, updatedBackrefs: Parameters<typeof entityRepo.updateBackrefs>[1]) => {\n      await entityRepo.updateBackrefs(entityId, updatedBackrefs);\n      await reloadEntities([entityId]);\n    },\n    []\n  );\n\n  const handleUndoDescription = useCallback(async (entityId: string) => {\n    await entityRepo.undoDescription(entityId);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateAliases = useCallback(async (entityId: string, aliases: string[]) => {\n    await entityRepo.updateAliases(entityId, aliases);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateDescription = useCallback(async (entityId: string, description: string) => {\n    await entityRepo.updateDescriptionManual(entityId, description);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateSummary = useCallback(async (entityId: string, summary: string) => {\n    await entityRepo.updateSummaryManual(entityId, summary);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleClearNotes = useCallback(async (entityId: string) => {\n    await entityRepo.setHistorianNotes(entityId, []);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleRestoreDescription = useCallback(async (entityId: string, historyIndex: number) => {\n    await entityRepo.restoreDescriptionFromHistory(entityId, historyIndex);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleDeleteEntity = useCallback(async (entity: { id: string; name: string }) => {\n    if (!entity.id.startsWith(\"manual_\")) return;\n    if (!confirm(`Delete \"${entity.name}\"? This cannot be undone.`)) return;\n    try {\n      await entityRepo.deleteEntity(entity.id);\n      await reloadEntities([entity.id]);\n    } catch (err) {\n      console.error(\"[Illuminator] Delete entity failed:\", err);\n    }\n  }, []);\n\n  return {\n    handleAssignImage,\n    handleUpdateBackrefs,\n    handleUndoDescription,\n    handleUpdateAliases,\n    handleUpdateDescription,\n    handleUpdateSummary,\n    handleClearNotes,\n    handleRestoreDescription,\n    handleDeleteEntity,\n  };\n}", "parameters": [], "returnType": "{ handleAssignImage: (entityId: string, imageId: string, imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string; }) => Promise<void>; handleUpdateBackrefs: (entityId: string, updatedBackrefs: Parameters<typeof entityRepo.updateBackrefs>[1]) => Promise<void>; handleUndoDescription: (entityId: string) => Promise<void>; handleUpdateAliases: (entityId: string, aliases: string[]) => Promise<void>; handleUpdateDescription: (entityId: string, description: string) => Promise<void>; handleUpdateSummary: (entityId: string, summary: string) => Promise<void>; handleClearNotes: (entityId: string) => Promise<void>; handleRestoreDescription: (entityId: string, historyIndex: number) => Promise<void>; handleDeleteEntity: (entity: { id: string; name: string; }) => Promise<void>; }", "jsxTree": null, "hookCalls": [{"name": "useCallback", "count": 9}], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}], "storeAccess": ["useEntityStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useEraNarrative.ts::useEraNarrative", "name": "useEraNarrative", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEraNarrative.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useEraNarrative(\n  onEnqueue: (\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void\n): UseEraNarrativeReturn {\n  const [narrative, setNarrative] = useState<EraNarrativeRecord | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const headlessRef = useRef(false);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback(\n    (narrativeId: string) => {\n      const sentinelEntity = {\n        id: \"__era_narrative__\",\n        name: \"Era Narrative\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      onEnqueue([\n        {\n          entity: sentinelEntity,\n          type: \"eraNarrative\" as EnrichmentType,\n          prompt: \"\",\n          chronicleId: narrativeId, // Repurposed for narrativeId\n        },\n      ]);\n    },\n    [onEnqueue]\n  );\n\n  // Advance a narrative to its next step (shared by interactive and headless)\n  const advanceRecord = useCallback(\n    async (narrativeId: string, currentStep: EraNarrativeStep) => {\n      const nextStep = NEXT_STEP[currentStep];\n      if (!nextStep) return;\n\n      await updateEraNarrative(narrativeId, {\n        status: \"pending\",\n        currentStep: nextStep,\n      });\n\n      setNarrative((prev) =>\n        prev\n          ? {\n              ...prev,\n              status: \"pending\",\n              currentStep: nextStep,\n            }\n          : null\n      );\n\n      dispatchTask(narrativeId);\n    },\n    [dispatchTask]\n  );\n\n  // Ref to break circular dependency between startPolling and handlePollTick\n  const startPollingRef = useRef<(narrativeId: string) => void>(() => {});\n\n  // Extracted polling tick logic to reduce nesting depth\n  const handlePollTick = useCallback(\n    async (narrativeId: string) => {\n      const updated = await getEraNarrative(narrativeId);\n      if (!updated) return;\n\n      setNarrative(updated);\n\n      // Terminal states always stop polling\n      if (\n        updated.status === \"complete\" ||\n        updated.status === \"failed\" ||\n        updated.status === \"cancelled\"\n      ) {\n        stopPolling();\n        return;\n      }\n\n      if (updated.status === \"step_complete\") {\n        if (headlessRef.current) {\n          // Headless: auto-advance without user interaction (skips edit)\n          stopPolling();\n\n          const nextStep = NEXT_STEP[updated.currentStep];\n          if (!nextStep || updated.currentStep === \"generate\") {\n            // Final step (or generate in headless \u2014 skip edit): mark complete\n            await updateEraNarrative(updated.narrativeId, { status: \"complete\" });\n            setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n          } else {\n            // Intermediate step: advance and restart polling\n            await advanceRecord(updated.narrativeId, updated.currentStep);\n            startPollingRef.current(updated.narrativeId);\n          }\n        } else {\n          // Interactive: stop polling, wait for user action\n          stopPolling();\n        }\n      }\n    },\n    [stopPolling, advanceRecord]\n  );\n\n  // Poll IndexedDB for state changes\n  const startPolling = useCallback(\n    (narrativeId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void handlePollTick(narrativeId);\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling, handlePollTick]\n  );\n\n  // Keep ref in sync\n  useEffect(() => {\n    startPollingRef.current = startPolling;\n  }, [startPolling]);\n\n  // Create a record and start\n  const createAndStart = useCallback(\n    async (config: EraNarrativeConfig, headless: boolean) => {\n      const narrativeId = generateEraNarrativeId();\n      const now = Date.now();\n\n      const newRecord: EraNarrativeRecord = {\n        narrativeId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        eraId: config.eraId,\n        eraName: config.eraName,\n        status: \"pending\",\n        tone: config.tone,\n        arcDirection: config.arcDirection || undefined,\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        currentStep: \"threads\",\n        prepBriefs: config.prepBriefs,\n        worldContext: config.worldContext,\n        totalInputTokens: 0,\n        totalOutputTokens: 0,\n        totalActualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      headlessRef.current = headless;\n      await createEraNarrative(newRecord);\n      setNarrative(newRecord);\n      setIsActive(true);\n\n      dispatchTask(narrativeId);\n      startPolling(narrativeId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Start interactive session\n  const startNarrative = useCallback(\n    async (config: EraNarrativeConfig) => {\n      await createAndStart(config, false);\n    },\n    [createAndStart]\n  );\n\n  // Start headless session (all steps, no pauses)\n  const startHeadless = useCallback(\n    async (config: EraNarrativeConfig) => {\n      await createAndStart(config, true);\n    },\n    [createAndStart]\n  );\n\n  // Resume an existing narrative from IndexedDB\n  const resumeNarrative = useCallback(\n    async (narrativeId: string) => {\n      const record = await getEraNarrative(narrativeId);\n      if (!record) return;\n\n      headlessRef.current = false;\n      setNarrative(record);\n      setIsActive(true);\n\n      if (record.status === \"pending\" || record.status === \"generating\") {\n        // After a page refresh, the worker that was processing this step is gone.\n        // Reset to pending and re-dispatch so the step actually runs again.\n        await updateEraNarrative(narrativeId, { status: \"pending\" });\n        setNarrative((prev) => (prev ? { ...prev, status: \"pending\" } : null));\n        dispatchTask(narrativeId);\n        startPolling(narrativeId);\n      }\n      // step_complete, failed, complete: just show current state, no polling needed\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Advance to the next step, or mark complete if at the final step\n  const advanceStep = useCallback(async () => {\n    if (!narrative) return;\n    const nextStep = NEXT_STEP[narrative.currentStep];\n    if (!nextStep) {\n      // Final step \u2014 mark complete\n      await updateEraNarrative(narrative.narrativeId, { status: \"complete\" });\n      setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n      stopPolling();\n      return;\n    }\n    await advanceRecord(narrative.narrativeId, narrative.currentStep);\n    startPolling(narrative.narrativeId);\n  }, [narrative, advanceRecord, startPolling, stopPolling]);\n\n  // Skip edit step and mark complete\n  const skipEdit = useCallback(async () => {\n    if (!narrative) return;\n\n    await updateEraNarrative(narrative.narrativeId, { status: \"complete\" });\n    setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n    stopPolling();\n  }, [narrative, stopPolling]);\n\n  // Re-run copy edit on the latest version of a completed narrative\n  const rerunCopyEdit = useCallback(async () => {\n    if (!narrative) return;\n\n    // Reset to edit step + pending so the worker picks it up\n    await updateEraNarrative(narrative.narrativeId, {\n      status: \"pending\",\n      currentStep: \"edit\",\n    });\n\n    setNarrative((prev) =>\n      prev\n        ? {\n            ...prev,\n            status: \"pending\",\n            currentStep: \"edit\",\n          }\n        : null\n    );\n\n    headlessRef.current = false;\n    dispatchTask(narrative.narrativeId);\n    startPolling(narrative.narrativeId);\n  }, [narrative, dispatchTask, startPolling]);\n\n  // Delete a content version (cannot delete the generate version)\n  const deleteVersion = useCallback(\n    async (versionId: string) => {\n      if (!narrative) return;\n      const updated = await deleteEraNarrativeVersion(narrative.narrativeId, versionId);\n      setNarrative(updated);\n    },\n    [narrative]\n  );\n\n  // Set the active content version\n  const setActiveVersion = useCallback(\n    async (versionId: string) => {\n      if (!narrative) return;\n      const updated = await setEraNarrativeActiveVersion(narrative.narrativeId, versionId);\n      setNarrative(updated);\n    },\n    [narrative]\n  );\n\n  // Cancel\n// ... (truncated)", "parameters": [{"name": "onEnqueue", "type": "(\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void", "optional": false}], "returnType": "UseEraNarrativeReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 3}, {"name": "useCallback", "count": 15}, {"name": "useEffect", "count": 2}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianConfig"], "category": "internal"}, {"source": "../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeStep", "EraNarrativePrepBrief", "EraNarrativeWorldContext", "EraNarrativeTone"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["createEraNarrative", "getEraNarrative", "updateEraNarrative", "deleteEraNarrative", "generateEraNarrativeId", "deleteEraNarrativeVersion", "setEraNarrativeActiveVersion"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useFactCoverage.ts::useFactCoverage", "name": "useFactCoverage", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useFactCoverage.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useFactCoverage(): UseFactCoverageReturn {\n  const [progress, setProgress] = useState<FactCoverageProgress>(IDLE_PROGRESS);\n\n  const activeRef = useRef(false);\n  const cancelledRef = useRef(false);\n  const scanRef = useRef<{\n    chronicles: FactCoverageChronicleSummary[];\n    facts: Array<{ id: string; text: string }>;\n  } | null>(null);\n\n  const isActive = progress.status === \"running\" || progress.status === \"confirming\";\n\n  // Phase 1: Prepare\n  const prepareFactCoverage = useCallback((chronicleItems: ChronicleNavItem[]) => {\n    if (activeRef.current) return;\n\n    // Filter to eligible chronicles (have content)\n    const eligible = chronicleItems.filter(\n      (c) => (c.status === \"complete\" || c.status === \"assembly_ready\") && c.wordCount > 0\n    );\n\n    const chronicles: FactCoverageChronicleSummary[] = eligible.map((c) => ({\n      chronicleId: c.chronicleId,\n      title: c.title || c.name,\n    }));\n\n    // Load canon facts from config store\n    const worldContext = useIlluminatorConfigStore.getState().worldContext;\n    const rawFacts = worldContext?.canonFactsWithMetadata ?? [];\n    const facts = rawFacts\n      .filter((f: Record<string, unknown>) => !f.disabled)\n      .map((f: Record<string, unknown>) => ({\n        id: (f.id as string) || (typeof f.text === 'string' ? f.text : String(f.text)).slice(0, 20),\n        text: f.text as string,\n      }));\n\n    if (facts.length === 0) {\n      setProgress({\n        ...IDLE_PROGRESS,\n        status: \"failed\",\n        error: \"No canon facts configured\",\n      });\n      return;\n    }\n\n    scanRef.current = { chronicles, facts };\n\n    setProgress({\n      ...IDLE_PROGRESS,\n      status: \"confirming\",\n      chronicles,\n      totalChronicles: chronicles.length,\n    });\n  }, []);\n\n  // Phase 2: Confirm and run\n  const confirmFactCoverage = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    setProgress((p) => ({ ...p, status: \"running\" }));\n\n    void (async () => {\n      try {\n        const { chronicles, facts } = scan;\n        let globalProcessed = 0;\n        let globalCost = 0;\n        const failedChronicles: Array<{ chronicleId: string; title: string; error: string }> = [];\n\n        for (let i = 0; i < chronicles.length; i++) {\n          if (cancelledRef.current) break;\n\n          const chron = chronicles[i];\n\n          setProgress((p) => ({\n            ...p,\n            currentTitle: chron.title,\n          }));\n\n          try {\n            // Load full chronicle record\n            const record = await getChronicle(chron.chronicleId);\n            const narrativeText = record?.assembledContent || record?.finalContent;\n\n            if (!narrativeText) {\n              globalProcessed++;\n              setProgress((p) => ({ ...p, processedChronicles: globalProcessed }));\n              continue;\n            }\n\n            // Build payload\n            const payload = {\n              chronicleId: chron.chronicleId,\n              narrativeText,\n              facts,\n            };\n\n            // Create synthetic entity for queue dispatch (same pattern as temporal check)\n            const primaryRole =\n              record?.roleAssignments?.find((r) => r.isPrimary) || record?.roleAssignments?.[0];\n            const syntheticEntity = {\n              id: primaryRole?.entityId || chron.chronicleId,\n              name: primaryRole?.entityName || chron.title,\n              kind: primaryRole?.entityKind || \"chronicle\",\n              subtype: \"\",\n              prominence: \"recognized\",\n              culture: \"\",\n              status: \"active\",\n              description: \"\",\n              tags: {},\n            };\n\n            // Clear any previous report timestamp so we can detect the new one\n            const prevTimestamp = record?.factCoverageReportGeneratedAt ?? 0;\n\n            // Dispatch\n            getEnqueue()([\n              {\n                entity: syntheticEntity as never,\n                type: \"factCoverage\" as const,\n                prompt: JSON.stringify(payload),\n                chronicleId: chron.chronicleId,\n              },\n            ]);\n\n            // Poll for completion\n            let result: { cost: number } | null = null;\n            while (!cancelledRef.current) {\n              await sleep(1500);\n              if (cancelledRef.current) break;\n\n              const updated = await getChronicle(chron.chronicleId);\n              if (\n                updated?.factCoverageReportGeneratedAt &&\n                updated.factCoverageReportGeneratedAt > prevTimestamp\n              ) {\n                result = { cost: updated.factCoverageReport?.actualCost ?? 0 };\n                break;\n              }\n            }\n\n            if (cancelledRef.current || !result) break;\n            globalCost += result.cost;\n          } catch (err) {\n            console.error(`[Fact Coverage] Chronicle \"${chron.title}\" failed:`, err);\n            failedChronicles.push({\n              chronicleId: chron.chronicleId,\n              title: chron.title,\n              error: err instanceof Error ? err.message : String(err),\n            });\n          }\n\n          globalProcessed++;\n          setProgress((p) => ({\n            ...p,\n            processedChronicles: globalProcessed,\n            totalCost: globalCost,\n            failedChronicles: [...failedChronicles],\n          }));\n        }\n\n        if (cancelledRef.current) {\n          setProgress((p) => ({ ...p, status: \"cancelled\", currentTitle: \"\" }));\n        } else {\n          setProgress((p) => ({ ...p, status: \"complete\", currentTitle: \"\" }));\n        }\n      } catch (err) {\n        console.error(\"[Fact Coverage] Fatal error:\", err);\n        setProgress((p) => ({\n          ...p,\n          status: \"failed\",\n          currentTitle: \"\",\n          error: err instanceof Error ? err.message : String(err),\n        }));\n      } finally {\n        activeRef.current = false;\n        scanRef.current = null;\n      }\n    })();\n  }, []);\n\n  // Cancel\n  const cancelFactCoverage = useCallback(() => {\n    cancelledRef.current = true;\n    scanRef.current = null;\n    setProgress((p) => {\n      if (p.status === \"confirming\") return IDLE_PROGRESS;\n      return p; // running \u2192 let the loop handle it\n    });\n  }, []);\n\n  // Close (reset from terminal state)\n  const closeFactCoverage = useCallback(() => {\n    setProgress(IDLE_PROGRESS);\n  }, []);\n\n  return {\n    progress,\n    isActive,\n    prepareFactCoverage,\n    confirmFactCoverage,\n    cancelFactCoverage,\n    closeFactCoverage,\n  };\n}", "parameters": [], "returnType": "UseFactCoverageReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 3}, {"name": "useCallback", "count": 4}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef"], "category": "framework"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}], "storeAccess": ["useIlluminatorConfigStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianActions.ts::useHistorianActions", "name": "useHistorianActions", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianActions.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianActions() {\n  const historianConfig = useIlluminatorConfigStore((s) => s.historianConfig);\n  const historianConfigured = isHistorianConfigured(historianConfig);\n  const isHistorianEditionActive = useIlluminatorConfigStore((s) => s.isHistorianEditionActive);\n  const isHistorianActive = useIlluminatorConfigStore((s) => s.isHistorianActive);\n\n  // Edition preview state (compression check before starting)\n  const [editionPreview, setEditionPreview] = useState<EditionPreview | null>(null);\n\n  const handleHistorianEdition = useCallback(\n    async (entityId: string, tone: string, reEdition?: boolean) => {\n      const config = await buildHistorianEditionContext(entityId, tone, reEdition);\n      if (!config) return;\n\n      const history = config.descriptionHistory || [];\n      if (history.length > COMPRESSION_FLOOR) {\n        const compressed = compressDescriptionHistory(history);\n        if (compressed.length < history.length) {\n          setEditionPreview({\n            config,\n            entityName: config.entityName,\n            originalCount: history.length,\n            compressed,\n          });\n          return;\n        }\n      }\n      getStarters().startHistorianEdition(config);\n    },\n    []\n  );\n\n  const handleEditionPreviewProceed = useCallback(() => {\n    if (editionPreview?.config) getStarters().startHistorianEdition(editionPreview.config);\n    setEditionPreview(null);\n  }, [editionPreview]);\n\n  const handleEditionPreviewCancel = useCallback(() => {\n    setEditionPreview(null);\n  }, []);\n\n  const handleHistorianReview = useCallback(async (entityId: string, tone: string) => {\n    const config = await buildHistorianReviewContext(entityId, tone);\n    if (config) getStarters().startHistorianReview(config);\n  }, []);\n\n  const handleUpdateHistorianNote = useCallback(\n    async (\n      targetType: string,\n      targetId: string,\n      noteId: string,\n      updates: Record<string, unknown>\n    ) => {\n      if (targetType === \"entity\" && targetId) {\n        const entity = await useEntityStore.getState().loadEntity(targetId);\n        if (!entity?.enrichment?.historianNotes) return;\n        const updatedNotes = entity.enrichment.historianNotes.map((n) =>\n          n.noteId === noteId ? { ...n, ...updates } : n\n        );\n        await entityRepo.setHistorianNotes(targetId, updatedNotes);\n        await reloadEntities([targetId]);\n      } else if (targetType === \"chronicle\" && targetId) {\n        try {\n          const chronicle = await getChronicle(targetId);\n          if (!chronicle?.historianNotes) return;\n          const updatedNotes = chronicle.historianNotes.map((n: { noteId: string }) =>\n            n.noteId === noteId ? { ...n, ...updates } : n\n          );\n          await updateChronicleHistorianNotes(targetId, updatedNotes);\n          await useChronicleStore.getState().refreshChronicle(targetId);\n        } catch (err) {\n          console.error(\"[Historian] Failed to update note:\", err);\n        }\n      }\n    },\n    []\n  );\n\n  return {\n    historianConfigured,\n    isHistorianEditionActive,\n    isHistorianActive,\n    handleHistorianEdition,\n    handleHistorianReview,\n    handleUpdateHistorianNote,\n    editionPreview,\n    handleEditionPreviewProceed,\n    handleEditionPreviewCancel,\n  };\n}", "parameters": [], "returnType": "{ historianConfigured: boolean; isHistorianEditionActive: boolean; isHistorianActive: boolean; handleHistorianEdition: (entityId: string, tone: string, reEdition?: boolean) => Promise<void>; handleHistorianReview: (entityId: string, tone: string) => Promise<void>; handleUpdateHistorianNote: (targetType: string, targetId: string, noteId: string, updates: Record<string, unknown>) => Promise<void>; editionPreview: EditionPreview; handleEditionPreviewProceed: () => void; handleEditionPreviewCancel: () => void; }", "jsxTree": null, "hookCalls": [{"name": "useIlluminatorConfigStore", "count": 3}, {"name": "useState", "count": 1}, {"name": "useCallback", "count": 5}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback"], "category": "framework"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/historianContextBuilders", "specifiers": ["buildHistorianEditionContext", "buildHistorianReviewContext"], "category": "internal"}, {"source": "../lib/descriptionHistoryCompression", "specifiers": ["compressDescriptionHistory", "COMPRESSION_FLOOR"], "category": "internal"}, {"source": "./useEntityCrud", "specifiers": ["reloadEntities"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "updateChronicleHistorianNotes"], "category": "internal"}, {"source": "./useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}], "storeAccess": ["useIlluminatorConfigStore", "useEntityStore.getState", "useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianCallbacks.js::useHistorianCallbacks", "name": "useHistorianCallbacks", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianCallbacks.js", "sourceCode": "// --- Main hook ---\n\nexport function useHistorianCallbacks({\n  projectId,\n  simulationRunId,\n  worldContext,\n  historianConfig,\n  reloadEntities,\n  entityNavMap,\n}) {\n  const {\n    run: historianEditionRun,\n    isActive: isHistorianEditionActive,\n    startHistorianEdition,\n    togglePatchDecision: toggleHistorianEditionPatchDecision,\n    applyAccepted: applyAcceptedHistorianEditionPatches,\n    cancelHistorianEdition,\n  } = useHistorianEdition();\n  const {\n    run: historianRun,\n    isActive: isHistorianActive,\n    startReview: startHistorianReview,\n    toggleNoteDecision: toggleHistorianNoteDecision,\n    applyAccepted: applyAcceptedHistorianNotes,\n    cancelReview: cancelHistorianReview,\n  } = useHistorianReview();\n\n  registerHistorianStarters({ startHistorianEdition, startHistorianReview });\n  useEffect(() => {\n    useIlluminatorConfigStore.getState().setConfig({ isHistorianEditionActive, isHistorianActive });\n  }, [isHistorianEditionActive, isHistorianActive]);\n\n  const handleAcceptHistorianEdition = useCallback(\n    () => runAcceptHistorianEdition(applyAcceptedHistorianEditionPatches, reloadEntities),\n    [applyAcceptedHistorianEditionPatches, reloadEntities]\n  );\n\n  const corpusStrengthCacheRef = useRef({ runId: null, strength: null });\n  const handleChronicleHistorianReview = useCallback(\n    (chronicleId, tone) =>\n      runChronicleHistorianReview({\n        projectId,\n        simulationRunId,\n        chronicleId,\n        tone,\n        worldContext,\n        historianConfig,\n        corpusStrengthCacheRef,\n        startHistorianReview,\n      }),\n    [projectId, simulationRunId, worldContext, historianConfig, startHistorianReview]\n  );\n\n  const {\n    bulkHistorianProgress,\n    isBulkHistorianActive,\n    showBulkHistorianModal,\n    editionMaxTokens,\n    setBulkHistorianTone,\n    handleStartBulkHistorianReview,\n    handleStartBulkHistorianEdition,\n    handleStartBulkHistorianClear,\n    handleConfirmBulkHistorian,\n    handleCancelBulkHistorian,\n    handleCloseBulkHistorian,\n  } = useBulkHistorianSetup({\n    applyReviewNotesForEntity,\n    applyEditionPatchesForEntity,\n    reloadEntities,\n    entityNavMap,\n  });\n\n  const handleAcceptHistorianNotes = useCallback(\n    () => runAcceptHistorianNotes(historianRun, applyAcceptedHistorianNotes, reloadEntities),\n    [applyAcceptedHistorianNotes, historianRun, reloadEntities]\n  );\n  const handleUpdateHistorianNote = useCallback(\n    (targetType, targetId, noteId, updates) =>\n      runUpdateHistorianNote(targetType, targetId, noteId, updates, reloadEntities),\n    [reloadEntities]\n  );\n  const handleEditHistorianNoteText = useCallback(\n    (noteId, newText) => runEditHistorianNoteText(historianRun, noteId, newText),\n    [historianRun]\n  );\n\n  return {\n    historianEditionRun,\n    isHistorianEditionActive,\n    startHistorianEdition,\n    toggleHistorianEditionPatchDecision,\n    handleAcceptHistorianEdition,\n    cancelHistorianEdition,\n    historianRun,\n    isHistorianActive,\n    startHistorianReview,\n    toggleHistorianNoteDecision,\n    cancelHistorianReview,\n    handleAcceptHistorianNotes,\n    handleUpdateHistorianNote,\n    handleEditHistorianNoteText,\n    handleChronicleHistorianReview,\n    bulkHistorianProgress,\n    isBulkHistorianActive,\n    showBulkHistorianModal,\n    editionMaxTokens,\n    setBulkHistorianTone,\n    handleStartBulkHistorianReview,\n    handleStartBulkHistorianEdition,\n    handleStartBulkHistorianClear,\n    handleConfirmBulkHistorian,\n    handleCancelBulkHistorian,\n    handleCloseBulkHistorian,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  worldContext,\n  historianConfig,\n  reloadEntities,\n  entityNavMap,\n}", "type": "{ projectId: any; simulationRunId: any; worldContext: any; historianConfig: any; reloadEntities: any; entityNavMap: any; }", "optional": false}], "returnType": "{ historianEditionRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isHistorianEditionActive: boolean; startHistorianEdition: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useHistorianEdition\").HistorianEditionConfig) => Promise<void>; toggleHistorianEditionPatchDecision: (entityId: string, accepted: boolean) => Promise<void>; handleAcceptHistorianEdition: () => Promise<void>; cancelHistorianEdition: () => void; historianRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/historianTypes\").HistorianRun; isHistorianActive: boolean; startHistorianReview: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useHistorianReview\").HistorianReviewConfig) => Promise<void>; toggleHistorianNoteDecision: (noteId: string, accepted: boolean) => Promise<void>; cancelHistorianReview: () => void; handleAcceptHistorianNotes: () => Promise<void>; handleUpdateHistorianNote: (targetType: any, targetId: any, noteId: any, updates: any) => Promise<void>; handleEditHistorianNoteText: (noteId: any, newText: any) => void; handleChronicleHistorianReview: (chronicleId: any, tone: any) => Promise<void>; bulkHistorianProgress: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useBulkHistorian\").BulkHistorianProgress; isBulkHistorianActive: boolean; showBulkHistorianModal: boolean; editionMaxTokens: number; setBulkHistorianTone: (tone: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/historianTypes\").HistorianTone) => void; handleStartBulkHistorianReview: (eligibleEntityIds: any) => void; handleStartBulkHistorianEdition: (eligibleEntityIds: any, reEdition: any) => void; handleStartBulkHistorianClear: (eligibleEntityIds: any) => void; handleConfirmBulkHistorian: () => void; handleCancelBulkHistorian: () => void; handleCloseBulkHistorian: () => void; }", "jsxTree": null, "hookCalls": [{"name": "useHistorianEdition", "count": 1}, {"name": "useHistorianReview", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 5}, {"name": "useRef", "count": 1}, {"name": "useBulkHistorianSetup", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "./useHistorianEdition", "specifiers": ["useHistorianEdition"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["useHistorianReview"], "category": "internal"}, {"source": "./useBulkHistorian", "specifiers": ["useBulkHistorian"], "category": "internal"}, {"source": "./useHistorianActions", "specifiers": ["registerHistorianStarters"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getCallConfig as getLLMCallConfig"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "updateChronicleHistorianNotes", "computeCorpusFactStrength"], "category": "internal"}, {"source": "../lib/db/historianRunHelpers", "specifiers": ["extractReinforcedFactIds"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/historianContextBuilders", "specifiers": ["buildHistorianEditionContext", "buildHistorianReviewContext", "collectPreviousNotes", "buildFactCoverageGuidance"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["updateHistorianRun as updateHistorianRunRecord"], "category": "internal"}], "storeAccess": ["useChronicleStore.getState", "useEntityStore.getState", "useIlluminatorConfigStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianChronology.ts::useHistorianChronology", "name": "useHistorianChronology", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianChronology.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianChronology(\n  onEnqueue: (\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void\n): UseHistorianChronologyReturn {\n  const [run, setRun] = useState<HistorianRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback(\n    (runId: string) => {\n      const sentinelEntity = {\n        id: \"__historian_chronology__\",\n        name: \"Historian Chronology\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      onEnqueue([\n        {\n          entity: sentinelEntity,\n          type: \"historianChronology\" as EnrichmentType,\n          prompt: \"\", // All data is in IndexedDB run context\n          chronicleId: runId, // Repurpose chronicleId field for runId\n        },\n      ]);\n    },\n    [onEnqueue]\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getHistorianRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new chronology session\n  const startChronology = useCallback(\n    async (config: ChronologyConfig) => {\n      const runId = generateHistorianRunId();\n      const now = Date.now();\n\n      const newRun: HistorianRun = {\n        runId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        status: \"pending\",\n        tone: config.tone,\n        targetType: \"chronology\",\n        targetId: config.eraId,\n        targetName: config.eraName,\n        sourceText: \"\", // Not used for chronology\n        notes: [],\n        noteDecisions: {},\n        contextJson: config.contextJson,\n        previousNotesJson: \"[]\",\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        inputTokens: 0,\n        outputTokens: 0,\n        actualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await createHistorianRun(newRun);\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Adjust a year for a specific chronicle before applying\n  const adjustYear = useCallback(\n    async (chronicleId: string, year: number) => {\n      if (!run?.chronologyAssignments) return;\n\n      const updated = run.chronologyAssignments.map((a) =>\n        a.chronicleId === chronicleId ? { ...a, year } : a\n      );\n\n      await updateHistorianRun(run.runId, { chronologyAssignments: updated });\n      setRun((prev) => (prev ? { ...prev, chronologyAssignments: updated } : null));\n    },\n    [run]\n  );\n\n  // Apply all assignments and return them\n  const applyChronology = useCallback((): ChronologyAssignment[] => {\n    if (!run?.chronologyAssignments) return [];\n\n    const assignments = [...run.chronologyAssignments];\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return assignments;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelChronology = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startChronology,\n    adjustYear,\n    applyChronology,\n    cancelChronology,\n  };\n}", "parameters": [{"name": "onEnqueue", "type": "(\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void", "optional": false}], "returnType": "UseHistorianChronologyReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianRun", "HistorianConfig", "HistorianTone", "ChronologyAssignment"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "getHistorianRun", "updateHistorianRun", "deleteHistorianRun", "generateHistorianRunId"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useHistorianEdition.ts::useHistorianEdition", "name": "useHistorianEdition", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianEdition.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianEdition(): UseHistorianEditionReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for the single entity\n  const dispatchTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__historian_edition__\",\n      name: \"Historian Edition\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"historianEdition\" as EnrichmentType,\n        prompt: \"\", // All data is in IndexedDB run context\n        chronicleId: runId, // Repurpose chronicleId field for runId\n      },\n    ]);\n  }, []);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new historian edition session\n  const startHistorianEdition = useCallback(\n    async (cfg: HistorianEditionConfig) => {\n      const runId = generateRevisionRunId();\n\n      // Single batch with one entity ID\n      const batches = [\n        {\n          culture: \"historian-edition\",\n          entityIds: [cfg.entityId],\n          status: \"pending\" as const,\n          patches: [],\n        },\n      ];\n\n      // Pack all context into staticPagesContext as JSON\n      const contextJson = JSON.stringify({\n        entityId: cfg.entityId,\n        entityName: cfg.entityName,\n        entityKind: cfg.entityKind,\n        entitySubtype: cfg.entitySubtype,\n        entityCulture: cfg.entityCulture,\n        entityProminence: cfg.entityProminence,\n        summary: cfg.summary,\n        descriptionHistory: cfg.descriptionHistory,\n        chronicleSummaries: cfg.chronicleSummaries,\n        relationships: cfg.relationships,\n        neighborSummaries: cfg.neighborSummaries,\n        canonFacts: cfg.canonFacts,\n        worldDynamics: cfg.worldDynamics,\n        previousNotes: cfg.previousNotes,\n        historianConfig: cfg.historianConfig,\n        tone: cfg.tone,\n      });\n\n      // Create run in IndexedDB\n      // worldDynamicsContext = current description, staticPagesContext = everything else\n      const newRun = await createRevisionRun(runId, cfg.projectId, cfg.simulationRunId, batches, {\n        worldDynamicsContext: cfg.description,\n        staticPagesContext: contextJson,\n        schemaContext: \"\",\n        revisionGuidance: \"\",\n      });\n\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Toggle accept/reject for the entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply the accepted patch and return it\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect patches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelHistorianEdition = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startHistorianEdition,\n    togglePatchDecision,\n    applyAccepted,\n    cancelHistorianEdition,\n  };\n}", "parameters": [], "returnType": "UseHistorianEditionReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianConfig", "HistorianTone"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionPatch"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useHistorianReview.ts::useHistorianReview", "name": "useHistorianReview", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianReview.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianReview(): UseHistorianReviewReturn {\n  const [run, setRun] = useState<HistorianRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__historian_review__\",\n      name: \"Historian Review\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"historianReview\" as EnrichmentType,\n        prompt: \"\", // All data is in IndexedDB run context\n        chronicleId: runId, // Repurpose chronicleId field for runId\n      },\n    ]);\n  }, []);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getHistorianRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new historian review session\n  const startReview = useCallback(\n    async (config: HistorianReviewConfig) => {\n      const runId = generateHistorianRunId();\n      const now = Date.now();\n\n      const newRun: HistorianRun = {\n        runId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        status: \"pending\",\n        tone: config.tone,\n        targetType: config.targetType,\n        targetId: config.targetId,\n        targetName: config.targetName,\n        sourceText: config.sourceText,\n        notes: [],\n        noteDecisions: {},\n        contextJson: config.contextJson,\n        previousNotesJson: config.previousNotesJson,\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        inputTokens: 0,\n        outputTokens: 0,\n        actualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await createHistorianRun(newRun);\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Toggle accept/reject for a note\n  const toggleNoteDecision = useCallback(\n    async (noteId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.noteDecisions, [noteId]: accepted };\n      await updateHistorianRun(run.runId, { noteDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, noteDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply accepted notes and return them\n  const applyAccepted = useCallback((): HistorianNote[] => {\n    if (!run) return [];\n\n    // Collect notes where accepted (default to accepted if no explicit decision)\n    const acceptedNotes: HistorianNote[] = run.notes.filter(\n      (note) => run.noteDecisions[note.noteId] !== false\n    );\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedNotes;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelReview = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startReview,\n    toggleNoteDecision,\n    applyAccepted,\n    cancelReview,\n  };\n}", "parameters": [], "returnType": "UseHistorianReviewReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianRun", "HistorianNote", "HistorianConfig", "HistorianTargetType", "HistorianTone"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "getHistorianRun", "updateHistorianRun", "deleteHistorianRun", "generateHistorianRunId"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useIlluminatorSetup.js::useIlluminatorSetup", "name": "useIlluminatorSetup", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useIlluminatorSetup.js", "sourceCode": "// --- Main hook ---\n\nexport function useIlluminatorSetup({\n  projectId,\n  worldData,\n  schema,\n  onStyleSelectionChange,\n  config,\n  apiKeys,\n  slotRecord,\n  currentEra,\n  simulationRunId,\n  handleEntityUpdate,\n  reloadEntities,\n  reloadEntitiesAndEvents,\n  worldContext,\n  historianConfig,\n  entityGuidance,\n  cultureIdentities,\n  navEntities,\n  setChronicleRefreshTrigger,\n}) {\n  // Style library\n  const styleLib = useStyleLibrary();\n\n  // Image gen settings\n  const [imageGenSettings, updateImageGenSettings] = useImageGenSettings(\n    onStyleSelectionChange\n      ? (s) =>\n          onStyleSelectionChange({\n            artisticStyleId: s.artisticStyleId,\n            compositionStyleId: s.compositionStyleId,\n            colorPaletteId: s.colorPaletteId,\n          })\n      : undefined\n  );\n  const styleSelection = useMemo(\n    () => ({\n      artisticStyleId: imageGenSettings.artisticStyleId,\n      compositionStyleId: imageGenSettings.compositionStyleId,\n      colorPaletteId: imageGenSettings.colorPaletteId,\n    }),\n    [\n      imageGenSettings.artisticStyleId,\n      imageGenSettings.compositionStyleId,\n      imageGenSettings.colorPaletteId,\n    ]\n  );\n\n  // World schema + simulation metadata\n  const worldSchema = useMemo(() => computeWorldSchema(worldData, schema), [worldData, schema]);\n  const simulationMetadata = useMemo(\n    () => computeSimulationMetadata(slotRecord, currentEra),\n    [slotRecord, currentEra]\n  );\n\n  // Derived state\n  const hasHardState = Boolean(worldData?.hardState?.length);\n  const hardStateSummary = useMemo(() => computeHardStateSummary(worldData), [worldData]);\n  const canImport = hasHardState;\n  const hasWorldData = navEntities.length > 0;\n  const isTemporarySlot = slotRecord?.isTemporary ?? false;\n\n  // Subtypes\n  const subtypesByKind = useMemo(() => computeSubtypesByKind(worldSchema), [worldSchema]);\n\n  // Era entities (wrapped in async IIFE to satisfy set-state-in-effect rule)\n  const [eraEntities, setEraEntities] = useState([]);\n  useEffect(() => {\n    (async () => {\n      const eraNavs = navEntities.filter((e) => e.kind === \"era\");\n      if (eraNavs.length === 0) {\n        setEraEntities([]);\n        return;\n      }\n      const full = await useEntityStore.getState().loadEntities(eraNavs.map((e) => e.id));\n      setEraEntities(full.map((e) => ({ id: e.id, name: e.name, description: e.description })));\n    })();\n  }, [navEntities]);\n\n  // Queue\n  const {\n    queue,\n    isWorkerReady,\n    stats,\n    initialize: initializeWorker,\n    enqueue,\n    cancel,\n    cancelAll,\n    retry,\n    clearCompleted,\n  } = useEnrichmentQueue(handleEntityUpdate, projectId, simulationRunId);\n  registerQueue(enqueue, cancel);\n  useEffect(() => {\n    useEnrichmentQueueStore.getState().setQueue(queue, stats);\n  }, [queue, stats]);\n  useChronicleQueueWatcher(queue);\n  useEffect(() => {\n    if (apiKeys.anthropicApiKey || apiKeys.openaiApiKey)\n      initializeWorker(buildWorkerConfig(apiKeys, config, imageGenSettings));\n  }, [apiKeys, config, imageGenSettings, initializeWorker]);\n\n  // Config store sync\n  useEffect(() => {\n    useIlluminatorConfigStore.getState().setConfig({\n      projectId: projectId || null,\n      simulationRunId: simulationRunId || null,\n      worldContext,\n      historianConfig,\n      entityGuidance,\n      cultureIdentities,\n    });\n  }, [\n    projectId,\n    simulationRunId,\n    worldContext,\n    historianConfig,\n    entityGuidance,\n    cultureIdentities,\n  ]);\n\n  // Entity CRUD\n  const editEntityModal = useIlluminatorModals((s) => s.editEntityModal);\n  const handleRenameApplied = useCallback(\n    (args) =>\n      handleRenameApply(args, simulationRunId, reloadEntitiesAndEvents, setChronicleRefreshTrigger),\n    [simulationRunId, reloadEntitiesAndEvents, setChronicleRefreshTrigger]\n  );\n  const handleCreateEntity = useCallback(\n    (entityData) => handleCreateApply(entityData, simulationRunId, reloadEntities),\n    [simulationRunId, reloadEntities]\n  );\n  const handleEditEntity = useCallback(\n    (entityData) => handleEditApply(entityData, editEntityModal, reloadEntities),\n    [editEntityModal, reloadEntities]\n  );\n\n  return {\n    ...styleLib,\n    imageGenSettings,\n    updateImageGenSettings,\n    styleSelection,\n    worldSchema,\n    simulationMetadata,\n    hasHardState,\n    hardStateSummary,\n    canImport,\n    hasWorldData,\n    isTemporarySlot,\n    subtypesByKind,\n    eraEntities,\n    queue,\n    isWorkerReady,\n    stats,\n    enqueue,\n    cancel,\n    cancelAll,\n    retry,\n    clearCompleted,\n    handleRenameApplied,\n    handleCreateEntity,\n    handleEditEntity,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  worldData,\n  schema,\n  onStyleSelectionChange,\n  config,\n  apiKeys,\n  slotRecord,\n  currentEra,\n  simulationRunId,\n  handleEntityUpdate,\n  reloadEntities,\n  reloadEntitiesAndEvents,\n  worldContext,\n  historianConfig,\n  entityGuidance,\n  cultureIdentities,\n  navEntities,\n  setChronicleRefreshTrigger,\n}", "type": "{ projectId: any; worldData: any; schema: any; onStyleSelectionChange: any; config: any; apiKeys: any; slotRecord: any; currentEra: any; simulationRunId: any; handleEntityUpdate: any; reloadEntities: any; reloadEntitiesAndEvents: any; worldContext: any; historianConfig: any; entityGuidance: any; cultureIdentities: any; navEntities: any; setChronicleRefreshTrigger: any; }", "optional": false}], "returnType": "{ imageGenSettings: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useImageGenSettings\").ImageGenSettings; updateImageGenSettings: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useImageGenSettings\").ImageGenSettingsUpdater; styleSelection: { artisticStyleId: string; compositionStyleId: string; colorPaletteId: string; }; worldSchema: any; simulationMetadata: { currentTick: any; currentEra: any; }; hasHardState: boolean; hardStateSummary: string; canImport: boolean; hasWorldData: boolean; isTemporarySlot: any; subtypesByKind: {}; eraEntities: any[]; queue: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/enrichmentTypes\").QueueItem[]; isWorkerReady: boolean; stats: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useEnrichmentQueue\").QueueStats; enqueue: (items: (Omit<import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/enrichmentTypes\").EnrichmentTaskPayload, \"id\" | \"simulationRunId\" | \"entityName\" | \"entityKind\" | \"entityCulture\" | \"entityId\" | \"entitySubtype\"> & { entity: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useEnrichmentQueue\").EnrichedEntity; })[]) => void; cancel: (itemId: string) => void; cancelAll: () => void; retry: (itemId: string) => void; clearCompleted: () => void; handleRenameApplied: (args: any) => Promise<void>; handleCreateEntity: (entityData: any) => Promise<void>; handleEditEntity: (entityData: any) => Promise<void>; styleLibrary: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").StyleLibrary; loading: boolean; isCustom: boolean; save: (library: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").StyleLibrary) => Promise<void>; reset: () => Promise<void>; addArtisticStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/artisticStyles\").ArtisticStyle) => Promise<void>; updateArtisticStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/artisticStyles\").ArtisticStyle>) => Promise<void>; deleteArtisticStyle: (id: string) => Promise<void>; addCompositionStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/compositionStyles\").CompositionStyle) => Promise<void>; updateCompositionStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/compositionStyles\").CompositionStyle>) => Promise<void>; deleteCompositionStyle: (id: string) => Promise<void>; addNarrativeStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").NarrativeStyle) => Promise<void>; updateNarrativeStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").NarrativeStyle>) => Promise<void>; deleteNarrativeStyle: (id: string) => Promise<void>; }", "jsxTree": null, "hookCalls": [{"name": "useStyleLibrary", "count": 1}, {"name": "useImageGenSettings", "count": 1}, {"name": "useMemo", "count": 5}, {"name": "useState", "count": 1}, {"name": "useEffect", "count": 4}, {"name": "useEnrichmentQueue", "count": 1}, {"name": "useChronicleQueueWatcher", "count": 1}, {"name": "useIlluminatorModals", "count": 1}, {"name": "useCallback", "count": 3}], "imports": [{"source": "react", "specifiers": ["useState", "useMemo", "useEffect", "useCallback"], "category": "framework"}, {"source": "./useStyleLibrary", "specifiers": ["useStyleLibrary"], "category": "internal"}, {"source": "./useImageGenSettings", "specifiers": ["useImageGenSettings"], "category": "internal"}, {"source": "./useEnrichmentQueue", "specifiers": ["useEnrichmentQueue"], "category": "internal"}, {"source": "./useChronicleQueueWatcher", "specifiers": ["useChronicleQueueWatcher"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["registerQueue"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getResolvedLLMCallSettings"], "category": "internal"}, {"source": "../lib/db/indexComputation", "specifiers": ["computeRunIndexes"], "category": "internal"}, {"source": "../lib/db/indexRepository", "specifiers": ["upsertRunIndexes"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/eventRepository", "specifiers": ["* as eventRepo"], "category": "internal"}], "storeAccess": ["useIndexStore.getState", "useEntityStore.getState", "useEnrichmentQueueStore.getState", "useIlluminatorConfigStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useImageGenSettings.ts::useImageGenSettings", "name": "useImageGenSettings", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useImageGenSettings.ts", "sourceCode": "/**\n * Hook providing global image generation settings backed by localStorage.\n *\n * Optional external sync: if onExternalSync is provided, changes are\n * also forwarded there (for syncing with parent shell).\n */\nexport function useImageGenSettings(\n  onExternalSync?: (settings: ImageGenSettings) => void\n): [ImageGenSettings, ImageGenSettingsUpdater] {\n  const [settings, setSettings] = useState<ImageGenSettings>(loadSettings);\n  const externalSyncRef = useRef(onExternalSync);\n  useEffect(() => {\n    externalSyncRef.current = onExternalSync;\n  }, [onExternalSync]);\n\n  const updateSettings = useCallback((partial: Partial<ImageGenSettings>) => {\n    setSettings((prev) => ({ ...prev, ...partial }));\n  }, []);\n\n  // Defer localStorage write and external sync to after render\n  const isInitialMount = useRef(true);\n  useEffect(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false;\n      return;\n    }\n    saveSettings(settings);\n    if (externalSyncRef.current) {\n      externalSyncRef.current(settings);\n    }\n  }, [settings]);\n\n  return [settings, updateSettings];\n}", "parameters": [{"name": "onExternalSync", "type": "(settings: ImageGenSettings) => void", "optional": true}], "returnType": "[ImageGenSettings, ImageGenSettingsUpdater]", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/usePromptBuilder.js::usePromptBuilder", "name": "usePromptBuilder", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/usePromptBuilder.js", "sourceCode": "// --- Main hook ---\n\nexport function usePromptBuilder({\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  relationshipsByEntity,\n  entityNavMap,\n  currentEra,\n  narrativeEvents,\n  prominentByCulture,\n  styleSelection,\n  worldSchema,\n  config,\n  prominenceScale,\n  styleLibrary,\n  eraTemporalInfo,\n  eraTemporalInfoByKey,\n}) {\n  // Get visual config for an entity (thesis/traits prompts, avoid elements, era)\n  const getVisualConfig = useCallback(\n    (entity) => {\n      const visualConfig = getVisualConfigFromGuidance(entityGuidance, entity.kind);\n\n      const entityEraId = resolveEntityEraId(entity);\n      const entityFocalEra = entityEraId ? eraTemporalInfoByKey.get(entityEraId) : undefined;\n      const entityAllEras = eraTemporalInfo.length > 0 ? eraTemporalInfo : undefined;\n\n      return {\n        ...visualConfig,\n        entityEraId,\n        entityFocalEra,\n        entityAllEras,\n      };\n    },\n    [entityGuidance, eraTemporalInfo, eraTemporalInfoByKey]\n  );\n\n  // Build prompt for entity using EntityGuidance and CultureIdentities directly\n  const buildPrompt = useCallback(\n    (entity, type) => {\n      const params = {\n        entityGuidance,\n        cultureIdentities,\n        worldContext,\n        relationshipsByEntity,\n        entityNavMap,\n        prominenceScale,\n        currentEra,\n        narrativeEvents,\n        prominentByCulture,\n        styleSelection,\n        worldSchema,\n        styleLibrary,\n        config,\n      };\n\n      if (type === \"description\") {\n        return buildEntityDescriptionPrompt(entity, params);\n      }\n      if (type === \"image\") {\n        return buildEntityImagePrompt(entity, params);\n      }\n      return `Describe ${entity.name}, a ${entity.subtype} ${entity.kind}.`;\n    },\n    [\n      worldContext,\n      entityGuidance,\n      cultureIdentities,\n      relationshipsByEntity,\n      entityNavMap,\n      currentEra,\n      narrativeEvents,\n      prominentByCulture,\n      styleSelection,\n      worldSchema,\n      styleLibrary,\n      config,\n      prominenceScale,\n    ]\n  );\n\n  return { buildPrompt, getVisualConfig };\n}", "parameters": [{"name": "{\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  relationshipsByEntity,\n  entityNavMap,\n  currentEra,\n  narrativeEvents,\n  prominentByCulture,\n  styleSelection,\n  worldSchema,\n  config,\n  prominenceScale,\n  styleLibrary,\n  eraTemporalInfo,\n  eraTemporalInfoByKey,\n}", "type": "{ entityGuidance: any; cultureIdentities: any; worldContext: any; relationshipsByEntity: any; entityNavMap: any; currentEra: any; narrativeEvents: any; prominentByCulture: any; styleSelection: any; worldSchema: any; config: any; prominenceScale: any; styleLibrary: any; eraTemporalInfo: any; eraTemporalInfoByKey: any; }", "optional": false}], "returnType": "{ buildPrompt: (entity: any, type: any) => string; getVisualConfig: (entity: any) => { entityEraId: any; entityFocalEra: any; entityAllEras: any; visualAvoid: string; visualThesisInstructions: string; visualThesisFraming: string; visualTraitsInstructions: string; visualTraitsFraming: string; }; }", "jsxTree": null, "hookCalls": [{"name": "useCallback", "count": 2}], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/promptBuilders", "specifiers": ["buildDescriptionPromptFromGuidance", "buildImagePromptFromGuidance", "getVisualConfigFromGuidance"], "category": "internal"}, {"source": "../components/StyleSelector", "specifiers": ["resolveStyleSelection"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "getEntityEvents", "getEntityEffects"], "category": "external"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useRevisionFlow.js::useRevisionFlow", "name": "useRevisionFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useRevisionFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useRevisionFlow({\n  projectId,\n  simulationRunId,\n  navEntities,\n  entityNavMap,\n  relationshipsByEntity,\n  prominenceScale,\n  worldContext,\n  worldSchema,\n  entityGuidance,\n  reloadEntities,\n}) {\n  const getEntityContextsForRevision = useCallback(\n    async (entityIds) => {\n      const fullEntities = await useEntityStore.getState().loadEntities(entityIds);\n      const params = { relationshipsByEntity, entityNavMap, prominenceScale, entityGuidance };\n      return fullEntities.map((entity) => mapEntityToRevisionContext(entity, params));\n    },\n    [entityNavMap, relationshipsByEntity, prominenceScale, entityGuidance]\n  );\n\n  const handleRevisionApplied = useCallback(\n    async (patches, source = \"summary-revision\") => {\n      if (!patches?.length) return;\n      const updatedIds = await entityRepo.applyRevisionPatches(patches, source);\n      await reloadEntities(updatedIds);\n    },\n    [reloadEntities]\n  );\n\n  const {\n    run: revisionRun,\n    isActive: isRevisionActive,\n    startRevision,\n    continueToNextBatch,\n    autoContineAll: autoContineAllRevision,\n    togglePatchDecision,\n    applyAccepted: applyAcceptedPatches,\n    cancelRevision,\n  } = useSummaryRevision(getEntityContextsForRevision);\n\n  const [revisionFilter, setRevisionFilter] = useState({\n    open: false,\n    totalEligible: 0,\n    usedInChronicles: 0,\n    chronicleEntityIds: new Set(),\n  });\n\n  const handleOpenRevisionFilter = useCallback(async () => {\n    if (!projectId || !simulationRunId) return;\n    const eligible = navEntities.filter((e) => e.hasDescription && !e.lockedSummary);\n    let chronicleEntityIds = new Set();\n    try {\n      const usageStats = await getEntityUsageStats(simulationRunId);\n      chronicleEntityIds = new Set(usageStats.keys());\n    } catch (err) {\n      console.warn(\"[Revision] Failed to load chronicle usage stats:\", err);\n    }\n    const usedInChronicles = eligible.filter((e) => chronicleEntityIds.has(e.id)).length;\n    setRevisionFilter({\n      open: true,\n      totalEligible: eligible.length,\n      usedInChronicles,\n      chronicleEntityIds,\n    });\n  }, [projectId, simulationRunId, navEntities]);\n\n  const handleStartRevision = useCallback(\n    async (excludeChronicleEntities) => {\n      if (!projectId || !simulationRunId) return;\n      setRevisionFilter((prev) => ({ ...prev, open: false }));\n      await buildRevisionStartPayload({\n        projectId,\n        simulationRunId,\n        worldContext,\n        worldSchema,\n        navEntities,\n        entityNavMap,\n        relationshipsByEntity,\n        prominenceScale,\n        excludeChronicleEntities,\n        chronicleEntityIds: revisionFilter.chronicleEntityIds,\n        startRevision,\n      });\n    },\n    [\n      projectId,\n      simulationRunId,\n      worldContext,\n      worldSchema,\n      navEntities,\n      entityNavMap,\n      relationshipsByEntity,\n      prominenceScale,\n      startRevision,\n      revisionFilter.chronicleEntityIds,\n    ]\n  );\n\n  const handleAcceptRevision = useCallback(() => {\n    handleRevisionApplied(applyAcceptedPatches());\n  }, [applyAcceptedPatches, handleRevisionApplied]);\n\n  return {\n    revisionRun,\n    isRevisionActive,\n    revisionFilter,\n    setRevisionFilter,\n    getEntityContextsForRevision,\n    handleOpenRevisionFilter,\n    handleStartRevision,\n    handleAcceptRevision,\n    continueToNextBatch,\n    autoContineAllRevision,\n    togglePatchDecision,\n    cancelRevision,\n    startRevision,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  navEntities,\n  entityNavMap,\n  relationshipsByEntity,\n  prominenceScale,\n  worldContext,\n  worldSchema,\n  entityGuidance,\n  reloadEntities,\n}", "type": "{ projectId: any; simulationRunId: any; navEntities: any; entityNavMap: any; relationshipsByEntity: any; prominenceScale: any; worldContext: any; worldSchema: any; entityGuidance: any; reloadEntities: any; }", "optional": false}], "returnType": "{ revisionRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isRevisionActive: boolean; revisionFilter: { open: boolean; totalEligible: number; usedInChronicles: number; chronicleEntityIds: Set<any>; }; setRevisionFilter: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<{ open: boolean; totalEligible: number; usedInChronicles: number; chronicleEntityIds: Set<any>; }>>; getEntityContextsForRevision: (entityIds: any) => Promise<{ existingAnchorPhrases: any; kindFocus: any; prominence: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").ProminenceLabel; relationships: any; aliases: any; subtype: any; culture: any; status: any; summary: any; description: any; visualThesis: any; id: any; name: any; kind: any; }[]>; handleOpenRevisionFilter: () => Promise<void>; handleStartRevision: (excludeChronicleEntities: any) => Promise<void>; handleAcceptRevision: () => void; continueToNextBatch: () => Promise<void>; autoContineAllRevision: () => Promise<void>; togglePatchDecision: (entityId: string, accepted: boolean) => Promise<void>; cancelRevision: () => void; startRevision: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useSummaryRevision\").SummaryRevisionConfig) => Promise<void>; }", "jsxTree": null, "hookCalls": [{"name": "useCallback", "count": 5}, {"name": "useSummaryRevision", "count": 1}, {"name": "useState", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback"], "category": "framework"}, {"source": "./useSummaryRevision", "specifiers": ["useSummaryRevision"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getEntityUsageStats"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getPublishedStaticPagesForProject"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale"], "category": "external"}], "storeAccess": ["useEntityStore.getState"]}, {"id": "apps/illuminator/webui/src/hooks/useStyleLibrary.ts::useStyleLibrary", "name": "useStyleLibrary", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useStyleLibrary.ts", "sourceCode": "export function useStyleLibrary(): UseStyleLibraryReturn {\n  const [styleLibrary, setStyleLibrary] = useState<StyleLibrary>(() => createDefaultStyleLibrary());\n  const [loading, setLoading] = useState(true);\n  const [isCustom, setIsCustom] = useState(false);\n\n  // Load style library on mount\n  useEffect(() => {\n    async function load() {\n      try {\n        const stored = await loadStyleLibrary();\n        if (stored) {\n          setStyleLibrary(stored);\n          setIsCustom(true);\n        } else {\n          setStyleLibrary(createDefaultStyleLibrary());\n          setIsCustom(false);\n        }\n      } catch (err) {\n        console.error(\"[useStyleLibrary] Failed to load:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n    void load();\n  }, []);\n\n  // Save entire library\n  const save = useCallback(async (library: StyleLibrary) => {\n    await saveStyleLibrary(library);\n    setStyleLibrary(library);\n    setIsCustom(true);\n  }, []);\n\n  // Reset to defaults\n  const reset = useCallback(async () => {\n    await resetStyleLibrary();\n    setStyleLibrary(createDefaultStyleLibrary());\n    setIsCustom(false);\n  }, []);\n\n  // Add artistic style\n  const addArtisticStyle = useCallback(\n    async (style: ArtisticStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: [...styleLibrary.artisticStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update artistic style\n  const updateArtisticStyle = useCallback(\n    async (id: string, updates: Partial<ArtisticStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: styleLibrary.artisticStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete artistic style\n  const deleteArtisticStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: styleLibrary.artisticStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Add composition style\n  const addCompositionStyle = useCallback(\n    async (style: CompositionStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: [...styleLibrary.compositionStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update composition style\n  const updateCompositionStyle = useCallback(\n    async (id: string, updates: Partial<CompositionStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: styleLibrary.compositionStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete composition style\n  const deleteCompositionStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: styleLibrary.compositionStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Add narrative style\n  const addNarrativeStyle = useCallback(\n    async (style: NarrativeStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: [...styleLibrary.narrativeStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update narrative style\n  const updateNarrativeStyle = useCallback(\n    async (id: string, updates: Partial<NarrativeStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: styleLibrary.narrativeStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete narrative style\n  const deleteNarrativeStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: styleLibrary.narrativeStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  return {\n    styleLibrary,\n    loading,\n    isCustom,\n    save,\n    reset,\n    addArtisticStyle,\n    updateArtisticStyle,\n    deleteArtisticStyle,\n    addCompositionStyle,\n    updateCompositionStyle,\n    deleteCompositionStyle,\n    addNarrativeStyle,\n    updateNarrativeStyle,\n    deleteNarrativeStyle,\n  };\n}", "parameters": [], "returnType": "UseStyleLibraryReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 3}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 11}], "imports": [{"source": "react", "specifiers": ["useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle", "NarrativeStyle"], "category": "external"}, {"source": "../lib/db/styleRepository", "specifiers": ["loadStyleLibrary", "saveStyleLibrary", "resetStyleLibrary"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useSummaryRevision.ts::useSummaryRevision", "name": "useSummaryRevision", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useSummaryRevision.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useSummaryRevision(\n  /** Callback to get entity context by IDs (called when dispatching a batch) */\n  getEntityContexts: (entityIds: string[]) => RevisionEntityContext[]\n): UseSummaryRevisionReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const autoModeRef = useRef(false);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for one batch\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__summary_revision__\",\n        name: \"Summary Revision\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"summaryRevision\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n\n            // In auto mode, continue to next batch if batch_reviewing\n            if (autoModeRef.current && updated.status === \"batch_reviewing\") {\n              const nextIndex = updated.currentBatchIndex + 1;\n              if (nextIndex < updated.batches.length) {\n                // Dispatch next batch\n                const nextBatch = updated.batches[nextIndex];\n                const contexts = getEntityContexts(nextBatch.entityIds);\n                await updateRevisionRun(runId, { currentBatchIndex: nextIndex });\n                dispatchBatch(runId, contexts);\n                startPolling(runId);\n              }\n            }\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling, dispatchBatch, getEntityContexts]\n  );\n\n  // Start a new revision session\n  const startRevision = useCallback(\n    async (config: SummaryRevisionConfig) => {\n      const runId = generateRevisionRunId();\n      autoModeRef.current = false;\n\n      // Filter out locked-summary entities\n      const eligibleEntities = config.entities;\n\n      // Group into batches\n      const batches = groupEntitiesIntoBatches(eligibleEntities);\n\n      if (batches.length === 0) {\n        return;\n      }\n\n      // Create run in IndexedDB\n      const newRun = await createRevisionRun(\n        runId,\n        config.projectId,\n        config.simulationRunId,\n        batches,\n        {\n          worldDynamicsContext: config.worldDynamicsContext,\n          staticPagesContext: config.staticPagesContext,\n          schemaContext: config.schemaContext,\n          revisionGuidance: config.revisionGuidance,\n        }\n      );\n\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch first batch\n      const firstBatch = batches[0];\n      const firstContexts = getEntityContexts(firstBatch.entityIds);\n      dispatchBatch(runId, firstContexts);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchBatch, startPolling, getEntityContexts]\n  );\n\n  // Continue to next batch after reviewing current one\n  const continueToNextBatch = useCallback(async () => {\n    if (!run) return;\n\n    const nextIndex = run.currentBatchIndex + 1;\n    if (nextIndex >= run.batches.length) {\n      // All batches done \u2014 move to run_reviewing\n      await updateRevisionRun(run.runId, { status: \"run_reviewing\" });\n      const updated = await getRevisionRun(run.runId);\n      if (updated) setRun(updated);\n      return;\n    }\n\n    // Advance to next batch\n    await updateRevisionRun(run.runId, {\n      currentBatchIndex: nextIndex,\n      status: \"generating\",\n    });\n\n    const nextBatch = run.batches[nextIndex];\n    const contexts = getEntityContexts(nextBatch.entityIds);\n    dispatchBatch(run.runId, contexts);\n    startPolling(run.runId);\n  }, [run, dispatchBatch, startPolling, getEntityContexts]);\n\n  // Auto-continue all remaining batches\n  const autoContineAll = useCallback(async () => {\n    if (!run) return;\n    autoModeRef.current = true;\n\n    // Trigger next batch\n    await continueToNextBatch();\n  }, [run, continueToNextBatch]);\n\n  // Toggle accept/reject for a specific entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply all accepted patches and return them\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect all patches from all batches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelRevision = useCallback(() => {\n    autoModeRef.current = false;\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startRevision,\n    continueToNextBatch,\n    autoContineAll,\n    togglePatchDecision,\n    applyAccepted,\n    cancelRevision,\n  };\n}", "parameters": [{"name": "getEntityContexts", "type": "(entityIds: string[]) => RevisionEntityContext[]", "optional": false}], "returnType": "UseSummaryRevisionReturn", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useCallback", "count": 9}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionBatch", "SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::useToneRanking", "name": "useToneRanking", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "// ============================================================================\n// Hook \u2014 thin accessor over toneRankingStore\n// ============================================================================\n\nexport function useToneRanking(): UseToneRankingReturn {\n  const progress = useToneRankingStore((s) => s.progress);\n  const assignmentPreview = useToneRankingStore((s) => s.assignmentPreview);\n  const prepareToneRanking = useToneRankingStore((s) => s.prepareToneRanking);\n  const confirmToneRanking = useToneRankingStore((s) => s.confirmToneRanking);\n  const cancelToneRanking = useToneRankingStore((s) => s.cancelToneRanking);\n  const closeToneRanking = useToneRankingStore((s) => s.closeToneRanking);\n  const prepareAssignment = useToneRankingStore((s) => s.prepareAssignment);\n  const applyAssignment = useToneRankingStore((s) => s.applyAssignment);\n  const closeAssignment = useToneRankingStore((s) => s.closeAssignment);\n\n  const isActive = progress.status === \"running\" || progress.status === \"confirming\";\n\n  return {\n    progress,\n    isActive,\n    prepareToneRanking,\n    confirmToneRanking,\n    cancelToneRanking,\n    closeToneRanking,\n    assignmentPreview,\n    prepareAssignment,\n    applyAssignment,\n    closeAssignment,\n  };\n}", "parameters": [], "returnType": "UseToneRankingReturn", "jsxTree": null, "hookCalls": [{"name": "useToneRankingStore", "count": 9}], "imports": [{"source": "../lib/db/toneRankingStore", "specifiers": ["useToneRankingStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone"], "category": "internal"}], "storeAccess": ["useToneRankingStore"]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::ChronicleWizard", "name": "ChronicleWizard", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "// =============================================================================\n// Main Component (wraps with provider)\n// =============================================================================\n\nexport default function ChronicleWizard(props: Readonly<ChronicleWizardProps>) {\n  if (!props.isOpen) return null;\n\n  return (\n    <WizardProvider\n      entityKinds={props.entityKinds}\n      eras={props.eras ?? []}\n      simulationRunId={props.simulationRunId}\n    >\n      <InnerWizard {...props} />\n    </WizardProvider>\n  );\n}", "parameters": [{"name": "props", "type": "Readonly<ChronicleWizardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "WizardProvider", "children": [{"tag": "InnerWizard", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::WizardProvider", "name": "WizardProvider", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "export function WizardProvider({\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}: Readonly<WizardProviderProps>) {\n  const [state, dispatch] = useReducer(wizardReducer, initialState);\n\n  // Build kind-to-category mapping\n  const kindToCategory = useMemo(() => buildKindToCategoryMap(entityKinds), [entityKinds]);\n\n  // Compute ALL relevant events (unlimited) for focal era computation\n  // This includes all events involving assigned entities, not just top 20\n  const allRelevantEvents = useMemo(() => {\n    const events = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    return events;\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Compute detected focal era from selected events (if any), otherwise all relevant events.\n  // This ensures that when the user narrows the event selection, the focal era updates to match.\n  const detectedFocalEra = useMemo<EraTemporalInfo | null>(() => {\n    if (eras.length === 0) return null;\n    // Prefer selected events when user has made a selection\n    const eventsForDetection =\n      state.selectedEventIds.size > 0\n        ? allRelevantEvents.filter((e) => state.selectedEventIds.has(e.id))\n        : allRelevantEvents;\n    return computeFocalEra(eventsForDetection, eras) || null;\n  }, [eras, allRelevantEvents, state.selectedEventIds]);\n\n  // Compute effective focal era (respecting override)\n  const effectiveFocalEraId = useMemo(() => {\n    return state.focalEraOverride || detectedFocalEra?.id || eras[0]?.id || \"\";\n  }, [state.focalEraOverride, detectedFocalEra, eras]);\n\n  // Compute temporal context from selected events, but align focal era to the dropdown choice\n  const temporalContext = useMemo<ChronicleTemporalContext | null>(() => {\n    if (eras.length === 0) return null;\n\n    // Get selected events for temporal computation\n    const selectedEvents = state.candidateEvents.filter((e) => state.selectedEventIds.has(e.id));\n\n    return computeTemporalContext(\n      selectedEvents,\n      eras,\n      state.entryPoint || undefined,\n      effectiveFocalEraId\n    );\n  }, [eras, state.candidateEvents, state.selectedEventIds, state.entryPoint, effectiveFocalEraId]);\n\n  // Navigation\n  const nextStep = useCallback(() => {\n    if (state.step < 5) {\n      dispatch({ type: \"SET_STEP\", step: (state.step + 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const prevStep = useCallback(() => {\n    if (state.step > 1) {\n      dispatch({ type: \"SET_STEP\", step: (state.step - 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const goToStep = useCallback((step: WizardStep) => {\n    dispatch({ type: \"SET_STEP\", step });\n  }, []);\n\n  // Step 1: Style selection\n  const selectStyle = useCallback((style: NarrativeStyle, acceptDefaults: boolean) => {\n    dispatch({ type: \"SELECT_STYLE\", style, acceptDefaults });\n  }, []);\n\n  const setAcceptDefaults = useCallback((acceptDefaults: boolean) => {\n    dispatch({ type: \"SET_ACCEPT_DEFAULTS\", acceptDefaults });\n  }, []);\n\n  // Step 2: Entry point selection\n  const selectEntryPoint = useCallback(\n    (\n      entity: EntityContext,\n      allEntities: EntityContext[],\n      allRelationships: RelationshipContext[],\n      allEvents: NarrativeEventContext[]\n    ) => {\n      dispatch({ type: \"SELECT_ENTRY_POINT\", entity });\n\n      // Build selection context for this entry point\n      if (state.narrativeStyle) {\n        const selectionContext = buildWizardSelectionContext(\n          entity,\n          allEntities,\n          allRelationships,\n          allEvents,\n          state.narrativeStyle,\n          { includeErasInNeighborhood: state.includeErasInNeighborhood }\n        );\n\n        dispatch({\n          type: \"SET_CANDIDATES\",\n          candidates: selectionContext.candidates,\n          relationships: selectionContext.candidateRelationships,\n          events: selectionContext.candidateEvents,\n          distances: selectionContext.distances,\n        });\n\n        // Auto-fill if accept defaults is checked\n        if (state.acceptDefaults) {\n          const roles = getRoles(state.narrativeStyle);\n          const suggested = suggestRoleAssignments(\n            selectionContext.candidates,\n            roles,\n            entity.id,\n            undefined, // entityRules removed\n            selectionContext.candidateRelationships,\n            kindToCategory\n          );\n          dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n        }\n      }\n    },\n    [state.narrativeStyle, state.acceptDefaults, state.includeErasInNeighborhood, kindToCategory]\n  );\n\n  // Clear entry point\n  const clearEntryPoint = useCallback(() => {\n    dispatch({ type: \"CLEAR_ENTRY_POINT\" });\n  }, []);\n\n  // Set include eras in neighborhood option\n  const setIncludeErasInNeighborhood = useCallback((include: boolean) => {\n    dispatch({ type: \"SET_INCLUDE_ERAS_IN_NEIGHBORHOOD\", include });\n  }, []);\n\n  // Compute metrics helper - uses stored distances from original graph construction\n  const computeMetrics = useCallback(\n    (usageStats: Map<string, { usageCount: number }>) => {\n      if (!state.entryPoint) return new Map<string, EntitySelectionMetrics>();\n\n      return computeAllEntityMetrics(\n        state.candidates,\n        state.entryPoint.id,\n        state.candidateRelationships,\n        state.candidateDistances,\n        usageStats,\n        state.roleAssignments,\n        kindToCategory\n      );\n    },\n    [\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      state.candidateDistances,\n      state.roleAssignments,\n      kindToCategory,\n    ]\n  );\n\n  // Compute event metrics for selection\n  const computeEventMetricsForSelection = useCallback(() => {\n    if (!state.entryPoint || eras.length === 0) {\n      return new Map<string, EventSelectionMetrics>();\n    }\n\n    // Get assigned entity IDs\n    const assignedEntityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n\n    return computeAllEventMetrics(\n      state.candidateEvents,\n      state.entryPoint.id,\n      state.entryPoint.createdAt,\n      effectiveFocalEraId,\n      eras,\n      assignedEntityIds\n    );\n  }, [state.entryPoint, state.candidateEvents, state.roleAssignments, eras, effectiveFocalEraId]);\n\n  // Auto-fill events based on temporal alignment\n  const autoFillEvents = useCallback(\n    (preferFocalEra: boolean = true) => {\n      const metricsMap = computeEventMetricsForSelection();\n\n      // Get relevant events (those involving assigned entities)\n      const relevantEvents = getRelevantEvents(\n        state.roleAssignments,\n        state.candidateEvents\n      );\n\n      const suggestedEventIds = suggestEventSelection(\n        relevantEvents,\n        metricsMap,\n        8, // maxEvents\n        preferFocalEra\n      );\n\n      dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds: suggestedEventIds });\n    },\n    [\n      computeEventMetricsForSelection,\n      state.roleAssignments,\n      state.candidateEvents,\n      state.narrativeStyle,\n    ]\n  );\n\n  // Auto-fill all events and relationships (used when skipping step 4 with defaults)\n  const autoFillEventsAndRelationships = useCallback(() => {\n    // Get all relevant relationships (include lens entity)\n    const lensIds = state.lens ? [state.lens.entityId] : [];\n    const relevantRelationships = getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensIds\n    );\n    const relationshipIds = relevantRelationships.map((r) => `${r.src}:${r.dst}:${r.kind}`);\n\n    // Get all relevant events\n    const relevantEvents = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    const eventIds = relevantEvents.map((e) => e.id);\n\n    // Select all\n    dispatch({ type: \"SELECT_ALL_RELATIONSHIPS\", relationshipIds });\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, [\n    state.roleAssignments,\n    state.candidateRelationships,\n    state.candidateEvents,\n    state.narrativeStyle,\n    state.lens,\n  ]);\n\n  // Step 3: Auto-fill roles\n  const autoFillRoles = useCallback(\n    (metricsMap?: Map<string, EntitySelectionMetrics>) => {\n      if (!state.narrativeStyle || !state.entryPoint) return;\n\n      const roles = getRoles(state.narrativeStyle);\n      const suggested = suggestRoleAssignments(\n        state.candidates,\n        roles,\n        state.entryPoint.id,\n        undefined, // entityRules removed\n        state.candidateRelationships,\n        kindToCategory,\n        metricsMap\n      );\n      dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n    },\n    [\n      state.narrativeStyle,\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      kindToCategory,\n    ]\n  );\n\n  const addRoleAssignment = useCallback((assignment: ChronicleRoleAssignment) => {\n    dispatch({ type: \"ADD_ROLE_ASSIGNMENT\", assignment });\n  }, []);\n\n  const removeRoleAssignment = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"REMOVE_ROLE_ASSIGNMENT\", entityId, role });\n  }, []);\n\n  const togglePrimary = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"TOGGLE_PRIMARY\", entityId, role });\n  }, []);\n\n  // Lens actions\n  const setLens = useCallback((lens: NarrativeLens) => {\n    dispatch({ type: \"SET_LENS\", lens });\n  }, []);\n\n  const clearLens = useCallback(() => {\n    dispatch({ type: \"CLEAR_LENS\" });\n  }, []);\n\n  // Step 4: Event/relationship selection\n  const toggleEvent = useCallback((eventId: string) => {\n    dispatch({ type: \"TOGGLE_EVENT\", eventId });\n  }, []);\n\n  const toggleRelationship = useCallback((relationshipId: string) => {\n    dispatch({ type: \"TOGGLE_RELATIONSHIP\", relationshipId });\n  }, []);\n\n  const selectAllEvents = useCallback((eventIds: string[]) => {\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, []);\n\n  const deselectAllEvents = useCallback(() => {\n    dispatch({ type: \"DESELECT_ALL_EVENTS\" });\n  }, []);\n// ... (truncated)", "parameters": [{"name": "{\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}", "type": "Readonly<WizardProviderProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "WizardContext.Provider", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useReducer", "count": 1}, {"name": "useMemo", "count": 6}, {"name": "useCallback", "count": 28}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::useWizard", "name": "useWizard", "kind": "hook", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "// =============================================================================\n// Hook\n// =============================================================================\n\nexport function useWizard(): WizardContextValue {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error(\"useWizard must be used within a WizardProvider\");\n  }\n  return context;\n}", "parameters": [], "returnType": "WizardContextValue", "jsxTree": null, "hookCalls": [{"name": "useContext", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx::WizardProvider", "name": "WizardProvider", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx", "sourceCode": "export function WizardProvider({\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}: Readonly<WizardProviderProps>) {\n  const [state, dispatch] = useReducer(wizardReducer, initialState);\n\n  // Build kind-to-category mapping\n  const kindToCategory = useMemo(() => buildKindToCategoryMap(entityKinds), [entityKinds]);\n\n  // Compute ALL relevant events (unlimited) for focal era computation\n  // This includes all events involving assigned entities, not just top 20\n  const allRelevantEvents = useMemo(() => {\n    const events = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    return events;\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Compute detected focal era from selected events (if any), otherwise all relevant events.\n  // This ensures that when the user narrows the event selection, the focal era updates to match.\n  const detectedFocalEra = useMemo<EraTemporalInfo | null>(() => {\n    if (eras.length === 0) return null;\n    // Prefer selected events when user has made a selection\n    const eventsForDetection =\n      state.selectedEventIds.size > 0\n        ? allRelevantEvents.filter((e) => state.selectedEventIds.has(e.id))\n        : allRelevantEvents;\n    return computeFocalEra(eventsForDetection, eras) || null;\n  }, [eras, allRelevantEvents, state.selectedEventIds]);\n\n  // Compute effective focal era (respecting override)\n  const effectiveFocalEraId = useMemo(() => {\n    return state.focalEraOverride || detectedFocalEra?.id || eras[0]?.id || \"\";\n  }, [state.focalEraOverride, detectedFocalEra, eras]);\n\n  // Compute temporal context from selected events, but align focal era to the dropdown choice\n  const temporalContext = useMemo<ChronicleTemporalContext | null>(() => {\n    if (eras.length === 0) return null;\n\n    // Get selected events for temporal computation\n    const selectedEvents = state.candidateEvents.filter((e) => state.selectedEventIds.has(e.id));\n\n    return computeTemporalContext(\n      selectedEvents,\n      eras,\n      state.entryPoint || undefined,\n      effectiveFocalEraId\n    );\n  }, [eras, state.candidateEvents, state.selectedEventIds, state.entryPoint, effectiveFocalEraId]);\n\n  // Navigation\n  const nextStep = useCallback(() => {\n    if (state.step < 5) {\n      dispatch({ type: \"SET_STEP\", step: (state.step + 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const prevStep = useCallback(() => {\n    if (state.step > 1) {\n      dispatch({ type: \"SET_STEP\", step: (state.step - 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const goToStep = useCallback((step: WizardStep) => {\n    dispatch({ type: \"SET_STEP\", step });\n  }, []);\n\n  // Step 1: Style selection\n  const selectStyle = useCallback((style: NarrativeStyle, acceptDefaults: boolean) => {\n    dispatch({ type: \"SELECT_STYLE\", style, acceptDefaults });\n  }, []);\n\n  const setAcceptDefaults = useCallback((acceptDefaults: boolean) => {\n    dispatch({ type: \"SET_ACCEPT_DEFAULTS\", acceptDefaults });\n  }, []);\n\n  // Step 2: Entry point selection\n  const selectEntryPoint = useCallback(\n    (\n      entity: EntityContext,\n      allEntities: EntityContext[],\n      allRelationships: RelationshipContext[],\n      allEvents: NarrativeEventContext[]\n    ) => {\n      dispatch({ type: \"SELECT_ENTRY_POINT\", entity });\n\n      // Build selection context for this entry point\n      if (state.narrativeStyle) {\n        const selectionContext = buildWizardSelectionContext(\n          entity,\n          allEntities,\n          allRelationships,\n          allEvents,\n          state.narrativeStyle,\n          { includeErasInNeighborhood: state.includeErasInNeighborhood }\n        );\n\n        dispatch({\n          type: \"SET_CANDIDATES\",\n          candidates: selectionContext.candidates,\n          relationships: selectionContext.candidateRelationships,\n          events: selectionContext.candidateEvents,\n          distances: selectionContext.distances,\n        });\n\n        // Auto-fill if accept defaults is checked\n        if (state.acceptDefaults) {\n          const roles = getRoles(state.narrativeStyle);\n          const suggested = suggestRoleAssignments(\n            selectionContext.candidates,\n            roles,\n            entity.id,\n            undefined, // entityRules removed\n            selectionContext.candidateRelationships,\n            kindToCategory\n          );\n          dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n        }\n      }\n    },\n    [state.narrativeStyle, state.acceptDefaults, state.includeErasInNeighborhood, kindToCategory]\n  );\n\n  // Clear entry point\n  const clearEntryPoint = useCallback(() => {\n    dispatch({ type: \"CLEAR_ENTRY_POINT\" });\n  }, []);\n\n  // Set include eras in neighborhood option\n  const setIncludeErasInNeighborhood = useCallback((include: boolean) => {\n    dispatch({ type: \"SET_INCLUDE_ERAS_IN_NEIGHBORHOOD\", include });\n  }, []);\n\n  // Compute metrics helper - uses stored distances from original graph construction\n  const computeMetrics = useCallback(\n    (usageStats: Map<string, { usageCount: number }>) => {\n      if (!state.entryPoint) return new Map<string, EntitySelectionMetrics>();\n\n      return computeAllEntityMetrics(\n        state.candidates,\n        state.entryPoint.id,\n        state.candidateRelationships,\n        state.candidateDistances,\n        usageStats,\n        state.roleAssignments,\n        kindToCategory\n      );\n    },\n    [\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      state.candidateDistances,\n      state.roleAssignments,\n      kindToCategory,\n    ]\n  );\n\n  // Compute event metrics for selection\n  const computeEventMetricsForSelection = useCallback(() => {\n    if (!state.entryPoint || eras.length === 0) {\n      return new Map<string, EventSelectionMetrics>();\n    }\n\n    // Get assigned entity IDs\n    const assignedEntityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n\n    return computeAllEventMetrics(\n      state.candidateEvents,\n      state.entryPoint.id,\n      state.entryPoint.createdAt,\n      effectiveFocalEraId,\n      eras,\n      assignedEntityIds\n    );\n  }, [state.entryPoint, state.candidateEvents, state.roleAssignments, eras, effectiveFocalEraId]);\n\n  // Auto-fill events based on temporal alignment\n  const autoFillEvents = useCallback(\n    (preferFocalEra: boolean = true) => {\n      const metricsMap = computeEventMetricsForSelection();\n\n      // Get relevant events (those involving assigned entities)\n      const relevantEvents = getRelevantEvents(\n        state.roleAssignments,\n        state.candidateEvents\n      );\n\n      const suggestedEventIds = suggestEventSelection(\n        relevantEvents,\n        metricsMap,\n        8, // maxEvents\n        preferFocalEra\n      );\n\n      dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds: suggestedEventIds });\n    },\n    [\n      computeEventMetricsForSelection,\n      state.roleAssignments,\n      state.candidateEvents,\n      state.narrativeStyle,\n    ]\n  );\n\n  // Auto-fill all events and relationships (used when skipping step 4 with defaults)\n  const autoFillEventsAndRelationships = useCallback(() => {\n    // Get all relevant relationships (include lens entity)\n    const lensIds = state.lens ? [state.lens.entityId] : [];\n    const relevantRelationships = getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensIds\n    );\n    const relationshipIds = relevantRelationships.map((r) => `${r.src}:${r.dst}:${r.kind}`);\n\n    // Get all relevant events\n    const relevantEvents = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    const eventIds = relevantEvents.map((e) => e.id);\n\n    // Select all\n    dispatch({ type: \"SELECT_ALL_RELATIONSHIPS\", relationshipIds });\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, [\n    state.roleAssignments,\n    state.candidateRelationships,\n    state.candidateEvents,\n    state.narrativeStyle,\n    state.lens,\n  ]);\n\n  // Step 3: Auto-fill roles\n  const autoFillRoles = useCallback(\n    (metricsMap?: Map<string, EntitySelectionMetrics>) => {\n      if (!state.narrativeStyle || !state.entryPoint) return;\n\n      const roles = getRoles(state.narrativeStyle);\n      const suggested = suggestRoleAssignments(\n        state.candidates,\n        roles,\n        state.entryPoint.id,\n        undefined, // entityRules removed\n        state.candidateRelationships,\n        kindToCategory,\n        metricsMap\n      );\n      dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n    },\n    [\n      state.narrativeStyle,\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      kindToCategory,\n    ]\n  );\n\n  const addRoleAssignment = useCallback((assignment: ChronicleRoleAssignment) => {\n    dispatch({ type: \"ADD_ROLE_ASSIGNMENT\", assignment });\n  }, []);\n\n  const removeRoleAssignment = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"REMOVE_ROLE_ASSIGNMENT\", entityId, role });\n  }, []);\n\n  const togglePrimary = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"TOGGLE_PRIMARY\", entityId, role });\n  }, []);\n\n  // Lens actions\n  const setLens = useCallback((lens: NarrativeLens) => {\n    dispatch({ type: \"SET_LENS\", lens });\n  }, []);\n\n  const clearLens = useCallback(() => {\n    dispatch({ type: \"CLEAR_LENS\" });\n  }, []);\n\n  // Step 4: Event/relationship selection\n  const toggleEvent = useCallback((eventId: string) => {\n    dispatch({ type: \"TOGGLE_EVENT\", eventId });\n  }, []);\n\n  const toggleRelationship = useCallback((relationshipId: string) => {\n    dispatch({ type: \"TOGGLE_RELATIONSHIP\", relationshipId });\n  }, []);\n\n  const selectAllEvents = useCallback((eventIds: string[]) => {\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, []);\n\n  const deselectAllEvents = useCallback(() => {\n    dispatch({ type: \"DESELECT_ALL_EVENTS\" });\n  }, []);\n// ... (truncated)", "parameters": [{"name": "{\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}", "type": "Readonly<WizardProviderProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "WizardContext.Provider", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useReducer", "count": 1}, {"name": "useMemo", "count": 6}, {"name": "useCallback", "count": 28}], "imports": [{"source": "react", "specifiers": ["React", "createContext", "useContext", "useReducer", "ReactNode", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "EntityKindDefinition", "EntityCategory", "RoleDefinition"], "category": "external"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "NarrativeLens", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext"], "category": "internal"}, {"source": "../../lib/chronicle/selectionWizard", "specifiers": ["buildWizardSelectionContext", "suggestRoleAssignments", "computeAllEntityMetrics", "computeAllEventMetrics", "computeTemporalContext", "computeFocalEra", "suggestEventSelection", "getRelevantRelationships", "getRelevantEvents", "buildKindToCategoryMap", "EntitySelectionMetrics", "EventSelectionMetrics"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx::useWizard", "name": "useWizard", "kind": "hook", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx", "sourceCode": "// =============================================================================\n// Hook\n// =============================================================================\n\nexport function useWizard(): WizardContextValue {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error(\"useWizard must be used within a WizardProvider\");\n  }\n  return context;\n}", "parameters": [], "returnType": "WizardContextValue", "jsxTree": null, "hookCalls": [{"name": "useContext", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "createContext", "useContext", "useReducer", "ReactNode", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "EntityKindDefinition", "EntityCategory", "RoleDefinition"], "category": "external"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "NarrativeLens", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext"], "category": "internal"}, {"source": "../../lib/chronicle/selectionWizard", "specifiers": ["buildWizardSelectionContext", "suggestRoleAssignments", "computeAllEntityMetrics", "computeAllEventMetrics", "computeTemporalContext", "computeFocalEra", "suggestEventSelection", "getRelevantRelationships", "getRelevantEvents", "buildKindToCategoryMap", "EntitySelectionMetrics", "EventSelectionMetrics"], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useChronicleNavItems", "name": "useChronicleNavItems", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "// ============================================================================\n// Nav item type \u2014 lightweight projection for the chronicle list sidebar\n// ============================================================================\n\n// ============================================================================\n// Selectors\n// ============================================================================\n\n/**\n * Sorted nav items for the chronicle list sidebar.\n * Subscribes to the chronicles record (reference-stable per chronicle),\n * derives lightweight nav items in a useMemo.\n */\nexport function useChronicleNavItems(\n  getEffectiveStatus?: (chronicleId: string, baseStatus: string) => string\n): ChronicleNavItem[] {\n  const navItems = useChronicleStore((state) => state.navItems);\n  const navOrder = useChronicleStore((state) => state.navOrder);\n\n  return useMemo(() => {\n    const items = navOrder.map((id) => navItems[id]).filter(Boolean);\n    if (!getEffectiveStatus) return items;\n    return items.map((item) => ({\n      ...item,\n      status: getEffectiveStatus(item.chronicleId, item.status),\n    }));\n  }, [navItems, navOrder, getEffectiveStatus]);\n}", "parameters": [{"name": "getEffectiveStatus", "type": "(chronicleId: string, baseStatus: string) => string", "optional": true}], "returnType": "ChronicleNavItem[]", "jsxTree": null, "hookCalls": [{"name": "useChronicleStore", "count": 2}, {"name": "useMemo", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}], "storeAccess": ["useChronicleStore", "useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useSelectedChronicle", "name": "useSelectedChronicle", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Single chronicle record for the review panel.\n * Only re-renders when this specific chronicle's record reference changes.\n */\nexport function useSelectedChronicle(chronicleId: string | null): ChronicleRecord | undefined {\n  const record = useChronicleStore((state) =>\n    chronicleId ? state.cache.get(chronicleId) : undefined\n  );\n  const loadChronicle = useChronicleStore((state) => state.loadChronicle);\n\n  useEffect(() => {\n    if (chronicleId) {\n      void loadChronicle(chronicleId);\n    }\n  }, [chronicleId, loadChronicle]);\n\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string | null", "optional": false}], "returnType": "ChronicleRecord | undefined", "jsxTree": null, "hookCalls": [{"name": "useChronicleStore", "count": 2}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}], "storeAccess": ["useChronicleStore", "useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useChronicleCount", "name": "useChronicleCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Chronicle count for stats display.\n */\nexport function useChronicleCount(): number {\n  return useChronicleStore((state) => state.navOrder.length);\n}", "parameters": [], "returnType": "number", "jsxTree": null, "hookCalls": [{"name": "useChronicleStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}], "storeAccess": ["useChronicleStore", "useChronicleStore.getState"]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavItems", "name": "useEntityNavItems", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Full nav item map for O(1) lookups \u2014 re-renders when any nav item changes */\nexport function useEntityNavItems(): Map<string, EntityNavItem> {\n  return useEntityStore((state) => state.navItems);\n}", "parameters": [], "returnType": "Map<string, EntityNavItem>", "jsxTree": null, "hookCalls": [{"name": "useEntityStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}], "storeAccess": ["useEntityStore"]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavList", "name": "useEntityNavList", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Nav item array for list rendering \u2014 derived from map via useMemo */\nexport function useEntityNavList(): EntityNavItem[] {\n  const navItems = useEntityStore((state) => state.navItems);\n  return useMemo(() => (navItems.size ? Array.from(navItems.values()) : EMPTY_ARRAY), [navItems]);\n}", "parameters": [], "returnType": "EntityNavItem[]", "jsxTree": null, "hookCalls": [{"name": "useEntityStore", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}], "storeAccess": ["useEntityStore"]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavItem", "name": "useEntityNavItem", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Single nav item by ID \u2014 only re-renders when this specific nav item changes */\nexport function useEntityNavItem(id: string | undefined): EntityNavItem | undefined {\n  return useEntityStore((state) => (id ? state.navItems.get(id) : undefined));\n}", "parameters": [{"name": "id", "type": "string | undefined", "optional": false}], "returnType": "EntityNavItem | undefined", "jsxTree": null, "hookCalls": [{"name": "useEntityStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}], "storeAccess": ["useEntityStore"]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntity", "name": "useEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/**\n * Single full entity from the bounded cache.\n * Returns undefined if the entity hasn't been loaded yet.\n * Pair with store.loadEntity(id) in a useEffect to trigger the load.\n */\nexport function useEntity(id: string | undefined): PersistedEntity | undefined {\n  return useEntityStore((state) => (id ? state.cache.get(id) : undefined));\n}", "parameters": [{"name": "id", "type": "string | undefined", "optional": false}], "returnType": "PersistedEntity | undefined", "jsxTree": null, "hookCalls": [{"name": "useEntityStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}], "storeAccess": ["useEntityStore"]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityCount", "name": "useEntityCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Entity count \u2014 only re-renders when count changes */\nexport function useEntityCount(): number {\n  return useEntityStore((state) => state.navItems.size);\n}", "parameters": [], "returnType": "number", "jsxTree": null, "hookCalls": [{"name": "useEntityStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}], "storeAccess": ["useEntityStore"]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useProminenceScale", "name": "useProminenceScale", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useProminenceScale(): ProminenceScale {\n  return useIndexStore((state) => state.indexes?.prominenceScale ?? FALLBACK_SCALE);\n}", "parameters": [], "returnType": "ProminenceScale", "jsxTree": null, "hookCalls": [{"name": "useIndexStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}], "storeAccess": ["useIndexStore"]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useRenownedThreshold", "name": "useRenownedThreshold", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useRenownedThreshold(): number {\n  return useIndexStore((state) => state.indexes?.renownedThreshold ?? 0);\n}", "parameters": [], "returnType": "number", "jsxTree": null, "hookCalls": [{"name": "useIndexStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}], "storeAccess": ["useIndexStore"]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useEraTemporalInfo", "name": "useEraTemporalInfo", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useEraTemporalInfo(): EraTemporalEntry[] {\n  return useIndexStore((state) => state.indexes?.eraTemporalInfo ?? EMPTY_ERA_TEMPORAL);\n}", "parameters": [], "returnType": "EraTemporalEntry[]", "jsxTree": null, "hookCalls": [{"name": "useIndexStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}], "storeAccess": ["useIndexStore"]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useEraTemporalInfoByKey", "name": "useEraTemporalInfoByKey", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useEraTemporalInfoByKey(): Map<string, EraTemporalEntry> {\n  const eraTemporalInfo = useIndexStore((state) => state.indexes?.eraTemporalInfo);\n  const eraIdAliases = useIndexStore((state) => state.indexes?.eraIdAliases);\n\n  return useMemo(() => {\n    if (!eraTemporalInfo?.length) return EMPTY_MAP;\n\n    const byId = new Map<string, EraTemporalEntry>(eraTemporalInfo.map((era) => [era.id, era]));\n    const map = new Map(byId);\n\n    if (eraIdAliases) {\n      for (const [entityId, eraId] of Object.entries(eraIdAliases)) {\n        const eraInfo = byId.get(entityId) || byId.get(eraId);\n        if (eraInfo) {\n          map.set(eraId, eraInfo);\n          map.set(entityId, eraInfo);\n        }\n      }\n    }\n\n    return map;\n  }, [eraTemporalInfo, eraIdAliases]);\n}", "parameters": [], "returnType": "Map<string, EraTemporalEntry>", "jsxTree": null, "hookCalls": [{"name": "useIndexStore", "count": 2}, {"name": "useMemo", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}], "storeAccess": ["useIndexStore"]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useProminentByCulture", "name": "useProminentByCulture", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useProminentByCulture(): Record<string, Array<{ id: string; name: string }>> {\n  return useIndexStore((state) => state.indexes?.prominentByCulture ?? EMPTY_PROMINENT);\n}", "parameters": [], "returnType": "Record<string, Array<{ id: string; name: string }>>", "jsxTree": null, "hookCalls": [{"name": "useIndexStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}], "storeAccess": ["useIndexStore"]}, {"id": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts::useNarrativeEvents", "name": "useNarrativeEvents", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts", "sourceCode": "/** Full narrative events array \u2014 re-renders when events change */\nexport function useNarrativeEvents() {\n  return useNarrativeEventStore((state) => state.events);\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/illuminatorDb\").PersistedNarrativeEvent[]", "jsxTree": null, "hookCalls": [{"name": "useNarrativeEventStore", "count": 1}], "imports": [{"source": "./narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}], "storeAccess": ["useNarrativeEventStore"]}, {"id": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts::useNarrativeEventCount", "name": "useNarrativeEventCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts", "sourceCode": "/** Event count \u2014 re-renders when count changes */\nexport function useNarrativeEventCount(): number {\n  return useNarrativeEventStore((state) => state.events.length);\n}", "parameters": [], "returnType": "number", "jsxTree": null, "hookCalls": [{"name": "useNarrativeEventStore", "count": 1}], "imports": [{"source": "./narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}], "storeAccess": ["useNarrativeEventStore"]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationships", "name": "useRelationships", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Full flat relationship array \u2014 re-renders when relationships change */\nexport function useRelationships(): PersistedRelationship[] {\n  return useRelationshipStore((state) => state.relationships);\n}", "parameters": [], "returnType": "PersistedRelationship[]", "jsxTree": null, "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}], "storeAccess": ["useRelationshipStore"]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipsByEntity", "name": "useRelationshipsByEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Precomputed byEntity index \u2014 re-renders when relationships change */\nexport function useRelationshipsByEntity(): RelationshipIndex {\n  return useRelationshipStore((state) => state.byEntity);\n}", "parameters": [], "returnType": "RelationshipIndex", "jsxTree": null, "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}], "storeAccess": ["useRelationshipStore"]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipsForEntity", "name": "useRelationshipsForEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Relationships for a specific entity \u2014 re-renders when index changes */\nexport function useRelationshipsForEntity(entityId: string | undefined): PersistedRelationship[] {\n  return useRelationshipStore((state) =>\n    entityId\n      ? ((state.byEntity.get(entityId) as PersistedRelationship[] | undefined) ?? EMPTY_ARRAY)\n      : EMPTY_ARRAY\n  );\n}", "parameters": [{"name": "entityId", "type": "string | undefined", "optional": false}], "returnType": "PersistedRelationship[]", "jsxTree": null, "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}], "storeAccess": ["useRelationshipStore"]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipCount", "name": "useRelationshipCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Relationship count */\nexport function useRelationshipCount(): number {\n  return useRelationshipStore((state) => state.relationships.length);\n}", "parameters": [], "returnType": "number", "jsxTree": null, "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}], "storeAccess": ["useRelationshipStore"]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::IntensitySparkline", "name": "IntensitySparkline", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function IntensitySparkline({\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}: Readonly<IntensitySparklineProps>) {\n  // Match padding with NarrativeTimeline for visual alignment\n  const padding = { left: 40, right: 40, top: 4, bottom: 4 };\n  const innerWidth = width - padding.left - padding.right;\n  const innerHeight = height - padding.top - padding.bottom;\n\n  // Build the SVG path\n  const { areaPath, linePath } = useMemo(() => {\n    if (points.length < 2) {\n      return { areaPath: \"\", linePath: \"\" };\n    }\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const scaleY = (intensity: number) => padding.top + (1 - intensity) * innerHeight;\n\n    // Build line path\n    const lineParts: string[] = [];\n    const areaParts: string[] = [];\n\n    points.forEach((point, i) => {\n      const x = scaleX(point.tick);\n      const y = scaleY(point.intensity);\n\n      if (i === 0) {\n        lineParts.push(`M ${x} ${y}`);\n        areaParts.push(`M ${x} ${height - padding.bottom}`);\n        areaParts.push(`L ${x} ${y}`);\n      } else {\n        lineParts.push(`L ${x} ${y}`);\n        areaParts.push(`L ${x} ${y}`);\n      }\n    });\n\n    // Close the area path\n    const lastX = scaleX(points[points.length - 1].tick);\n    areaParts.push(`L ${lastX} ${height - padding.bottom}`);\n    areaParts.push(\"Z\");\n\n    return {\n      areaPath: areaParts.join(\" \"),\n      linePath: lineParts.join(\" \"),\n    };\n  }, [points, extent, innerWidth, innerHeight, height, padding]);\n\n  // Build highlight rect for selected range\n  const highlightRect = useMemo(() => {\n    if (!selectedRange) return null;\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const x1 = scaleX(selectedRange[0]);\n    const x2 = scaleX(selectedRange[1]);\n\n    return {\n      x: Math.min(x1, x2),\n      width: Math.abs(x2 - x1),\n    };\n  }, [selectedRange, extent, innerWidth, padding]);\n\n  if (points.length < 2) {\n    return (\n      <svg width={width} height={height}>\n        <text\n          x={width / 2}\n          y={height / 2}\n          textAnchor=\"middle\"\n          fontSize=\"10\"\n          fill=\"var(--text-muted)\"\n        >\n          Not enough data\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={width} height={height} className=\"is-svg\">\n      {/* Selected range highlight */}\n      {highlightRect && (\n        <rect\n          x={highlightRect.x}\n          y={0}\n          width={highlightRect.width}\n          height={height}\n          fill=\"rgba(99, 102, 241, 0.15)\"\n        />\n      )}\n\n      {/* Area fill */}\n      <path d={areaPath} fill={fillColor} />\n\n      {/* Line stroke */}\n      <path d={linePath} fill=\"none\" stroke={strokeColor} strokeWidth={1.5} />\n\n      {/* Label */}\n      <text x={4} y={12} fontSize=\"9\" fill=\"var(--text-muted)\" fontFamily=\"inherit\">\n        Narrative Intensity\n      </text>\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}", "type": "Readonly<IntensitySparklineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "text", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::TimelineBrush", "name": "TimelineBrush", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function TimelineBrush({\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}: Readonly<TimelineBrushProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [dragMode, setDragMode] = useState<DragMode>(\"none\");\n  const [dragStart, setDragStart] = useState<{ x: number; selection: [number, number] | null }>({\n    x: 0,\n    selection: null,\n  });\n\n  const handleSize = 8;\n\n  // Convert selection to pixel positions\n  const selectionPx = selection\n    ? {\n        left: tickToX(selection[0], extent, width, padding),\n        right: tickToX(selection[1], extent, width, padding),\n      }\n    : null;\n\n  const getMouseX = useCallback((e: React.MouseEvent | MouseEvent) => {\n    if (!svgRef.current) return 0;\n    const rect = svgRef.current.getBoundingClientRect();\n    return e.clientX - rect.left;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, mode: DragMode) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragMode(mode);\n      setDragStart({ x: getMouseX(e), selection });\n    },\n    [selection, getMouseX]\n  );\n\n  const handleBackgroundMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      const x = getMouseX(e);\n      // If clicking outside selection, start creating new selection\n      if (!selectionPx || x < selectionPx.left - handleSize || x > selectionPx.right + handleSize) {\n        setDragMode(\"create\");\n        const tick = xToTick(x, extent, width, padding);\n        setDragStart({ x, selection: [tick, tick] });\n        onSelectionChange([tick, tick]);\n      }\n    },\n    [selectionPx, extent, width, padding, getMouseX, onSelectionChange, handleSize]\n  );\n\n  useEffect(() => {\n    if (dragMode === \"none\") return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const x = getMouseX(e);\n      const dx = x - dragStart.x;\n\n      if (dragMode === \"create\") {\n        const startTick = dragStart.selection[0];\n        const currentTick = xToTick(x, extent, width, padding);\n        const newSelection: [number, number] =\n          currentTick >= startTick ? [startTick, currentTick] : [currentTick, startTick];\n        onSelectionChange(newSelection);\n        return;\n      }\n\n      if (!dragStart.selection) return;\n\n      const [startTick, endTick] = dragStart.selection;\n\n      if (dragMode === \"left\") {\n        const newLeft = xToTick(\n          tickToX(startTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.min(newLeft, endTick - 1);\n        onSelectionChange([Math.max(extent[0], clamped), endTick]);\n      } else if (dragMode === \"right\") {\n        const newRight = xToTick(\n          tickToX(endTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.max(newRight, startTick + 1);\n        onSelectionChange([startTick, Math.min(extent[1], clamped)]);\n      } else if (dragMode === \"move\") {\n        const tickDelta =\n          xToTick(dragStart.x + dx, extent, width, padding) -\n          xToTick(dragStart.x, extent, width, padding);\n        let newStart = startTick + tickDelta;\n        let newEnd = endTick + tickDelta;\n\n        // Clamp to extent\n        if (newStart < extent[0]) {\n          const shift = extent[0] - newStart;\n          newStart = extent[0];\n          newEnd += shift;\n        }\n        if (newEnd > extent[1]) {\n          const shift = newEnd - extent[1];\n          newEnd = extent[1];\n          newStart -= shift;\n        }\n\n        onSelectionChange([Math.max(extent[0], newStart), Math.min(extent[1], newEnd)]);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setDragMode(\"none\");\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [dragMode, dragStart, extent, width, padding, getMouseX, onSelectionChange]);\n\n  const getCursor = (mode: DragMode) => {\n    switch (mode) {\n      case \"left\":\n      case \"right\":\n        return \"ew-resize\";\n      case \"move\":\n        return \"grab\";\n      case \"create\":\n        return \"crosshair\";\n      default:\n        return \"crosshair\";\n    }\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"tb-svg\"\n      style={{\n        '--tb-cursor': getCursor(dragMode === \"none\" ? \"create\" : dragMode),\n      } as React.CSSProperties}\n      onMouseDown={handleBackgroundMouseDown}\n    >\n      {/* Background track */}\n      <rect\n        x={padding}\n        y={4}\n        width={width - 2 * padding}\n        height={height - 8}\n        rx={4}\n        fill=\"var(--bg-tertiary)\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n      />\n\n      {/* Selection */}\n      {selectionPx && selectionPx.right - selectionPx.left >= minSelectionWidth && (\n        <g>\n          {/* Selection rect */}\n          <rect\n            x={selectionPx.left}\n            y={4}\n            width={selectionPx.right - selectionPx.left}\n            height={height - 8}\n            rx={4}\n            fill=\"rgba(99, 102, 241, 0.3)\"\n            stroke=\"var(--accent-color)\"\n            strokeWidth={1}\n            className=\"tb-grab\"\n            onMouseDown={(e) => handleMouseDown(e, \"move\")}\n          />\n\n          {/* Left handle */}\n          <rect\n            x={selectionPx.left - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"left\")}\n          />\n\n          {/* Right handle */}\n          <rect\n            x={selectionPx.right - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"right\")}\n          />\n\n          {/* Selection label */}\n          {selection && (\n            <text\n              x={(selectionPx.left + selectionPx.right) / 2}\n              y={height / 2 + 4}\n              textAnchor=\"middle\"\n              fontSize=\"10\"\n              fontWeight=\"500\"\n              fill=\"var(--accent-color)\"\n              className=\"tb-no-pointer\"\n            >\n              {selection[0]} \u2013 {selection[1]}\n            </text>\n          )}\n        </g>\n      )}\n\n      {/* Instructions when no selection */}\n      {!selectionPx && (\n        <text\n          x={width / 2}\n          y={height / 2 + 4}\n          textAnchor=\"middle\"\n          fontSize=\"11\"\n          fill=\"var(--text-muted)\"\n          className=\"tb-no-pointer\"\n        >\n          Drag to select time range\n        </text>\n      )}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}", "type": "Readonly<TimelineBrushProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "g", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "text", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 2}, {"name": "useCallback", "count": 3}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::NarrativeTimeline", "name": "NarrativeTimeline", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function NarrativeTimeline({\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}: Readonly<NarrativeTimelineProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredEvent, setHoveredEvent] = useState<TooltipData | null>(null);\n  const [hoveredCastMarker, setHoveredCastMarker] = useState<CastTooltipData | null>(null);\n\n  const padding = { left: 40, right: 40, top: 24, bottom: 32 };\n  const hasCastMarkers = castMarkers && castMarkers.length > 0;\n  const castTrackHeight = hasCastMarkers ? 28 : 0;\n  const laneHeight = height - padding.top - padding.bottom;\n  const eventAreaTop = padding.top + 20; // Leave room for era labels\n  const eventAreaHeight = laneHeight - 20 - castTrackHeight;\n  const castBaselineY = eventAreaTop + eventAreaHeight + 4;\n  const castMarkerCenterY = castBaselineY + 12;\n\n  // Use provided extent or compute from events as fallback\n  const extent = useMemo(() => {\n    if (extentProp) return extentProp;\n    return computeTimelineExtent(events.map((e) => ({ tick: e.tick }) as any));\n  }, [extentProp, events]);\n\n  // Scale functions\n  const scaleX = useCallback(\n    (tick: number) => tickToX(tick, extent, width, padding.left),\n    [extent, width, padding.left]\n  );\n\n  // Position events to avoid overlap using simple row allocation\n  const eventPositions = useMemo(() => {\n    const positions = new Map<string, { x: number; y: number; height: number; row: number }>();\n    const rows: Array<{ endX: number }> = [];\n    const eventWidth = 24;\n    const eventGap = 4;\n\n    // Sort by tick\n    const sorted = [...events].sort((a, b) => a.tick - b.tick);\n\n    for (const event of sorted) {\n      const x = scaleX(event.tick);\n      const eventHeight = getEventHeight(event.significance, 50, 20);\n\n      // Find first available row\n      let row = 0;\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].endX + eventGap < x) {\n          row = i;\n          break;\n        }\n        row = i + 1;\n      }\n\n      // Ensure row exists\n      while (rows.length <= row) {\n        rows.push({ endX: 0 });\n      }\n      rows[row].endX = x + eventWidth;\n\n      // Calculate y position (stack from bottom)\n      const y = eventAreaTop + eventAreaHeight - eventHeight - row * 12;\n\n      positions.set(event.id, { x, y, height: eventHeight, row });\n    }\n\n    return positions;\n  }, [events, scaleX, eventAreaTop, eventAreaHeight]);\n\n  // Generate tick marks\n  const tickMarks = useMemo(() => {\n    const [minTick, maxTick] = extent;\n    const range = maxTick - minTick;\n    const step = Math.ceil(range / 8);\n    const marks: number[] = [];\n\n    for (let tick = Math.ceil(minTick / step) * step; tick <= maxTick; tick += step) {\n      marks.push(tick);\n    }\n\n    return marks;\n  }, [extent]);\n\n  const handleEventClick = useCallback(\n    (e: React.MouseEvent, eventId: string) => {\n      e.stopPropagation();\n      onToggleEvent(eventId);\n    },\n    [onToggleEvent]\n  );\n\n  const handleEventHover = useCallback((event: TimelineEvent | null, e?: React.MouseEvent) => {\n    if (event && e && svgRef.current) {\n      const rect = svgRef.current.getBoundingClientRect();\n      setHoveredEvent({\n        event,\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    } else {\n      setHoveredEvent(null);\n    }\n  }, []);\n\n  return (\n    <div className=\"nt-wrap\">\n      <svg\n        ref={svgRef}\n        width={width}\n        height={height}\n        className=\"nt-svg\"\n      >\n        {/* Era bands */}\n        {eraRanges.map((era) => {\n          // Clamp era boundaries to the usable timeline area\n          const x1 = Math.max(scaleX(era.startTick), padding.left);\n          const x2 = Math.min(scaleX(era.endTick), width - padding.right);\n          const isFocal = focalEraId === era.id;\n          const bandWidth = x2 - x1;\n\n          // Skip eras that fall entirely outside the visible range\n          if (bandWidth <= 0) return null;\n\n          return (\n            <g key={era.id}>\n              {/* Era background band */}\n              <rect\n                x={x1}\n                y={padding.top}\n                width={bandWidth}\n                height={laneHeight}\n                fill={era.color}\n                opacity={isFocal ? 0.15 : 0.08}\n              />\n              {/* Era divider line */}\n              <line\n                x1={x1}\n                y1={padding.top}\n                x2={x1}\n                y2={height - padding.bottom}\n                stroke={era.color}\n                strokeWidth={isFocal ? 2 : 1}\n                strokeDasharray={isFocal ? \"none\" : \"4,4\"}\n              />\n              {/* Era label */}\n              <text\n                x={x1 + 6}\n                y={padding.top + 14}\n                fontSize=\"10\"\n                fontWeight={isFocal ? 600 : 400}\n                fill={era.color}\n              >\n                {era.name}\n                {isFocal && \" \u2605\"}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Timeline axis */}\n        <line\n          x1={padding.left}\n          y1={height - padding.bottom}\n          x2={width - padding.right}\n          y2={height - padding.bottom}\n          stroke=\"var(--border-color)\"\n          strokeWidth={1}\n        />\n\n        {/* Tick marks */}\n        {tickMarks.map((tick) => {\n          const x = scaleX(tick);\n          return (\n            <g key={tick}>\n              <line\n                x1={x}\n                y1={height - padding.bottom}\n                x2={x}\n                y2={height - padding.bottom + 4}\n                stroke=\"var(--text-muted)\"\n                strokeWidth={1}\n              />\n              <text\n                x={x}\n                y={height - padding.bottom + 16}\n                textAnchor=\"middle\"\n                fontSize=\"9\"\n                fill=\"var(--text-muted)\"\n              >\n                {tick}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Event cards */}\n        {events.map((event) => {\n          const pos = eventPositions.get(event.id);\n          if (!pos) return null;\n\n          const fill = getEventFill(event);\n          const cardWidth = 20;\n\n          return (\n            <g\n              key={event.id}\n              className=\"nt-cursor-pointer\"\n              onClick={(e) => handleEventClick(e, event.id)}\n              onMouseEnter={(e) => handleEventHover(event, e)}\n              onMouseLeave={() => handleEventHover(null)}\n            >\n              {/* Event card */}\n              <rect\n                x={pos.x - cardWidth / 2}\n                y={pos.y}\n                width={cardWidth}\n                height={pos.height}\n                rx={3}\n                fill={fill}\n                opacity={event.selected ? 1 : 0.4}\n                stroke={event.selected ? \"white\" : \"transparent\"}\n                strokeWidth={event.selected ? 2 : 0}\n              />\n              {/* Selection checkmark */}\n              {event.selected && (\n                <text\n                  x={pos.x}\n                  y={pos.y + pos.height / 2 + 4}\n                  textAnchor=\"middle\"\n                  fontSize=\"12\"\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  className=\"nt-no-pointer\"\n                >\n                  \u2713\n                </text>\n              )}\n            </g>\n          );\n        })}\n\n        {/* Cast creation markers */}\n        {hasCastMarkers && (\n          <g>\n            {/* Dashed baseline */}\n            <line\n              x1={padding.left}\n              y1={castBaselineY}\n              x2={width - padding.right}\n              y2={castBaselineY}\n              stroke=\"var(--border-color)\"\n              strokeWidth={1}\n              strokeDasharray=\"4,3\"\n            />\n            {/* \"Cast\" label */}\n            <text\n              x={padding.left - 4}\n              y={castMarkerCenterY + 3}\n              textAnchor=\"end\"\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n            >\n              Cast\n            </text>\n            {/* Markers */}\n            {castMarkers.map((marker) => {\n              if (typeof marker.createdAt !== \"number\" || Number.isNaN(marker.createdAt))\n                return null;\n              const x = scaleX(marker.createdAt);\n              const shape = getCastMarkerShape(marker.entityKind);\n              const color = getCastMarkerColor(marker.entityKind);\n              const isHovered = hoveredCastMarker?.marker.entityId === marker.entityId;\n\n              return (\n                <g\n                  key={marker.entityId}\n                  className=\"nt-cursor-pointer\"\n                  onMouseEnter={(e) => {\n                    if (svgRef.current) {\n                      const rect = svgRef.current.getBoundingClientRect();\n                      setHoveredCastMarker({\n                        marker,\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                      });\n                    }\n                  }}\n                  onMouseLeave={() => setHoveredCastMarker(null)}\n                >\n                  {/* Vertical tick from baseline to marker */}\n                  <line\n                    x1={x}\n                    y1={castBaselineY}\n                    x2={x}\n                    y2={castMarkerCenterY - shape.size / 2}\n// ... (truncated)", "parameters": [{"name": "{\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}", "type": "Readonly<NarrativeTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "svg", "children": [{"tag": "g", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "line", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "line", "children": [], "isMap": false, "isConditional": false}, {"tag": "g", "children": [{"tag": "line", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "g", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}, {"tag": "g", "children": [{"tag": "line", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}, {"tag": "g", "children": [{"tag": "line", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": true}, {"tag": "circle", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 2}, {"name": "useMemo", "count": 3}, {"name": "useCallback", "count": 3}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::FilterChips", "name": "FilterChips", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function FilterChips<T extends string>({\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}: Readonly<FilterChipsProps<T>>) {\n  const handleChipClick = (option: T) => {\n    const newSelected = new Set(selected);\n\n    if (newSelected.has(option)) {\n      newSelected.delete(option);\n    } else {\n      if (!multiSelect) {\n        newSelected.clear();\n      }\n      newSelected.add(option);\n    }\n\n    onSelectionChange(newSelected);\n  };\n\n  const handleClearAll = () => {\n    onSelectionChange(new Set());\n  };\n\n  const getChipColor = (option: T): string => {\n    if (getColor) return getColor(option);\n    return KIND_COLORS[option.toLowerCase()] || \"var(--accent-color)\";\n  };\n\n  const getDisplayLabel = (option: T): string => {\n    if (formatLabel) return formatLabel(option);\n    // Capitalize first letter\n    return option.charAt(0).toUpperCase() + option.slice(1);\n  };\n\n  return (\n    <div className=\"fc-wrap\">\n      {label && (\n        <div className=\"fc-header\">\n          <span className=\"fc-label\">\n            {label}\n          </span>\n          {selected.size > 0 && (\n            <button\n              onClick={handleClearAll}\n              className=\"fc-clear-btn\"\n            >\n              Clear\n            </button>\n          )}\n        </div>\n      )}\n\n      <div className=\"fc-chips\">\n        {options.map((option) => {\n          const isSelected = selected.has(option);\n          const color = getChipColor(option);\n\n          return (\n            <button\n              key={option}\n              onClick={() => handleChipClick(option)}\n              className=\"fc-chip\"\n              style={{\n                '--fc-chip-border': isSelected ? `1px solid ${color}` : \"1px solid var(--border-color)\",\n                '--fc-chip-bg': isSelected ? color : \"transparent\",\n                '--fc-chip-color': isSelected ? \"white\" : \"var(--text-secondary)\",\n                '--fc-chip-weight': isSelected ? 500 : 400,\n              } as React.CSSProperties}\n            >\n              {/* Color dot when not selected */}\n              {!isSelected && (\n                <span\n                  className=\"fc-chip-dot\"\n                  style={{\n                    '--fc-dot-bg': color,\n                  } as React.CSSProperties}\n                />\n              )}\n              {getDisplayLabel(option)}\n            </button>\n          );\n        })}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}", "type": "Readonly<FilterChipsProps<T>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryPotentialRadar", "name": "StoryPotentialRadar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function StoryPotentialRadar({\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}: Readonly<StoryPotentialRadarProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const maxRadius = size / 2 - (showLabels ? 28 : 8);\n  const numAxes = AXES.length;\n  const angleStep = (2 * Math.PI) / numAxes;\n  // Start from top (-90 degrees)\n  const startAngle = -Math.PI / 2;\n\n  // Compute axis endpoints\n  const axisPoints = useMemo(() => {\n    return AXES.map((_, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + maxRadius * Math.cos(angle),\n        y: cy + maxRadius * Math.sin(angle),\n        labelX: cx + (maxRadius + 14) * Math.cos(angle),\n        labelY: cy + (maxRadius + 14) * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Compute polygon points for the data\n  const dataPoints = useMemo(() => {\n    return AXES.map((axis, i) => {\n      const value = potential[axis.key as keyof StoryPotential];\n      const radius = value * maxRadius;\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n        value,\n        label: axis.label,\n      };\n    });\n  }, [potential, cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Build polygon path\n  const polygonPath =\n    dataPoints.map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x} ${p.y}`).join(\" \") + \" Z\";\n\n  // Grid rings (25%, 50%, 75%, 100%)\n  const gridRings = [0.25, 0.5, 0.75, 1];\n\n  return (\n    <svg width={size} height={size} className=\"spr-svg\">\n      {/* Background */}\n      <circle cx={cx} cy={cy} r={maxRadius} fill=\"var(--bg-tertiary)\" />\n\n      {/* Grid rings */}\n      {gridRings.map((ring) => (\n        <circle\n          key={ring}\n          cx={cx}\n          cy={cy}\n          r={maxRadius * ring}\n          fill=\"none\"\n          stroke=\"var(--border-color)\"\n          strokeWidth={ring === 1 ? 1 : 0.5}\n          strokeDasharray={ring === 1 ? \"none\" : \"2,2\"}\n        />\n      ))}\n\n      {/* Axis lines */}\n      {axisPoints.map((point, i) => (\n        <line\n          key={i}\n          x1={cx}\n          y1={cy}\n          x2={point.x}\n          y2={point.y}\n          stroke=\"var(--border-color)\"\n          strokeWidth={0.5}\n        />\n      ))}\n\n      {/* Data polygon */}\n      <path\n        d={polygonPath}\n        fill=\"rgba(99, 102, 241, 0.3)\"\n        stroke=\"var(--accent-color)\"\n        strokeWidth={2}\n      />\n\n      {/* Data points */}\n      {dataPoints.map((point, i) => (\n        <g key={i}>\n          <circle\n            cx={point.x}\n            cy={point.y}\n            r={4}\n            fill=\"var(--accent-color)\"\n            stroke=\"white\"\n            strokeWidth={1.5}\n          />\n          {interactive && <title>{`${point.label}: ${(point.value * 100).toFixed(0)}%`}</title>}\n        </g>\n      ))}\n\n      {/* Axis labels */}\n      {showLabels &&\n        axisPoints.map((point, i) => {\n          const axis = AXES[i];\n\n          // Adjust text anchor based on position\n          let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n          if (point.labelX < cx - 10) textAnchor = \"end\";\n          else if (point.labelX > cx + 10) textAnchor = \"start\";\n\n          // Adjust vertical position\n          let dy = 4;\n          if (point.labelY < cy - maxRadius * 0.5) dy = 12;\n          else if (point.labelY > cy + maxRadius * 0.5) dy = -2;\n\n          return (\n            <text\n              key={i}\n              x={point.labelX}\n              y={point.labelY}\n              dy={dy}\n              textAnchor={textAnchor}\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n              fontFamily=\"inherit\"\n            >\n              {axis.shortLabel}\n            </text>\n          );\n        })}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}", "type": "Readonly<StoryPotentialRadarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": true, "isConditional": false}, {"tag": "line", "children": [], "isMap": true, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "g", "children": [{"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "title", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryPotentialRadarWithScore", "name": "StoryPotentialRadarWithScore", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Radar chart with score displayed below\n */\nexport function StoryPotentialRadarWithScore({\n  potential,\n  size = 160,\n}: Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>) {\n  return (\n    <div className=\"spr-with-score\">\n      <StoryPotentialRadar potential={potential} size={size} />\n      <div className=\"spr-score-wrap\">\n        <div className=\"spr-score-number\">\n          {(potential.overallScore * 100).toFixed(0)}\n        </div>\n        <div className=\"spr-score-label\">\n          Story Score\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n}", "type": "Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "StoryPotentialRadar", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryScoreBar", "name": "StoryScoreBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Compact score bar for list items\n */\nexport function StoryScoreBar({\n  score,\n  width = 60,\n  height = 8,\n}: Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>) {\n  const fillWidth = score * width;\n\n  return (\n    <svg width={width} height={height} className=\"spr-svg\">\n      {/* Background */}\n      <rect x={0} y={0} width={width} height={height} rx={height / 2} fill=\"var(--bg-tertiary)\" />\n      {/* Fill */}\n      <rect\n        x={0}\n        y={0}\n        width={fillWidth}\n        height={height}\n        rx={height / 2}\n        fill=\"var(--accent-color)\"\n      />\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  score,\n  width = 60,\n  height = 8,\n}", "type": "Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryScoreDots", "name": "StoryScoreDots", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Dot rating display (1-5 filled dots)\n */\nexport function StoryScoreDots({ score, maxDots = 5 }: Readonly<{ score: number; maxDots?: number }>) {\n  const filledDots = Math.max(1, Math.min(maxDots, Math.round(score * maxDots)));\n\n  return (\n    <div className=\"spr-dots\">\n      {Array.from({ length: maxDots }).map((_, i) => (\n        <span\n          key={i}\n          className={`spr-dot ${i < filledDots ? \"spr-dot-filled\" : \"spr-dot-empty\"}`}\n        />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ score, maxDots = 5 }", "type": "Readonly<{ score: number; maxDots?: number }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::MiniConstellation", "name": "MiniConstellation", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function MiniConstellation({\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}: Readonly<MiniConstellationProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const centerRadius = 16;\n  const nodeRadius = 10;\n  const orbitRadius = size / 2 - nodeRadius - 12;\n\n  // Limit and arrange connections\n  const visibleConnections = useMemo(() => {\n    // Group by kind and take most diverse sample\n    const byKind = new Map<string, ConnectedEntity[]>();\n    for (const conn of connections) {\n      const list = byKind.get(conn.kind) || [];\n      list.push(conn);\n      byKind.set(conn.kind, list);\n    }\n\n    // Take one from each kind first, then fill remaining\n    const result: ConnectedEntity[] = [];\n    const kindIterators = [...byKind.values()].map((list) => list[Symbol.iterator]());\n\n    while (result.length < maxConnections && kindIterators.length > 0) {\n      for (let i = kindIterators.length - 1; i >= 0; i--) {\n        if (result.length >= maxConnections) break;\n        const next = kindIterators[i].next();\n        if (next.done) {\n          kindIterators.splice(i, 1);\n        } else {\n          result.push(next.value);\n        }\n      }\n    }\n\n    return result;\n  }, [connections, maxConnections]);\n\n  const hiddenCount = connections.length - visibleConnections.length;\n\n  // Position nodes in a circle\n  const nodePositions = useMemo(() => {\n    const count = visibleConnections.length;\n    if (count === 0) return [];\n\n    const angleStep = (2 * Math.PI) / count;\n    const startAngle = -Math.PI / 2; // Start from top\n\n    return visibleConnections.map((conn, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        ...conn,\n        x: cx + orbitRadius * Math.cos(angle),\n        y: cy + orbitRadius * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [visibleConnections, cx, cy, orbitRadius]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (connections.length === 0) {\n    return (\n      <svg width={size} height={size} className=\"mc-svg\">\n        {/* Center node */}\n        <circle cx={cx} cy={cy} r={centerRadius} fill=\"var(--accent-color)\" />\n        <text x={cx} y={cy} textAnchor=\"middle\" dy={3} fontSize=\"10\" fill=\"white\" fontWeight=\"500\">\n          \u2605\n        </text>\n        <text\n          x={cx}\n          y={cy + centerRadius + 14}\n          textAnchor=\"middle\"\n          fontSize=\"9\"\n          fill=\"var(--text-muted)\"\n        >\n          No connections\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={size} height={size} className=\"mc-svg\">\n      {/* Connection lines */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n        const strength = node.strength ?? 0.5;\n\n        return (\n          <line\n            key={i}\n            x1={cx}\n            y1={cy}\n            x2={node.x}\n            y2={node.y}\n            stroke={color}\n            strokeWidth={1 + strength * 2}\n            strokeOpacity={0.4 + strength * 0.4}\n          />\n        );\n      })}\n\n      {/* Outer nodes */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n\n        return (\n          <g key={i}>\n            {/* Node circle */}\n            <circle cx={node.x} cy={node.y} r={nodeRadius} fill={color} opacity={0.9} />\n            {/* Kind initial */}\n            <text\n              x={node.x}\n              y={node.y}\n              textAnchor=\"middle\"\n              dy={3}\n              fontSize=\"8\"\n              fill=\"white\"\n              fontWeight=\"500\"\n            >\n              {node.kind.charAt(0).toUpperCase()}\n            </text>\n            {/* Name label */}\n            <title>{`${node.name} (${node.kind})\\n${node.relationshipKind}`}</title>\n          </g>\n        );\n      })}\n\n      {/* Center node (entry point) */}\n      <circle\n        cx={cx}\n        cy={cy}\n        r={centerRadius}\n        fill=\"var(--accent-color)\"\n        stroke=\"white\"\n        strokeWidth={2}\n      />\n      <text x={cx} y={cy} textAnchor=\"middle\" dy={4} fontSize=\"12\" fill=\"white\" fontWeight=\"600\">\n        \u2605\n      </text>\n\n      {/* Center label */}\n      <text x={cx} y={size - 6} textAnchor=\"middle\" fontSize=\"9\" fill=\"var(--text-muted)\">\n        {visibleConnections.length} connections\n        {hiddenCount > 0 && ` (+${hiddenCount})`}\n      </text>\n\n      {/* Legend - show unique kinds */}\n      {(() => {\n        const uniqueKinds = [...new Set(visibleConnections.map((c) => c.kind))];\n        if (uniqueKinds.length <= 4) {\n          return (\n            <g>\n              {uniqueKinds.map((kind, i) => (\n                <g key={kind} transform={`translate(${4 + i * 40}, 4)`}>\n                  <circle cx={4} cy={6} r={4} fill={getKindColor(kind)} />\n                  <text x={12} y={9} fontSize=\"8\" fill=\"var(--text-muted)\">\n                    {kind.slice(0, 4)}\n                  </text>\n                </g>\n              ))}\n            </g>\n          );\n        }\n        return null;\n      })()}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}", "type": "Readonly<MiniConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EnsembleConstellation", "name": "EnsembleConstellation", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EnsembleConstellation({\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}: Readonly<EnsembleConstellationProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);\n\n  // Compute layout\n  const nodes = useMemo(() => {\n    const layout = computeLayout(entryPointId, candidates, metricsMap, width, height);\n    const candidateMap = new Map(candidates.map((c) => [c.id, c]));\n    return layout.map((node) => {\n      const candidate = candidateMap.get(node.id);\n      const eraId = candidate?.eraId && candidate.eraId.length > 0 ? candidate.eraId : undefined;\n      return {\n        ...node,\n        isAssigned: assignedEntityIds.has(node.id),\n        eraColor: eraId ? (eraColorMap?.get(eraId) ?? \"#6b7280\") : \"#6b7280\",\n      };\n    });\n  }, [entryPointId, candidates, metricsMap, width, height, assignedEntityIds, eraColorMap]);\n\n  const nodeMap = useMemo(() => {\n    return new Map(nodes.map((n) => [n.id, n]));\n  }, [nodes]);\n\n  // Compute edges\n  const edges = useMemo(() => {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n    return computeEdges(relationships, nodeIds);\n  }, [relationships, nodes]);\n\n  // Compute bridge nodes (unassigned nodes connected to 2+ unique assigned entities)\n  const bridgeNodeIds = useMemo(() => {\n    // Map entity ID -> set of unique assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of relationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    const bridges = new Set<string>();\n    for (const [id, assignedConnections] of connectedToAssigned) {\n      if (assignedConnections.size >= 2) bridges.add(id);\n    }\n    return bridges;\n  }, [relationships, assignedEntityIds]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  const handleNodeClick = useCallback(\n    (nodeId: string) => {\n      if (selectedEntityId === nodeId) {\n        onSelectEntity(null);\n      } else {\n        onSelectEntity(nodeId);\n      }\n    },\n    [selectedEntityId, onSelectEntity]\n  );\n\n  // Determine node visual properties\n  const getNodeStyle = (node: ConstellationNode) => {\n    const isSelected = selectedEntityId === node.id;\n    const isHovered = hoveredNodeId === node.id;\n    const metrics = node.metrics;\n\n    // Base size\n    let radius = node.isEntryPoint ? 18 : 12;\n    if (isSelected || isHovered) radius += 2;\n\n    // Overused indicator\n    const isOverused = metrics && metrics.usageCount >= 5;\n\n    return { radius, isOverused, isSelected, isHovered };\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"ec-svg\"\n    >\n      {/* Orbit guides */}\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.25}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.5}\n      />\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.42}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.3}\n      />\n\n      {/* Edges */}\n      {edges.map((edge, i) => {\n        const source = nodeMap.get(edge.source);\n        const target = nodeMap.get(edge.target);\n        if (!source || !target) return null;\n\n        const sourceAssigned = assignedEntityIds.has(edge.source);\n        const targetAssigned = assignedEntityIds.has(edge.target);\n        const sourceSelected = selectedEntityId === edge.source || hoveredNodeId === edge.source;\n        const targetSelected = selectedEntityId === edge.target || hoveredNodeId === edge.target;\n\n        // Determine edge color and style based on node states\n        let strokeColor = \"var(--border-color)\";\n        let strokeOpacity = 0.2;\n        let strokeWidth = 1 + edge.strength * 1.5;\n\n        if (sourceAssigned && targetAssigned) {\n          // Both assigned - green, prominent\n          strokeColor = \"var(--success)\";\n          strokeOpacity = 0.7;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if ((sourceAssigned && targetSelected) || (targetAssigned && sourceSelected)) {\n          // One assigned, one selected - orange/gold\n          strokeColor = \"var(--warning)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceSelected || targetSelected) {\n          // One selected, neither assigned - purple\n          strokeColor = \"var(--accent-color)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceAssigned || targetAssigned) {\n          // One assigned, not selected - cyan to show potential ensemble connections\n          strokeColor = \"#06b6d4\"; // cyan\n          strokeOpacity = 0.5;\n          strokeWidth = 1.5 + edge.strength * 1.5;\n        }\n\n        return (\n          <line\n            key={i}\n            x1={source.x}\n            y1={source.y}\n            x2={target.x}\n            y2={target.y}\n            stroke={strokeColor}\n            strokeWidth={strokeWidth}\n            strokeOpacity={strokeOpacity}\n          />\n        );\n      })}\n\n      {/* Nodes */}\n      {nodes.map((node) => {\n        const style = getNodeStyle(node);\n        const color = getKindColor(node.kind);\n\n        return (\n          <g\n            key={node.id}\n            className=\"ec-cursor-pointer\"\n            onClick={() => handleNodeClick(node.id)}\n            onMouseEnter={() => setHoveredNodeId(node.id)}\n            onMouseLeave={() => setHoveredNodeId(null)}\n          >\n            {/* Overused glow */}\n            {style.isOverused && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 4}\n                fill=\"none\"\n                stroke=\"var(--error)\"\n                strokeWidth={2}\n                opacity={0.6}\n              />\n            )}\n\n            {/* Selection ring */}\n            {style.isSelected && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 3}\n                fill=\"none\"\n                stroke=\"var(--accent-color)\"\n                strokeWidth={2}\n              />\n            )}\n\n            {/* Bridge indicator (unassigned node connected to 2+ assigned) */}\n            {!node.isAssigned && !node.isEntryPoint && bridgeNodeIds.has(node.id) && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"#f59e0b\"\n                strokeWidth={2}\n                strokeDasharray=\"2,2\"\n              />\n            )}\n\n            {/* Assigned indicator */}\n            {node.isAssigned && !node.isEntryPoint && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"var(--success)\"\n                strokeWidth={2}\n                strokeDasharray=\"3,2\"\n              />\n            )}\n\n            {/* Node circle with era-colored ring */}\n            <circle\n              cx={node.x}\n              cy={node.y}\n              r={style.radius}\n              fill={node.isEntryPoint ? \"var(--accent-color)\" : color}\n              stroke={style.isHovered ? \"white\" : node.eraColor}\n              strokeWidth={2}\n            />\n\n            {/* Entry point star */}\n            {node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={5}\n                fontSize=\"14\"\n                fill=\"white\"\n                fontWeight=\"bold\"\n                className=\"ec-no-pointer\"\n              >\n                \u2605\n              </text>\n            )}\n\n            {/* Kind initial for non-entry-point nodes */}\n            {!node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={4}\n                fontSize=\"9\"\n                fill=\"white\"\n                fontWeight=\"500\"\n                className=\"ec-no-pointer\"\n              >\n                {node.kind.charAt(0).toUpperCase()}\n              </text>\n            )}\n          </g>\n        );\n      })}\n\n      {/* Tooltip layer - rendered on top of all nodes */}\n      {(() => {\n        const tooltipNodeId = hoveredNodeId || selectedEntityId;\n        const tooltipNode = tooltipNodeId ? nodeMap.get(tooltipNodeId) : null;\n        if (!tooltipNode) return null;\n\n        const style = getNodeStyle(tooltipNode);\n        const metrics = tooltipNode.metrics;\n        const usageCount = metrics?.usageCount ?? 0;\n        const linksToEnsemble = (() => {\n          if (tooltipNode.isAssigned) return null; // Don't show for assigned\n          let count = 0;\n          for (const rel of relationships) {\n// ... (truncated)", "parameters": [{"name": "{\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}", "type": "Readonly<EnsembleConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "line", "children": [], "isMap": true, "isConditional": false}, {"tag": "g", "children": [{"tag": "circle", "children": [], "isMap": false, "isConditional": true}, {"tag": "circle", "children": [], "isMap": false, "isConditional": true}, {"tag": "circle", "children": [], "isMap": false, "isConditional": true}, {"tag": "circle", "children": [], "isMap": false, "isConditional": true}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "text", "children": [], "isMap": false, "isConditional": true}, {"tag": "text", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}, {"tag": "g", "children": [{"tag": "text", "children": [{"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}, {"tag": "tspan", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 1}, {"name": "useMemo", "count": 4}, {"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::RoleSlot", "name": "RoleSlot", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function RoleSlot({\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}: Readonly<RoleSlotProps>) {\n  const canAccept = hasSelection && !isAtMax;\n  const count = assignments.length;\n\n  const wrapClass = `rs-wrap ${canAccept ? \"rs-wrap-accept\" : isUnderMin ? \"rs-wrap-undermin\" : \"rs-wrap-default\"}`;\n\n  return (\n    <div\n      onClick={canAccept ? onAssign : undefined}\n      className={wrapClass}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      {/* Role header - single line */}\n      <div className={`rs-header ${assignments.length > 0 || canAccept ? \"rs-header-mb\" : \"\"}`}>\n        <div className=\"rs-name-row\">\n          <span className={`rs-role-name ${isUnderMin ? \"rs-role-name-error\" : \"rs-role-name-default\"}`}>\n            {role.role}\n          </span>\n          <span className={`rs-role-count ${isUnderMin ? \"rs-role-count-error\" : \"rs-role-count-default\"}`}>\n            {count}/{role.count.max}\n          </span>\n        </div>\n\n        {canAccept && (\n          <span className=\"rs-add-label\">\n            + Add\n          </span>\n        )}\n      </div>\n\n      {/* Assigned entities - visually distinct from header */}\n      {assignments.length > 0 && (\n        <div className=\"rs-assignments\">\n          {assignments.map((assignment) => (\n            <div\n              key={assignment.entityId}\n              className=\"rs-assignment-row\"\n              onClick={(e) => e.stopPropagation()}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              {/* Entity name */}\n              <span className=\"rs-entity-name\">\n                {assignment.entityName}\n                <span className=\"rs-entity-kind\">\n                  {assignment.entityKind}\n                </span>\n              </span>\n\n              {/* Primary/Support toggle - full text, more button-like */}\n              <button\n                onClick={() => onTogglePrimary(assignment.entityId)}\n                className={`rs-toggle-btn ${assignment.isPrimary ? \"rs-toggle-btn-primary\" : \"rs-toggle-btn-support\"}`}\n                title=\"Click to toggle primary/support\"\n              >\n                {assignment.isPrimary ? \"Primary\" : \"Support\"}\n              </button>\n\n              {/* Remove button */}\n              <button\n                onClick={() => onRemove(assignment.entityId)}\n                className=\"rs-remove-btn\"\n                title=\"Remove from role\"\n              >\n                \u00d7\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}", "type": "Readonly<RoleSlotProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EntityDetailCard", "name": "EntityDetailCard", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EntityDetailCard({\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}: Readonly<EntityDetailCardProps>) {\n  // Empty state\n  if (!entity) {\n    return (\n      <div className=\"edc-empty\">\n        <div className=\"edc-empty-sub\">No entity selected</div>\n        <div className=\"edc-empty-hint\">Click a node to see details</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edc-card\">\n      {/* Header - compact */}\n      <div className=\"edc-header\">\n        <div className=\"edc-name-row\">\n          {entity.name}\n          {isEntryPoint && (\n            <span className=\"edc-entry-badge\">\n              Entry\n            </span>\n          )}\n          {isAssigned && !isEntryPoint && (\n            <span className=\"edc-assigned-badge\">\n              Assigned\n            </span>\n          )}\n        </div>\n        <div className=\"edc-kind-line\">\n          {entity.kind}\n          {entity.subtype && ` \u00b7 ${entity.subtype}`}\n        </div>\n      </div>\n\n      {/* Metrics - two rows: stats on top, story effects below */}\n      {(metrics || eraName) && (\n        <div className=\"edc-metrics\">\n          {/* Row 1: Basic stats */}\n          <div className=\"edc-metric-row\">\n            {metrics && (\n              <>\n                <MetricChip\n                  label={(() => {\n                    if (metrics.distance === 0) return \"Entry\";\n                    if (metrics.distance === 1) return \"Direct\";\n                    if (metrics.distance >= 99) return \"Distant\";\n                    return `${metrics.distance}-hop`;\n                  })()}\n                />\n                <MetricChip\n                  label={`${metrics.usageCount}x used`}\n                  variant={(() => {\n                    if (metrics.usageCount >= 5) return \"error\" as const;\n                    if (metrics.usageCount >= 2) return \"warning\" as const;\n                    return \"default\" as const;\n                  })()}\n                />\n                <MetricChip label={`${(metrics.avgStrength * 100).toFixed(0)}% link`} />\n              </>\n            )}\n            {eraName && <MetricChip label={eraName} customColor={eraColor} />}\n          </div>\n          {/* Row 2: Story effects (always separate line) */}\n          {(metrics?.addsNewCategory || (metrics && metrics.newRelTypes > 0)) && (\n            <div className=\"edc-metric-row\">\n              {metrics?.addsNewCategory && <MetricChip label=\"+category\" variant=\"accent\" />}\n              {metrics && metrics.newRelTypes > 0 && (\n                <MetricChip label={`+${metrics.newRelTypes} rel`} variant=\"accent\" />\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}", "type": "Readonly<EntityDetailCardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EnsembleHealthBar", "name": "EnsembleHealthBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EnsembleHealthBar({\n  assignments,\n  candidates,\n  kindToCategory,\n}: Readonly<EnsembleHealthBarProps>) {\n  // Compute category stats\n  const stats = useMemo(() => {\n    // Get all unique categories from candidates\n    const allCategories = new Set<string>();\n    const kindMap = kindToCategory || new Map<string, string>();\n\n    for (const candidate of candidates) {\n      const category = kindMap.get(candidate.kind) || candidate.kind;\n      allCategories.add(category);\n    }\n\n    // Count assigned categories\n    const assignedCategories = new Map<string, number>();\n    for (const assignment of assignments) {\n      const category = kindMap.get(assignment.entityKind) || assignment.entityKind;\n      assignedCategories.set(category, (assignedCategories.get(category) || 0) + 1);\n    }\n\n    // Find missing categories\n    const missingCategories: string[] = [];\n    for (const category of allCategories) {\n      if (!assignedCategories.has(category)) {\n        missingCategories.push(category);\n      }\n    }\n\n    // Calculate coverage percentage\n    const coveredCount = assignedCategories.size;\n    const totalCount = allCategories.size;\n    const coveragePercent = totalCount > 0 ? (coveredCount / totalCount) * 100 : 0;\n\n    return {\n      categories: [...allCategories],\n      assignedCategories,\n      missingCategories,\n      coveragePercent,\n      coveredCount,\n      totalCount,\n    };\n  }, [assignments, candidates, kindToCategory]);\n\n  const getColor = (category: string): string => {\n    return CATEGORY_COLORS[category.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (stats.totalCount === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"ehb-wrap\">\n      {/* Header */}\n      <div className=\"ehb-header\">\n        <span className=\"ehb-title\">\n          Ensemble Diversity\n        </span>\n        <span\n          className=\"ehb-count\"\n          style={{\n            '--ehb-count-color': stats.coveragePercent === 100 ? \"var(--success)\" : \"var(--text-muted)\",\n          } as React.CSSProperties}\n        >\n          {stats.coveredCount}/{stats.totalCount} categories\n        </span>\n      </div>\n\n      {/* Segmented bar */}\n      <div className=\"ehb-bar\">\n        {stats.categories.map((category, i) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const width = `${100 / stats.totalCount}%`;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              title={`${category}: ${count} assigned`}\n              className=\"ehb-bar-segment\"\n              style={{\n                '--ehb-seg-width': width,\n                '--ehb-seg-bg': isCovered ? color : \"transparent\",\n                '--ehb-seg-opacity': isCovered ? 1 : 0.3,\n                '--ehb-seg-border': i < stats.categories.length - 1 ? \"1px solid var(--bg-tertiary)\" : \"none\",\n              } as React.CSSProperties}\n            />\n          );\n        })}\n      </div>\n\n      {/* Category legend */}\n      <div\n        className=\"ehb-legend\"\n        style={{\n          '--ehb-legend-mb': stats.missingCategories.length > 0 ? \"8px\" : \"0\",\n        } as React.CSSProperties}\n      >\n        {stats.categories.map((category) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              className=\"ehb-legend-item\"\n              style={{\n                '--ehb-item-color': isCovered ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                '--ehb-item-opacity': isCovered ? 1 : 0.6,\n              } as React.CSSProperties}\n            >\n              <span\n                className=\"ehb-legend-dot\"\n                style={{\n                  '--ehb-dot-bg': isCovered ? color : \"var(--bg-secondary)\",\n                  '--ehb-dot-border': isCovered ? \"none\" : `1px solid ${color}`,\n                } as React.CSSProperties}\n              />\n              <span className=\"ehb-legend-label\">\n                {category}\n                {count > 1 && ` (${count})`}\n              </span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Missing categories warning */}\n      {stats.missingCategories.length > 0 && (\n        <div className=\"ehb-warning\">\n          <span className=\"ehb-warning-icon\">\ud83d\udca1</span>\n          <span>\n            Consider adding:{\" \"}\n            {stats.missingCategories.map((cat, i) => (\n              <span key={cat}>\n                <span className=\"ehb-missing-cat\">{cat}</span>\n                {i < stats.missingCategories.length - 1 && \", \"}\n              </span>\n            ))}\n          </span>\n        </div>\n      )}\n\n      {/* All covered celebration */}\n      {stats.missingCategories.length === 0 && stats.totalCount > 1 && (\n        <div className=\"ehb-success\">\n          <span>\u2713</span>\n          <span>All categories represented - diverse ensemble!</span>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  assignments,\n  candidates,\n  kindToCategory,\n}", "type": "Readonly<EnsembleHealthBarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryPotentialRadarWithScore", "name": "StoryPotentialRadarWithScore", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Radar chart with score displayed below\n */\nexport function StoryPotentialRadarWithScore({\n  potential,\n  size = 160,\n}: Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>) {\n  return (\n    <div className=\"spr-with-score\">\n      <StoryPotentialRadar potential={potential} size={size} />\n      <div className=\"spr-score-wrap\">\n        <div className=\"spr-score-number\">\n          {(potential.overallScore * 100).toFixed(0)}\n        </div>\n        <div className=\"spr-score-label\">\n          Story Score\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n}", "type": "Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "StoryPotentialRadar", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryScoreBar", "name": "StoryScoreBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Compact score bar for list items\n */\nexport function StoryScoreBar({\n  score,\n  width = 60,\n  height = 8,\n}: Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>) {\n  const fillWidth = score * width;\n\n  return (\n    <svg width={width} height={height} className=\"spr-svg\">\n      {/* Background */}\n      <rect x={0} y={0} width={width} height={height} rx={height / 2} fill=\"var(--bg-tertiary)\" />\n      {/* Fill */}\n      <rect\n        x={0}\n        y={0}\n        width={fillWidth}\n        height={height}\n        rx={height / 2}\n        fill=\"var(--accent-color)\"\n      />\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  score,\n  width = 60,\n  height = 8,\n}", "type": "Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryScoreDots", "name": "StoryScoreDots", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Dot rating display (1-5 filled dots)\n */\nexport function StoryScoreDots({ score, maxDots = 5 }: Readonly<{ score: number; maxDots?: number }>) {\n  const filledDots = Math.max(1, Math.min(maxDots, Math.round(score * maxDots)));\n\n  return (\n    <div className=\"spr-dots\">\n      {Array.from({ length: maxDots }).map((_, i) => (\n        <span\n          key={i}\n          className={`spr-dot ${i < filledDots ? \"spr-dot-filled\" : \"spr-dot-empty\"}`}\n        />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ score, maxDots = 5 }", "type": "Readonly<{ score: number; maxDots?: number }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}], "storeAccess": []}]