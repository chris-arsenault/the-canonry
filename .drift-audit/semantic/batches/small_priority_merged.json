[{"id": "packages/image-store/src/hooks.ts::useImageUrl", "name": "useImageUrl", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load a single image URL on demand.\n * Returns { url, loading, error, metadata }.\n */\nexport function useImageUrl(\n  imageId: string | null | undefined,\n  size: ImageSize = 'thumb',\n): UseImageUrlResult {\n  const [url, setUrl] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<ImageEntryMetadata | null>(null);\n  const loadUrl = useImageStore((s) => s.loadUrl);\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  useEffect(() => {\n    if (!imageId || !initialized) {\n      setUrl(null);\n      setLoading(false);\n      setError(null);\n      setMetadata(null);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n    setError(null);\n\n    Promise.all([\n      loadUrl(imageId, size),\n      loadMetadata([imageId]),\n    ])\n      .then(([result, metaMap]) => {\n        if (cancelled) return;\n        if (result) {\n          setUrl(result);\n          setMetadata(metaMap.get(imageId) ?? null);\n        } else {\n          setError('Image not found');\n        }\n      })\n      .catch((err: unknown) => {\n        if (!cancelled) {\n          setError(err instanceof Error ? err.message : 'Failed to load image');\n        }\n      })\n      .finally(() => {\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [imageId, size, loadUrl, loadMetadata, initialized]);\n\n  return { url, loading, error, metadata };\n}", "parameters": [{"name": "imageId", "type": "string | null | undefined", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "UseImageUrlResult", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useImageStore", "count": 3}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/hooks.ts::useImageUrls", "name": "useImageUrls", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load multiple image URLs in batch.\n * Returns { urls: Map<imageId, url>, loading }.\n */\nexport function useImageUrls(\n  imageIds: (string | null | undefined)[],\n  size: ImageSize = 'thumb',\n): { urls: Map<string, string>; loading: boolean } {\n  const [urls, setUrls] = useState<Map<string, string>>(new Map());\n  const [loading, setLoading] = useState(false);\n  const loadUrls = useImageStore((s) => s.loadUrls);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setUrls(new Map());\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    void loadUrls(validIds, size).then((result) => {\n      if (!cancelled) {\n        setUrls(result);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, size, loadUrls, initialized]);\n\n  return { urls, loading };\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "{ urls: Map<string, string>; loading: boolean }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/hooks.ts::useImageMetadata", "name": "useImageMetadata", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load metadata (dimensions, entity info) for a set of image IDs.\n * Metadata is lightweight and cached in the store.\n */\nexport function useImageMetadata(\n  imageIds: (string | null | undefined)[],\n): Map<string, ImageEntryMetadata> {\n  const [metadata, setMetadata] = useState<Map<string, ImageEntryMetadata>>(\n    new Map(),\n  );\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  // Track previous idsKey to avoid re-fetching same data\n  const prevIdsKeyRef = useRef('');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setMetadata(new Map());\n      return;\n    }\n\n    // Skip if IDs haven't changed\n    if (idsKey === prevIdsKeyRef.current) return;\n    prevIdsKeyRef.current = idsKey;\n\n    let cancelled = false;\n\n    void loadMetadata(validIds).then((result) => {\n      if (!cancelled) {\n        setMetadata(result);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, loadMetadata, initialized]);\n\n  return metadata;\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}], "returnType": "Map<string, ImageEntryMetadata>", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/index.ts::useImageUrl", "name": "useImageUrl", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load a single image URL on demand.\n * Returns { url, loading, error, metadata }.\n */\nexport function useImageUrl(\n  imageId: string | null | undefined,\n  size: ImageSize = 'thumb',\n): UseImageUrlResult {\n  const [url, setUrl] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<ImageEntryMetadata | null>(null);\n  const loadUrl = useImageStore((s) => s.loadUrl);\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  useEffect(() => {\n    if (!imageId || !initialized) {\n      setUrl(null);\n      setLoading(false);\n      setError(null);\n      setMetadata(null);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n    setError(null);\n\n    Promise.all([\n      loadUrl(imageId, size),\n      loadMetadata([imageId]),\n    ])\n      .then(([result, metaMap]) => {\n        if (cancelled) return;\n        if (result) {\n          setUrl(result);\n          setMetadata(metaMap.get(imageId) ?? null);\n        } else {\n          setError('Image not found');\n        }\n      })\n      .catch((err: unknown) => {\n        if (!cancelled) {\n          setError(err instanceof Error ? err.message : 'Failed to load image');\n        }\n      })\n      .finally(() => {\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [imageId, size, loadUrl, loadMetadata, initialized]);\n\n  return { url, loading, error, metadata };\n}", "parameters": [{"name": "imageId", "type": "string | null | undefined", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "UseImageUrlResult", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useImageStore", "count": 3}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/image-store/src/index.ts::useImageUrls", "name": "useImageUrls", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load multiple image URLs in batch.\n * Returns { urls: Map<imageId, url>, loading }.\n */\nexport function useImageUrls(\n  imageIds: (string | null | undefined)[],\n  size: ImageSize = 'thumb',\n): { urls: Map<string, string>; loading: boolean } {\n  const [urls, setUrls] = useState<Map<string, string>>(new Map());\n  const [loading, setLoading] = useState(false);\n  const loadUrls = useImageStore((s) => s.loadUrls);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setUrls(new Map());\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    void loadUrls(validIds, size).then((result) => {\n      if (!cancelled) {\n        setUrls(result);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, size, loadUrls, initialized]);\n\n  return { urls, loading };\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "{ urls: Map<string, string>; loading: boolean }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/image-store/src/index.ts::useImageMetadata", "name": "useImageMetadata", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load metadata (dimensions, entity info) for a set of image IDs.\n * Metadata is lightweight and cached in the store.\n */\nexport function useImageMetadata(\n  imageIds: (string | null | undefined)[],\n): Map<string, ImageEntryMetadata> {\n  const [metadata, setMetadata] = useState<Map<string, ImageEntryMetadata>>(\n    new Map(),\n  );\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  // Track previous idsKey to avoid re-fetching same data\n  const prevIdsKeyRef = useRef('');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setMetadata(new Map());\n      return;\n    }\n\n    // Skip if IDs haven't changed\n    if (idsKey === prevIdsKeyRef.current) return;\n    prevIdsKeyRef.current = idsKey;\n\n    let cancelled = false;\n\n    void loadMetadata(validIds).then((result) => {\n      if (!cancelled) {\n        setMetadata(result);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, loadMetadata, initialized]);\n\n  return metadata;\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}], "returnType": "Map<string, ImageEntryMetadata>", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/narrative-store/src/index.ts::useEntityNarrativeEvents", "name": "useEntityNarrativeEvents", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useEntityNarrativeEvents(\n  entityId: string | null | undefined\n): NarrativeEvent[] {\n  const ensureEntityEvents = useNarrativeStore((state) => state.ensureEntityEvents);\n  const backend = useNarrativeStore((state) => state.backend);\n  const simulationRunId = useNarrativeStore((state) => state.simulationRunId);\n  useEffect(() => {\n    if (!entityId) return;\n    if (!backend || !simulationRunId) return;\n    void ensureEntityEvents(entityId);\n  }, [backend, entityId, ensureEntityEvents, simulationRunId]);\n\n  return useNarrativeStore(\n    (state) => (entityId ? state.eventsByEntity.get(entityId) ?? EMPTY_EVENTS : EMPTY_EVENTS)\n  );\n}", "parameters": [{"name": "entityId", "type": "string | null | undefined", "optional": false}], "returnType": "NarrativeEvent[]", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 4}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useNarrativeStatus", "name": "useNarrativeStatus", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useNarrativeStatus(): NarrativeStatus {\n  return useNarrativeStore((state) => state.status);\n}", "parameters": [], "returnType": "NarrativeStatus", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useNarrativeLoading", "name": "useNarrativeLoading", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useNarrativeLoading(): boolean {\n  return useNarrativeStore((state) => state.status.loading);\n}", "parameters": [], "returnType": "boolean", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useEntityNarrativeLoading", "name": "useEntityNarrativeLoading", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useEntityNarrativeLoading(entityId: string | null | undefined): boolean {\n  return useNarrativeStore((state) => {\n    if (!entityId) return false;\n    return state.loadingEntityIds.has(entityId);\n  });\n}", "parameters": [{"name": "entityId", "type": "string | null | undefined", "optional": false}], "returnType": "boolean", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useEntityNarrativeReady", "name": "useEntityNarrativeReady", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useEntityNarrativeReady(entityId: string | null | undefined): boolean {\n  return useNarrativeStore((state) => {\n    if (!entityId) return true;\n    return state.loadedEntityIds.has(entityId);\n  });\n}", "parameters": [{"name": "entityId", "type": "string | null | undefined", "optional": false}], "returnType": "boolean", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useAllNarrativeEvents", "name": "useAllNarrativeEvents", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useAllNarrativeEvents(): NarrativeEvent[] {\n  return useNarrativeStore((state) => Array.from(state.eventsById.values()));\n}", "parameters": [], "returnType": "NarrativeEvent[]", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useAllNarrativeEventsLoading", "name": "useAllNarrativeEventsLoading", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useAllNarrativeEventsLoading(): boolean {\n  return useNarrativeStore((state) => state.allEventsLoading);\n}", "parameters": [], "returnType": "boolean", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "packages/narrative-store/src/index.ts::useAllNarrativeEventsLoaded", "name": "useAllNarrativeEventsLoaded", "kind": "hook", "filePath": "packages/narrative-store/src/index.ts", "sourceCode": "export function useAllNarrativeEventsLoaded(): boolean {\n  return useNarrativeStore((state) => state.allEventsLoaded);\n}", "parameters": [], "returnType": "boolean", "jsxTree": null, "hookCalls": [{"name": "useNarrativeStore", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect"], "category": "framework"}, {"source": "zustand", "specifiers": ["create"], "category": "framework"}, {"source": "zustand/middleware", "specifiers": ["subscribeWithSelector"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}], "storeAccess": ["useNarrativeStore"]}, {"id": "apps/chronicler/webui/src/components/Ornaments.tsx::ParchmentTexture", "name": "ParchmentTexture", "kind": "component", "filePath": "apps/chronicler/webui/src/components/Ornaments.tsx", "sourceCode": "/* =========================================\n   ParchmentTexture component\n   Loads real parchment/vellum photos, processes\n   them through the canvas pipeline, and displays\n   as a repeating background with soft-light blend.\n   ========================================= */\n\nexport function ParchmentTexture({\n  className,\n  config = DEFAULT_PARCHMENT_CONFIG,\n  prebakedUrl\n}: Readonly<{\n  className?: string;\n  config?: ParchmentConfig;\n  /** Pre-baked tile URL \u2014 skips runtime canvas pipeline when provided */\n  prebakedUrl?: string;\n}>) {\n  const [textureUrl, setTextureUrl] = useState<string | null>(prebakedUrl ?? null);\n  const [prevUrl, setPrevUrl] = useState<string | null>(null);\n\n  // Regenerate when processing params change \u2014 opacity is CSS-only\n  // Skip entirely when a prebaked tile is provided\n  const genKey = JSON.stringify({\n    br: config.blurRadius,\n    ds: config.detailStrength\n  });\n  useEffect(() => {\n    if (prebakedUrl) return;\n    let cancelled = false;\n    async function generate() {\n      try {\n        const [parchmentImg, vellumImg] = await Promise.all([loadImage(parchmentSrc), loadImage(vellumSrc)]);\n        if (cancelled) return;\n\n        // Normalize both to working size\n        const pCanvas = drawScaled(parchmentImg, WORK_SIZE, WORK_SIZE);\n        const vCanvas = drawScaled(vellumImg, WORK_SIZE, WORK_SIZE);\n\n        // Pipeline: frequency blend \u2192 mirror tile\n        // Keep natural warm tones \u2014 soft-light blend adds organic warmth\n        const blended = frequencyBlend(pCanvas, vCanvas, config.blurRadius, config.detailStrength);\n        const tileable = mirrorTile(blended);\n        const url = await canvasToObjectURL(tileable);\n        if (!cancelled) {\n          setTextureUrl(url);\n        }\n      } catch (err) {\n        console.error(\"[ParchmentTexture] Failed to generate:\", err);\n      }\n    }\n    void generate();\n    return () => {\n      cancelled = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [prebakedUrl, genKey]);\n\n  // Revoke previous object URL to avoid memory leaks (only for generated URLs)\n  useEffect(() => {\n    if (prevUrl && prevUrl !== textureUrl && prevUrl !== prebakedUrl) {\n      URL.revokeObjectURL(prevUrl);\n    }\n    setPrevUrl(textureUrl);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [textureUrl]);\n\n  // Cleanup on unmount (only for generated URLs)\n  useEffect(() => {\n    return () => {\n      if (textureUrl && textureUrl !== prebakedUrl) URL.revokeObjectURL(textureUrl);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  if (!textureUrl) return null;\n\n  // Mirror tile is 2x WORK_SIZE\n  const tileSize = WORK_SIZE * 2;\n  return <div aria-hidden className={`${className ?? \"\"} ${ornStyles.parchmentTexture}`}\n  // eslint-disable-next-line local/no-inline-styles -- dynamic texture URL and opacity from canvas pipeline\n  style={{\n    \"--parchment-url\": `url(${textureUrl})`,\n    \"--parchment-size\": `${tileSize}px ${tileSize}px`,\n    \"--parchment-opacity\": config.opacity\n  } as React.CSSProperties} />;\n}", "parameters": [{"name": "{\n  className,\n  config = DEFAULT_PARCHMENT_CONFIG,\n  prebakedUrl\n}", "type": "Readonly<{\n  className?: string;\n  config?: ParchmentConfig;\n  /** Pre-baked tile URL \u2014 skips runtime canvas pipeline when provided */\n  prebakedUrl?: string;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element | null", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useEffect", "count": 3}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../assets/textures/parchment.jpg", "specifiers": ["parchmentSrc"], "category": "internal"}, {"source": "../assets/textures/vellum.jpg", "specifiers": ["vellumSrc"], "category": "internal"}, {"source": "./Ornaments.module.css", "specifiers": ["ornStyles"], "category": "internal"}], "storeAccess": []}, {"id": "apps/chronicler/webui/src/components/Ornaments.tsx::ParchmentDebugPanel", "name": "ParchmentDebugPanel", "kind": "component", "filePath": "apps/chronicler/webui/src/components/Ornaments.tsx", "sourceCode": "export function ParchmentDebugPanel({\n  config,\n  onChange\n}: Readonly<{\n  config: ParchmentConfig;\n  onChange: (c: ParchmentConfig) => void;\n}>) {\n  const [open, setOpen] = useState(false);\n  const set = useCallback((key: keyof ParchmentConfig, val: number) => {\n    onChange({\n      ...config,\n      [key]: val\n    });\n  }, [config, onChange]);\n  if (!open) return <button className={ornStyles.debugBtn} onClick={() => setOpen(true)}>\n        Parchment Config\n      </button>;\n  return <div className={ornStyles.debugPanel}>\n      <div className={ornStyles.debugHeader}>\n        <strong className={ornStyles.debugTitle}>Parchment Config</strong>\n        <button onClick={() => setOpen(false)} className={ornStyles.debugClose}>\n          \u2715\n        </button>\n      </div>\n\n      <Slider label=\"Opacity\" value={config.opacity} min={0} max={1} step={0.01} onChange={v => set(\"opacity\", v)} />\n      <Slider label=\"Blur radius\" value={config.blurRadius} min={2} max={20} step={1} onChange={v => set(\"blurRadius\", v)} />\n      <Slider label=\"Detail\" value={config.detailStrength} min={0} max={3} step={0.1} onChange={v => set(\"detailStrength\", v)} />\n\n      <button onClick={() => onChange({\n      ...DEFAULT_PARCHMENT_CONFIG\n    })} className={ornStyles.resetBtn}>\n        Reset Defaults\n      </button>\n    </div>;\n}", "parameters": [{"name": "{\n  config,\n  onChange\n}", "type": "Readonly<{\n  config: ParchmentConfig;\n  onChange: (c: ParchmentConfig) => void;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useCallback", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../assets/textures/parchment.jpg", "specifiers": ["parchmentSrc"], "category": "internal"}, {"source": "../assets/textures/vellum.jpg", "specifiers": ["vellumSrc"], "category": "internal"}, {"source": "./Ornaments.module.css", "specifiers": ["ornStyles"], "category": "internal"}], "storeAccess": []}, {"id": "apps/chronicler/webui/src/components/Ornaments.tsx::PageFrame", "name": "PageFrame", "kind": "component", "filePath": "apps/chronicler/webui/src/components/Ornaments.tsx", "sourceCode": "export function PageFrame({\n  className\n}: Readonly<{\n  className?: string;\n}>) {\n  return <div aria-hidden=\"true\" className={`${className ?? \"\"} ${ornStyles.pageFrame}`}>\n      {/* Top-left */}\n      <div className={ornStyles.cornerTopLeft}>\n        <ScrollCorner />\n      </div>\n      {/* Top-right */}\n      <div className={ornStyles.cornerTopRight}>\n        <ScrollCorner />\n      </div>\n      {/* Bottom-left */}\n      <div className={ornStyles.cornerBottomLeft}>\n        <ScrollCorner />\n      </div>\n      {/* Bottom-right */}\n      <div className={ornStyles.cornerBottomRight}>\n        <ScrollCorner />\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  className\n}", "type": "Readonly<{\n  className?: string;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "ScrollCorner", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ScrollCorner", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ScrollCorner", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ScrollCorner", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../assets/textures/parchment.jpg", "specifiers": ["parchmentSrc"], "category": "internal"}, {"source": "../assets/textures/vellum.jpg", "specifiers": ["vellumSrc"], "category": "internal"}, {"source": "./Ornaments.module.css", "specifiers": ["ornStyles"], "category": "internal"}], "storeAccess": []}, {"id": "apps/chronicler/webui/src/components/Ornaments.tsx::SectionDivider", "name": "SectionDivider", "kind": "component", "filePath": "apps/chronicler/webui/src/components/Ornaments.tsx", "sourceCode": "/* ===================\n   SectionDivider\n   Ornamental filigree for section headings. Gold scrollwork\n   with frost blue accent tendrils. Replaces Unicode \u2766.\n   =================== */\n\nexport function SectionDivider({\n  className\n}: Readonly<{\n  className?: string;\n}>) {\n  return <svg aria-hidden=\"true\" viewBox=\"0 0 200 24\" className={className} fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      {/* Center diamond */}\n      <path d=\"M100 4 L104 12 L100 20 L96 12 Z\" fill=\"#c49a5c\" opacity=\"0.7\" />\n\n      {/* Left scrollwork \u2014 gold main curve */}\n      <path d=\"M94 12 C85 12 78 6 65 6 C55 6 50 10 45 12 C40 14 35 14 28 12\" stroke=\"#c49a5c\" strokeWidth=\"1.2\" opacity=\"0.6\" strokeLinecap=\"round\" />\n      {/* Left frost accent tendril */}\n      <path d=\"M94 12 C87 14 80 18 68 16 C58 14 52 16 45 14\" stroke=\"#8ab4c4\" strokeWidth=\"0.8\" opacity=\"0.35\" strokeLinecap=\"round\" />\n\n      {/* Right scrollwork \u2014 gold main curve (mirrored) */}\n      <path d=\"M106 12 C115 12 122 6 135 6 C145 6 150 10 155 12 C160 14 165 14 172 12\" stroke=\"#c49a5c\" strokeWidth=\"1.2\" opacity=\"0.6\" strokeLinecap=\"round\" />\n      {/* Right frost accent tendril (mirrored) */}\n      <path d=\"M106 12 C113 14 120 18 132 16 C142 14 148 16 155 14\" stroke=\"#8ab4c4\" strokeWidth=\"0.8\" opacity=\"0.35\" strokeLinecap=\"round\" />\n\n      {/* Terminal frost dots */}\n      <circle cx=\"25\" cy=\"12\" r=\"1.5\" fill=\"#8ab4c4\" opacity=\"0.4\" />\n      <circle cx=\"175\" cy=\"12\" r=\"1.5\" fill=\"#8ab4c4\" opacity=\"0.4\" />\n    </svg>;\n}", "parameters": [{"name": "{\n  className\n}", "type": "Readonly<{\n  className?: string;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../assets/textures/parchment.jpg", "specifiers": ["parchmentSrc"], "category": "internal"}, {"source": "../assets/textures/vellum.jpg", "specifiers": ["vellumSrc"], "category": "internal"}, {"source": "./Ornaments.module.css", "specifiers": ["ornStyles"], "category": "internal"}], "storeAccess": []}, {"id": "apps/chronicler/webui/src/components/Ornaments.tsx::FrostEdge", "name": "FrostEdge", "kind": "component", "filePath": "apps/chronicler/webui/src/components/Ornaments.tsx", "sourceCode": "/* ===================\n   FrostEdge\n   Ice crystalline decorative band with a visible frost-blue\n   background gradient. Irregular crystal spikes grow from a\n   frosted bar. For infobox edges, hero image bottoms, etc.\n   =================== */\n\nexport function FrostEdge({\n  position = \"top\",\n  className\n}: Readonly<{\n  position?: \"top\" | \"bottom\";\n  className?: string;\n}>) {\n  return <svg aria-hidden=\"true\" viewBox=\"0 0 260 12\" className={[className ?? \"\", position === \"bottom\" ? ornStyles.frostFlipped : \"\"].filter(Boolean).join(\" \")} fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\">\n      {/* Frost background band \u2014 visible blue-tinted bar */}\n      <rect x=\"0\" y=\"6\" width=\"260\" height=\"6\" fill=\"#8ab4c4\" opacity=\"0.12\" />\n      {/* Frost gradient fade at the bar edge */}\n      <defs>\n        <linearGradient id={`frost-fade-${position}`} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n          <stop offset=\"0%\" stopColor=\"#8ab4c4\" stopOpacity=\"0\" />\n          <stop offset=\"60%\" stopColor=\"#8ab4c4\" stopOpacity=\"0.08\" />\n          <stop offset=\"100%\" stopColor=\"#8ab4c4\" stopOpacity=\"0.15\" />\n        </linearGradient>\n      </defs>\n      <rect x=\"0\" y=\"0\" width=\"260\" height=\"12\" fill={`url(#frost-fade-${position})`} />\n\n      {/* Crystal spikes \u2014 irregular heights, more prominent */}\n      <path d=\"M15,11 L17,5 L19,11 M35,11 L36,7 L37,11 M55,11 L57,2 L59,11\n           M75,11 L76,6 L77,11 M95,11 L97,1 L99,11 M115,11 L116,7 L117,11\n           M135,11 L137,0 L139,11 M155,11 L156,5 L157,11 M175,11 L177,2 L179,11\n           M195,11 L196,6 L197,11 M215,11 L217,1 L219,11 M240,11 L241,5 L242,11\" stroke=\"#8ab4c4\" strokeWidth=\"0.8\" opacity=\"0.4\" fill=\"none\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n      {/* Filled crystal highlights on tallest spikes */}\n      <path d=\"M55,11 L57,2 L59,11 Z\" fill=\"#8ab4c4\" opacity=\"0.06\" />\n      <path d=\"M95,11 L97,1 L99,11 Z\" fill=\"#8ab4c4\" opacity=\"0.06\" />\n      <path d=\"M135,11 L137,0 L139,11 Z\" fill=\"#a8ccd8\" opacity=\"0.08\" />\n      <path d=\"M175,11 L177,2 L179,11 Z\" fill=\"#8ab4c4\" opacity=\"0.06\" />\n      <path d=\"M215,11 L217,1 L219,11 Z\" fill=\"#8ab4c4\" opacity=\"0.06\" />\n\n      {/* Crystal tip dots \u2014 glint effect */}\n      <circle cx=\"57\" cy=\"2\" r=\"0.8\" fill=\"#a8ccd8\" opacity=\"0.5\" />\n      <circle cx=\"97\" cy=\"1\" r=\"0.9\" fill=\"#a8ccd8\" opacity=\"0.5\" />\n      <circle cx=\"137\" cy=\"0\" r=\"1.0\" fill=\"#d0e8f0\" opacity=\"0.6\" />\n      <circle cx=\"177\" cy=\"2\" r=\"0.8\" fill=\"#a8ccd8\" opacity=\"0.5\" />\n      <circle cx=\"217\" cy=\"1\" r=\"0.9\" fill=\"#a8ccd8\" opacity=\"0.5\" />\n    </svg>;\n}", "parameters": [{"name": "{\n  position = \"top\",\n  className\n}", "type": "Readonly<{\n  position?: \"top\" | \"bottom\";\n  className?: string;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxTree": {"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "defs", "children": [{"tag": "linearGradient", "children": [{"tag": "stop", "children": [], "isMap": false, "isConditional": false}, {"tag": "stop", "children": [], "isMap": false, "isConditional": false}, {"tag": "stop", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "rect", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "path", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}, {"tag": "circle", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../assets/textures/parchment.jpg", "specifiers": ["parchmentSrc"], "category": "internal"}, {"source": "../assets/textures/vellum.jpg", "specifiers": ["vellumSrc"], "category": "internal"}, {"source": "./Ornaments.module.css", "specifiers": ["ornStyles"], "category": "internal"}], "storeAccess": []}, {"id": "apps/chronicler/webui/src/hooks/useBreakpoint.ts::useBreakpoint", "name": "useBreakpoint", "kind": "hook", "filePath": "apps/chronicler/webui/src/hooks/useBreakpoint.ts", "sourceCode": "/**\n * Hook that returns the current breakpoint based on window width.\n * - mobile: < 640px\n * - tablet: 640-1023px\n * - desktop: >= 1024px\n */\nexport function useBreakpoint(): Breakpoint {\n  const [breakpoint, setBreakpoint] = useState<Breakpoint>(() =>\n    typeof window !== \"undefined\" ? getBreakpoint(window.innerWidth) : \"desktop\"\n  );\n\n  useEffect(() => {\n    function handleResize() {\n      setBreakpoint(getBreakpoint(window.innerWidth));\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return breakpoint;\n}", "parameters": [], "returnType": "Breakpoint", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useEffect"], "category": "framework"}], "storeAccess": []}, {"id": "apps/canonry/webui/src/storage/useProjectStorage.js::useProjectStorage", "name": "useProjectStorage", "kind": "hook", "filePath": "apps/canonry/webui/src/storage/useProjectStorage.js", "sourceCode": "export function useProjectStorage() {\n  const [projects, setProjects] = useState([]);\n  const [currentProject, setCurrentProject] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Load project list on mount\n  useEffect(() => {\n    async function init() {\n      try {\n        await openDatabase();\n        let list = await listProjects();\n\n        // If no projects exist, load the default seed project\n        if (list.length === 0) {\n          const defaultData = await fetchDefaultProject();\n          if (defaultData?.project) {\n            await saveProject(defaultData.project);\n            list = await listProjects();\n\n            // Store illuminatorConfig in worldStore if present\n            if (defaultData.illuminatorConfig) {\n              const worldStoreData = {\n                activeSlotIndex: 0,\n                ...defaultData.illuminatorConfig,\n              };\n              await saveWorldStore(defaultData.project.id, worldStoreData);\n            }\n          }\n        }\n\n        setProjects(list);\n\n        // Auto-load last opened project if possible, otherwise most recent\n        if (list.length > 0) {\n          const lastProjectId = loadLastProjectId();\n          if (lastProjectId) {\n            const project = await loadProject(lastProjectId);\n            if (project) {\n              setCurrentProject(project);\n              return;\n            }\n          }\n          const project = await loadProject(list[0].id);\n          setCurrentProject(project);\n        }\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n    init();\n  }, []);\n\n  useEffect(() => {\n    if (currentProject?.id) {\n      saveLastProjectId(currentProject.id);\n    } else {\n      saveLastProjectId(null);\n    }\n  }, [currentProject?.id]);\n\n  // Refresh project list\n  const refreshList = useCallback(async () => {\n    try {\n      const list = await listProjects();\n      setProjects(list);\n    } catch (err) {\n      setError(err.message);\n    }\n  }, []);\n\n  // Create new project\n  const createProject = useCallback(\n    async (name) => {\n      try {\n        const project = createEmptyProject(name);\n        await saveProject(project);\n        await refreshList();\n        setCurrentProject(project);\n        return project;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Open existing project\n  const openProject = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      const project = await loadProject(id);\n      if (project) {\n        setCurrentProject(project);\n      } else {\n        throw new Error(`Project ${id} not found`);\n      }\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Save current project (auto-save on changes)\n  // Uses ref to track pending updates and avoid stale closure issues\n  const pendingUpdatesRef = useRef({});\n\n  const save = useCallback(\n    async (updates = {}) => {\n      if (!currentProject) return;\n\n      try {\n        // Merge with any pending updates to handle rapid sequential saves\n        pendingUpdatesRef.current = { ...pendingUpdatesRef.current, ...updates };\n        const allUpdates = pendingUpdatesRef.current;\n\n        const updated = { ...currentProject, ...allUpdates };\n        await saveProject(updated);\n        setCurrentProject(updated);\n\n        // Clear pending updates after successful save\n        pendingUpdatesRef.current = {};\n        await refreshList();\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject, refreshList]\n  );\n\n  // Delete project\n  const removeProject = useCallback(\n    async (id) => {\n      try {\n        await deleteProject(id);\n        await refreshList();\n\n        // If deleted current project, switch to another\n        if (currentProject?.id === id) {\n          const list = await listProjects();\n          if (list.length > 0) {\n            const project = await loadProject(list[0].id);\n            setCurrentProject(project);\n          } else {\n            setCurrentProject(null);\n          }\n        }\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject, refreshList]\n  );\n\n  // Duplicate project\n  const duplicateProject = useCallback(\n    async (id) => {\n      try {\n        const source = await loadProject(id);\n        if (!source) throw new Error(`Project ${id} not found`);\n\n        const duplicate = {\n          ...source,\n          id: `project_${Date.now()}`,\n          name: `${source.name} (copy)`,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        };\n\n        await saveProject(duplicate);\n        await refreshList();\n        return duplicate;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Export project as a zip file (Blob)\n  // Includes Illuminator configuration from worldStore and static pages\n  const exportProject = useCallback(\n    async (project = currentProject) => {\n      if (!project) return null;\n      try {\n        // Load Illuminator config from worldStore\n        let illuminatorConfig = null;\n        const worldStore = await loadWorldStore(project.id);\n        if (worldStore) {\n          // Export entityGuidance and cultureIdentities at top level\n          illuminatorConfig = {\n            worldContext: worldStore.worldContext || null,\n            entityGuidance: worldStore.entityGuidance || null,\n            cultureIdentities: worldStore.cultureIdentities || null,\n            enrichmentConfig: worldStore.enrichmentConfig || null,\n            styleSelection: worldStore.styleSelection || null,\n            historianConfig: worldStore.historianConfig || null,\n          };\n          // Only include if there's actual data\n          const hasData = Object.values(illuminatorConfig).some((v) => v !== null);\n          if (!hasData) {\n            illuminatorConfig = null;\n          }\n        }\n\n        // Load static pages from IndexedDB\n        const staticPages = await getStaticPagesForProject(project.id);\n\n        const zipBlob = await createProjectZip(project, { illuminatorConfig, staticPages });\n        return zipBlob;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject]\n  );\n\n  // Import project from zip file (Blob or File)\n  // Restores Illuminator configuration to worldStore and imports static pages\n  const importProject = useCallback(\n    async (input) => {\n      try {\n        let extractedData;\n\n        // Check if input is a Blob/File (zip)\n        if (input instanceof Blob) {\n          extractedData = await extractProjectZip(input);\n        } else {\n          throw new Error(\"Invalid import format: expected zip file\");\n        }\n\n        const { project: data, illuminatorConfig, staticPages } = extractedData;\n\n        // Generate new ID to avoid conflicts\n        let project = {\n          ...data,\n          id: `project_${Date.now()}`,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        };\n\n        await saveProject(project);\n\n        // Restore Illuminator configuration to worldStore\n        if (illuminatorConfig) {\n          const worldStoreData = {\n            activeSlotIndex: 0,\n            ...illuminatorConfig,\n          };\n          await saveWorldStore(project.id, worldStoreData);\n        }\n\n        // Import static pages if present\n        if (staticPages && staticPages.length > 0) {\n          await importStaticPages(project.id, staticPages);\n        }\n\n        await refreshList();\n        setCurrentProject(project);\n        return project;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Reload current project from default files (merge overwrite)\n  // Only works for the default project\n  const reloadProjectFromDefaults = useCallback(async () => {\n    if (!currentProject) return null;\n    if (currentProject.id !== DEFAULT_PROJECT_ID) {\n      throw new Error(\"Can only reload the default project from defaults\");\n    }\n\n    try {\n      setLoading(true);\n\n      // Fetch fresh default project files\n      const defaultData = await fetchDefaultProject();\n      if (!defaultData?.project) {\n        throw new Error(\"Failed to load default project files\");\n      }\n\n      // Merge: use fresh data but preserve the current project's ID and timestamps\n      const reloaded = {\n        ...defaultData.project,\n        id: currentProject.id,\n        createdAt: currentProject.createdAt,\n        updatedAt: new Date().toISOString(),\n// ... (truncated)", "parameters": [], "returnType": "{ projects: any[]; currentProject: any; loading: boolean; error: any; createProject: (name: any) => Promise<{ id: string; name: string; version: string; createdAt: string; updatedAt: string; entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; axisDefinitions: any[]; uiConfig: { worldIcon: string; prominenceLevels: string[]; prominenceColors: { forgotten: string; marginal: string; recognized: string; renowned: string; mythic: string; }; }; eras: any[]; pressures: any[]; generators: any[]; systems: any[]; actions: any[]; seedEntities: any[]; seedRelationships: any[]; distributionTargets: any; simulation: any; }>; openProject: (id: any) => Promise<void>; save: (updates?: {}) => Promise<void>; removeProject: (id: any) => Promise<void>; duplicateProject: (id: any) => Promise<any>; exportProject: (project?: any) => Promise<Blob>; importProject: (input: any) => Promise<any>; reloadProjectFromDefaults: () => Promise<any>; refreshList: () => Promise<void>; DEFAULT_PROJECT_ID: string; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 9}, {"name": "useRef", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "./db.js", "specifiers": ["openDatabase", "saveProject", "loadProject", "deleteProject", "listProjects", "createEmptyProject"], "category": "internal"}, {"source": "./uiState.js", "specifiers": ["loadLastProjectId", "saveLastProjectId"], "category": "internal"}, {"source": "./worldStore.js", "specifiers": ["loadWorldStore", "saveWorldStore"], "category": "internal"}, {"source": "./staticPageStorage.js", "specifiers": ["getStaticPagesForProject", "importStaticPages", "loadAndImportSeedPages"], "category": "internal"}, {"source": "@canonry/dsl", "specifiers": ["compileCanonProject", "compileCanonStaticPages", "serializeCanonProject", "serializeCanonStaticPages"], "category": "external"}], "storeAccess": []}]