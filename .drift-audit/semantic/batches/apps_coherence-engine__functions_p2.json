[{"id": "apps/coherence-engine/webui/src/components/validation/index.js::getValidationStatus", "name": "getValidationStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/index.js", "sourceCode": "/**\n * Export validation status calculation for use by parent\n */\nexport function getValidationStatus(usageMap, schema, eras, pressures, generators, systems) {\n  const results = runValidations(\n    usageMap,\n    schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    eras || [],\n    pressures || [],\n    generators || [],\n    systems || []\n  );\n  return {\n    status: getOverallStatus(results),\n    errorCount: results.errors.length,\n    warningCount: results.warnings.length,\n    totalIssues: results.errors.length + results.warnings.length,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}], "returnType": "{ status: string; errorCount: number; warningCount: number; totalIssues: number; }"}, {"id": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx::getValidationStatus", "name": "getValidationStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx", "sourceCode": "/**\n * Export validation status calculation for use by parent\n */\nexport function getValidationStatus(usageMap, schema, eras, pressures, generators, systems) {\n  const results = runValidations(\n    usageMap,\n    schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    eras || [],\n    pressures || [],\n    generators || [],\n    systems || []\n  );\n  return {\n    status: getOverallStatus(results),\n    errorCount: results.errors.length,\n    warningCount: results.warnings.length,\n    totalIssues: results.errors.length + results.warnings.length,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}], "returnType": "{ status: string; errorCount: number; warningCount: number; totalIssues: number; }"}, {"id": "apps/coherence-engine/webui/src/components/weight-matrix/WeightMatrixEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/weight-matrix/WeightMatrixEditor.jsx", "sourceCode": "export default function WeightMatrixEditor({\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}) {\n  const [viewMode, setViewMode] = useState(\"generators\"); // 'generators' | 'systems'\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [editingCell, setEditingCell] = useState(null); // shape: rowId + eraId\n  const [editValue, setEditValue] = useState(\"\");\n  const [selectedRows, setSelectedRows] = useState(new Set());\n  const [copiedRow, setCopiedRow] = useState(null); // { id, weights: { eraId: value } }\n  const inputRef = useRef(null);\n\n  // Get current items based on view mode\n  const items = useMemo(() => {\n    const source = viewMode === \"generators\" ? generators : systems;\n    return source.map(item => ({\n      id: viewMode === \"generators\" ? item.id : item.config.id,\n      name: viewMode === \"generators\" ? item.name || item.id : item.config.name || item.config.id,\n      type: viewMode === \"generators\" ? \"generator\" : item.systemType\n    }));\n  }, [viewMode, generators, systems]);\n\n  // Detect orphaned references - IDs in eras that don't exist in generators/systems\n  const orphanedReferences = useMemo(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const orphanedGenerators = [];\n    const orphanedSystems = [];\n    eras.forEach(era => {\n      // Check template weights\n      Object.keys(era.templateWeights || {}).forEach(id => {\n        if (!generatorIds.has(id)) {\n          orphanedGenerators.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n\n      // Check system modifiers\n      Object.keys(era.systemModifiers || {}).forEach(id => {\n        if (!systemIds.has(id)) {\n          orphanedSystems.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n    });\n    return {\n      generators: orphanedGenerators,\n      systems: orphanedSystems\n    };\n  }, [eras, generators, systems]);\n\n  // Count total orphans\n  const totalOrphans = orphanedReferences.generators.length + orphanedReferences.systems.length;\n\n  // Clean up all orphaned references\n  const cleanupOrphanedReferences = useCallback(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const newEras = eras.map(era => {\n      const newTemplateWeights = {\n        ...era.templateWeights\n      };\n      const newSystemModifiers = {\n        ...era.systemModifiers\n      };\n\n      // Remove orphaned generator references\n      Object.keys(newTemplateWeights).forEach(id => {\n        if (!generatorIds.has(id)) {\n          delete newTemplateWeights[id];\n        }\n      });\n\n      // Remove orphaned system references\n      Object.keys(newSystemModifiers).forEach(id => {\n        if (!systemIds.has(id)) {\n          delete newSystemModifiers[id];\n        }\n      });\n      return {\n        ...era,\n        templateWeights: newTemplateWeights,\n        systemModifiers: newSystemModifiers\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, generators, systems, onErasChange]);\n\n  // Filter items by search\n  const filteredItems = useMemo(() => {\n    if (!searchQuery) return items;\n    const query = searchQuery.toLowerCase();\n    return items.filter(item => item.id.toLowerCase().includes(query) || item.name.toLowerCase().includes(query));\n  }, [items, searchQuery]);\n\n  // Get weight for an item in an era\n  const getWeight = useCallback((itemId, eraId) => {\n    const era = eras.find(e => e.id === eraId);\n    if (!era) return null;\n    const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n    return weights?.[itemId] ?? null;\n  }, [eras, viewMode]);\n\n  // Set weight for an item in an era\n  const setWeight = useCallback((itemId, eraId, value) => {\n    const newEras = eras.map(era => {\n      if (era.id !== eraId) return era;\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === \"\" || value === undefined) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = parseFloat(value) || 0;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, viewMode, onErasChange]);\n\n  // Handle cell click to start editing\n  const handleCellClick = (rowId, eraId) => {\n    const currentValue = getWeight(rowId, eraId);\n    setEditingCell({\n      rowId,\n      eraId\n    });\n    setEditValue(currentValue !== null ? String(currentValue) : \"\");\n    setTimeout(() => inputRef.current?.select(), 0);\n  };\n\n  // Handle cell edit completion\n  const handleCellBlur = () => {\n    if (editingCell) {\n      const value = editValue.trim();\n      if (value === \"\") {\n        setWeight(editingCell.rowId, editingCell.eraId, null);\n      } else {\n        const numValue = parseFloat(value);\n        if (!isNaN(numValue)) {\n          setWeight(editingCell.rowId, editingCell.eraId, numValue);\n        }\n      }\n      setEditingCell(null);\n    }\n  };\n\n  // Handle keyboard navigation\n  const handleKeyDown = e => {\n    if (e.key === \"Enter\" || e.key === \"Tab\") {\n      e.preventDefault();\n      handleCellBlur();\n    } else if (e.key === \"Escape\") {\n      setEditingCell(null);\n    }\n  };\n\n  // Apply weight to all eras for a row\n  const applyToAllEras = (itemId, value) => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === 0) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = value;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Copy row weights\n  const copyRow = itemId => {\n    const weights = {};\n    eras.forEach(era => {\n      const value = getWeight(itemId, era.id);\n      if (value !== null) {\n        weights[era.id] = value;\n      }\n    });\n    setCopiedRow({\n      id: itemId,\n      weights\n    });\n  };\n\n  // Paste row weights\n  const pasteRow = targetItemId => {\n    if (!copiedRow) return;\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (copiedRow.weights[era.id] !== undefined) {\n        weights[targetItemId] = copiedRow.weights[era.id];\n      } else {\n        delete weights[targetItemId];\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Remove from all eras\n  const removeFromAllEras = itemId => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      delete weights[itemId];\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Check if item is used in any era\n  const isUsedInAnyEra = itemId => {\n    return eras.some(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] !== undefined && weights[itemId] !== null;\n    });\n  };\n\n  // Count eras where item is active\n  const countActiveEras = itemId => {\n    return eras.filter(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] > 0;\n    }).length;\n  };\n\n  // Quick set weight for bulk operations\n  const [quickSetValue, setQuickSetValue] = useState(1);\n  const handleQuickSetSelected = () => {\n    const value = quickSetValue ?? 0;\n    selectedRows.forEach(itemId => {\n      applyToAllEras(itemId, value);\n    });\n    setSelectedRows(new Set());\n  };\n  const toggleRowSelection = itemId => {\n    const newSelection = new Set(selectedRows);\n    if (newSelection.has(itemId)) {\n      newSelection.delete(itemId);\n    } else {\n      newSelection.add(itemId);\n    }\n    setSelectedRows(newSelection);\n  };\n  const selectAllRows = () => {\n    if (selectedRows.size === filteredItems.length) {\n      setSelectedRows(new Set());\n    } else {\n      setSelectedRows(new Set(filteredItems.map(i => i.id)));\n    }\n  };\n  return <div className=\"weight-matrix-editor\">\n      <div className=\"header\">\n        <h1 className=\"title\">Weight Matrix</h1>\n        <p className=\"subtitle\">\n          Manage {viewMode} weights across all eras in a spreadsheet view. Click any cell to edit,\n          or use row actions for bulk operations.\n        </p>\n      </div>\n\n      {/* Orphaned References Warning */}\n      {totalOrphans > 0 && <div className=\"orphan-warning\">\n          <div className=\"orphan-warning-content\">\n            <span className=\"orphan-warning-icon\">\u26a0\ufe0f</span>\n            <div className=\"orphan-warning-text\">\n              <strong>\n                {totalOrphans} orphaned reference{totalOrphans !== 1 ? \"s\" : \"\"} detected\n              </strong>\n              <span className=\"orphan-warning-details\">\n// ... (truncated)", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}", "type": "{ generators?: any[]; systems?: any[]; eras?: any[]; onErasChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/actions/tabs/InstigatorTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/tabs/InstigatorTab.jsx", "sourceCode": "export function InstigatorTab({ action, onChange, schema }) {\n  const actor = action.actor || {};\n\n  const updateActor = (field, value) => {\n    onChange({\n      ...action,\n      actor: { ...actor, [field]: value },\n    });\n  };\n\n  const instigator = actor.instigator;\n  const hasInstigator = Boolean(instigator);\n\n  const addInstigator = () => {\n    updateActor(\"instigator\", { from: \"graph\", kind: \"\", pickStrategy: \"random\", required: false });\n  };\n\n  const updateInstigator = (updated) => {\n    updateActor(\"instigator\", updated);\n  };\n\n  const removeInstigator = () => {\n    updateActor(\"instigator\", undefined);\n  };\n\n  return (\n    <div>\n      <div className=\"info-box\">\n        <div className=\"info-box-title\">Instigator</div>\n        <div className=\"info-box-text\">\n          Configure optional instigator selection for this action.\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">\ud83d\udc64 Instigator (Optional)</div>\n        <div className=\"section-desc\">\n          An instigator can trigger the action on behalf of the actor (e.g., NPC leader acts for\n          their faction).\n        </div>\n\n        {!hasInstigator ? (\n          <div>\n            <div className=\"text-muted text-small mb-md\">\n              No instigator configured. The actor performs the action directly.\n            </div>\n            <button className=\"btn btn-add\" onClick={addInstigator}>\n              + Add Instigator\n            </button>\n          </div>\n        ) : (\n          <div>\n            <label className=\"checkbox-label mb-lg\">\n              <input\n                type=\"checkbox\"\n                checked={instigator.required || false}\n                onChange={(e) =>\n                  updateInstigator({ ...instigator, required: e.target.checked || undefined })\n                }\n                className=\"checkbox\"\n              />\n              Instigator required\n            </label>\n            <VariableSelectionEditor\n              value={instigator}\n              onChange={(updated) =>\n                updateInstigator({ ...updated, required: instigator.required })\n              }\n              schema={schema}\n              availableRefs={[\"$actor\"]}\n            />\n            <button\n              className=\"btn btn-danger-outline mt-lg\"\n              onClick={removeInstigator}\n            >\n              Remove Instigator\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onChange, schema }", "type": "{ action: any; onChange: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/actions/tabs/VariablesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/actions/tabs/VariablesTab.jsx", "sourceCode": "// ============================================================================\n// VariablesTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.action - The action being edited\n * @param {Function} props.onChange - Callback when action changes\n * @param {Object} props.schema - Domain schema\n */\nexport function VariablesTab({ action, onChange, schema }) {\n  const variables = action.variables || {};\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddForm, setShowAddForm] = useState(false);\n\n  // Build available refs for relationship queries (actor, instigator, target, target2 + other vars)\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$actor\", \"$instigator\", \"$target\", \"$target2\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    // Ensure the name starts with $\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    // Create with empty required fields - validation will flag them\n    onChange({\n      ...action,\n      variables: {\n        ...variables,\n        [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"\" } },\n      },\n    });\n    setNewVarName(\"\");\n    setShowAddForm(false);\n  };\n\n  const varEntries = Object.entries(variables);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Variables</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What are variables?</div>\n          <div className=\"info-box-text\">\n            Variables let you select additional entities from the graph to use in mutations. For\n            example, you might select a <code className=\"inline-code\">$victimFaction</code> to\n            create an enemy relationship with, or an <code className=\"inline-code\">$artifact</code>{\" \"}\n            to modify. Variables are resolved after <code className=\"inline-code\">$actor</code> and{\" \"}\n            <code className=\"inline-code\">$target</code> are chosen.\n          </div>\n        </div>\n\n        {varEntries.length === 0 && !showAddForm ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udce6</div>\n            <div className=\"empty-state-title\">No variables defined</div>\n            <div className=\"empty-state-desc\">\n              Add variables to select additional entities for use in mutations.\n            </div>\n          </div>\n        ) : (\n          varEntries.map(([name, config]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={config}\n              onChange={(updated) =>\n                onChange({ ...action, variables: { ...variables, [name]: updated } })\n              }\n              onRemove={() => {\n                const newVars = { ...variables };\n                delete newVars[name];\n                onChange({ ...action, variables: newVars });\n              }}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onChange, schema }", "type": "{ action: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/AddRuleButton.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/AddRuleButton.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onAdd - Callback when a rule type is selected\n * @param {number} props.depth - Nesting depth (limits nested rule types at depth >= 2)\n */\nexport function AddRuleButton({ onAdd, depth = 0 }) {\n  const [showPicker, setShowPicker] = useState(false);\n\n  return (\n    <div className=\"dropdown\">\n      <button className=\"btn-add\" onClick={() => setShowPicker(!showPicker)}>\n        + Add Rule\n      </button>\n\n      {showPicker && (\n        <div className=\"dropdown-menu arb-dropdown\">\n          <div className=\"dropdown-options\">\n            {Object.entries(APPLICABILITY_TYPES)\n              .filter(([type]) => depth < 2 || (type !== \"or\" && type !== \"and\"))\n              .map(([type, config]) => (\n                <div\n                  key={type}\n                  className=\"dropdown-menu-item\"\n                  onClick={() => {\n                    onAdd(type);\n                    setShowPicker(false);\n                  }}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div\n                    className=\"dropdown-menu-icon\"\n                    // eslint-disable-next-line local/no-inline-styles -- dynamic color per rule type\n                    style={{ '--arb-icon-bg': `${config.color}20`, backgroundColor: 'var(--arb-icon-bg)' }}\n                  >\n                    {config.icon}\n                  </div>\n                  <div>\n                    <div className=\"dropdown-menu-label\">{config.label}</div>\n                    <div className=\"arb-desc\">\n                      {config.desc}\n                    </div>\n                  </div>\n                </div>\n              ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ onAdd, depth = 0 }", "type": "{ onAdd: Function; depth: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityRuleCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityRuleCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.rule - The rule configuration\n * @param {Function} props.onChange - Callback when rule changes\n * @param {Function} props.onRemove - Callback to remove this rule\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n * @param {number} props.depth - Nesting depth for nested rules\n */\nexport function ApplicabilityRuleCard({\n  rule,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  eras,\n  depth = 0,\n}) {\n  const [expanded, setExpanded] = useState(false);\n  const typeConfig = APPLICABILITY_TYPES[rule.type] || {};\n\n  const entityKinds = schema?.entityKinds || [];\n  const entityKindOptions = entityKinds.map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const getSubtypesForKind = (kind) => {\n    const ek = entityKinds.find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const pressureOptions = (pressures || []).map((p) => ({\n    value: p.id,\n    label: p.name || p.id,\n  }));\n\n  const eraOptions = (eras || []).map((e) => ({\n    value: e.id,\n    label: e.name || e.id,\n  }));\n\n  const updateField = (field, value) => {\n    onChange({ ...rule, [field]: value });\n  };\n\n  const getSummary = () => {\n    switch (rule.type) {\n      case \"entity_count\": {\n        const kindSpec = `${rule.kind || \"?\"}${rule.subtype ? \":\" + rule.subtype : \"\"}`;\n        const minPart = rule.min !== undefined ? `>= ${rule.min}` : \"\";\n        const maxPart = rule.max !== undefined ? ` <= ${rule.max}` : \"\";\n        return `${kindSpec} ${minPart}${maxPart}`;\n      }\n      case \"pressure\":\n        return `${rule.pressureId || \"?\"} in [${rule.min ?? \"-\\u221E\"}, ${rule.max ?? \"\\u221E\"}]`;\n      case \"pressure_any_above\":\n        return `Any of [${rule.pressureIds?.join(\", \") || \"?\"}] > ${rule.threshold ?? \"?\"}`;\n      case \"pressure_compare\":\n        return `${rule.pressureA || \"?\"} ${rule.operator || \">\"} ${rule.pressureB || \"?\"}`;\n      case \"relationship_count\": {\n        const relMinPart = rule.min !== undefined ? `>= ${rule.min}` : \"\";\n        const relMaxPart = rule.max !== undefined ? ` <= ${rule.max}` : \"\";\n        return `${rule.relationshipKind || \"any\"} count ${relMinPart}${relMaxPart}`;\n      }\n      case \"relationship_exists\": {\n        const targetSuffix = rule.targetKind ? ` to ${rule.targetKind}` : \"\";\n        return `${rule.relationshipKind || \"?\"} exists${targetSuffix}`;\n      }\n      case \"tag_exists\":\n        return `has tag \"${rule.tag || \"?\"}\"`;\n      case \"tag_absent\":\n        return `missing tag \"${rule.tag || \"?\"}\"`;\n      case \"status\":\n        return rule.not ? `status != ${rule.status || \"?\"}` : `status = ${rule.status || \"?\"}`;\n      case \"prominence\":\n        return `prominence ${rule.min || \"?\"}-${rule.max || \"?\"}`;\n      case \"time_elapsed\":\n        return `${rule.minTicks || \"?\"} ticks since ${rule.since || \"updated\"}`;\n      case \"growth_phases_complete\": {\n        const eraSuffix = rule.eraId ? ` in ${rule.eraId}` : \"\";\n        return `${rule.minPhases ?? \"?\"} growth phases${eraSuffix}`;\n      }\n      case \"era_match\":\n        return rule.eras?.length ? rule.eras.join(\", \") : \"No eras selected\";\n      case \"random_chance\":\n        return `${Math.round((rule.chance ?? 0.5) * 100)}% chance`;\n      case \"cooldown_elapsed\":\n        return `${rule.cooldownTicks ?? \"?\"} ticks since last run`;\n      case \"creations_per_epoch\":\n        return `max ${rule.maxPerEpoch ?? \"?\"} per epoch`;\n      case \"graph_path\":\n        return `graph path (${rule.assert?.check || \"exists\"})`;\n      case \"entity_exists\":\n        return `entity ${rule.entity || \"?\"} exists`;\n      case \"entity_has_relationship\":\n        return `${rule.entity || \"?\"} has ${rule.relationshipKind || \"?\"} relationship`;\n      case \"or\":\n      case \"and\":\n        return `${rule.conditions?.length || 0} sub-rules`;\n      case \"always\":\n        return \"always\";\n      default:\n        return rule.type;\n    }\n  };\n\n  const isNested = rule.type === \"or\" || rule.type === \"and\";\n\n  return (\n    <div className=\"condition-card\">\n      <div className=\"condition-card-header\">\n        <div className=\"condition-card-type\">\n          <div\n            className=\"condition-card-icon\"\n            // eslint-disable-next-line local/no-inline-styles -- dynamic color per rule type\n            style={{ '--arc-icon-bg': `${typeConfig.color || \"#3b82f6\"}20`, backgroundColor: 'var(--arc-icon-bg)' }}\n          >\n            {typeConfig.icon || \"\ud83d\udccb\"}\n          </div>\n          <div>\n            <div className=\"condition-card-label\">{typeConfig.label || rule.type}</div>\n            <div className=\"condition-card-summary\">{getSummary()}</div>\n          </div>\n        </div>\n        <div className=\"condition-card-actions\">\n          <button className=\"btn-icon\" onClick={() => setExpanded(!expanded)}>\n            {expanded ? \"^\" : \"v\"}\n          </button>\n          <button className=\"btn-icon btn-icon-danger\" onClick={onRemove}>\n            x\n          </button>\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"mt-lg\">\n          <div className=\"form-grid\">\n            {rule.type === \"entity_count\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={rule.kind}\n                  onChange={(v) => {\n                    updateField(\"kind\", v);\n                    if (rule.subtype) updateField(\"subtype\", undefined);\n                  }}\n                  options={entityKindOptions}\n                />\n                <ReferenceDropdown\n                  label=\"Subtype (optional)\"\n                  value={rule.subtype || \"\"}\n                  onChange={(v) => updateField(\"subtype\", v || undefined)}\n                  options={[{ value: \"\", label: \"Any\" }, ...getSubtypesForKind(rule.kind)]}\n                  placeholder=\"Any\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Min\n                  <NumberInput\n                    value={rule.min}\n                    onChange={(v) => updateField(\"min\", v)}\n                    min={0}\n                    integer\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Max\n                  <NumberInput\n                    value={rule.max}\n                    onChange={(v) => updateField(\"max\", v)}\n                    min={0}\n                    integer\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure\"\n                  value={rule.pressureId}\n                  onChange={(v) => updateField(\"pressureId\", v)}\n                  options={pressureOptions}\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Min Value\n                  <NumberInput\n                    value={rule.min}\n                    onChange={(v) => updateField(\"min\", v)}\n                    min={-100}\n                    max={100}\n                    integer\n                    allowEmpty\n                    placeholder=\"0\"\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Max Value\n                  <NumberInput\n                    value={rule.max}\n                    onChange={(v) => updateField(\"max\", v)}\n                    min={-100}\n                    max={100}\n                    integer\n                    allowEmpty\n                    placeholder=\"100\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure_any_above\" && (\n              <>\n                <div className=\"grid-col-full\">\n                  <ChipSelect\n                    label=\"Pressures\"\n                    value={rule.pressureIds || []}\n                    onChange={(v) => updateField(\"pressureIds\", v)}\n                    options={pressureOptions}\n                    placeholder=\"+ Add pressure\"\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"label\">Threshold\n                  <NumberInput\n                    value={rule.threshold}\n                    onChange={(v) => updateField(\"threshold\", v ?? 0)}\n                    min={-100}\n                    max={100}\n                    integer\n                    placeholder=\"50\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {rule.type === \"pressure_compare\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure A\"\n                  value={rule.pressureA}\n                  onChange={(v) => updateField(\"pressureA\", v)}\n                  options={pressureOptions}\n                />\n                <ReferenceDropdown\n                  label=\"Operator\"\n                  value={rule.operator || \">\"}\n                  onChange={(v) => updateField(\"operator\", v)}\n                  options={[\n                    { value: \">\", label: \">\" },\n                    { value: \">=\", label: \">=\" },\n                    { value: \"<\", label: \"<\" },\n                    { value: \"<=\", label: \"<=\" },\n                    { value: \"==\", label: \"==\" },\n                    { value: \"!=\", label: \"!=\" },\n                  ]}\n                />\n                <ReferenceDropdown\n                  label=\"Pressure B\"\n                  value={rule.pressureB}\n                  onChange={(v) => updateField(\"pressureB\", v)}\n                  options={pressureOptions}\n                />\n              </>\n            )}\n\n\n            {rule.type === \"era_match\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Eras\"\n                  value={rule.eras || []}\n                  onChange={(v) => updateField(\"eras\", v)}\n                  options={eraOptions}\n                  placeholder=\"+ Add era\"\n                />\n              </div>\n            )}\n\n            {rule.type === \"random_chance\" && (\n              <div className=\"form-group grid-col-full\">\n                <span className=\"label\">Chance (%)</span>\n                <div className=\"flex items-center gap-lg\">\n// ... (truncated)", "parameters": [{"name": "{\n  rule,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  eras,\n  depth = 0,\n}", "type": "{ rule: any; onChange: Function; onRemove: Function; schema: any; pressures: any[]; eras: any[]; depth: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/ApplicabilityTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n */\nexport function ApplicabilityTab({ generator, onChange, schema, pressures, eras }) {\n  const rules = generator.applicability || [];\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Applicability Rules</div>\n        <div className=\"section-desc\">\n          Define when this generator is eligible to run. If no rules are defined, the generator will\n          always be eligible. Multiple top-level rules are combined with AND logic.\n        </div>\n\n        {rules.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\u2713</div>\n            <div className=\"empty-state-title\">No applicability rules</div>\n            <div className=\"empty-state-desc\">\n              This generator will always be eligible to run. Add rules to control when it activates.\n            </div>\n          </div>\n        ) : (\n          rules.map((rule, index) => (\n            <ApplicabilityRuleCard\n              key={index}\n              rule={rule}\n              onChange={(updated) => {\n                const newRules = [...rules];\n                newRules[index] = updated;\n                onChange({ ...generator, applicability: newRules });\n              }}\n              onRemove={() =>\n                onChange({ ...generator, applicability: rules.filter((_, i) => i !== index) })\n              }\n              schema={schema}\n              pressures={pressures}\n              eras={eras}\n            />\n          ))\n        )}\n\n        <AddRuleButton\n          onAdd={(type) => {\n            const newRule = createNewRule(type, pressures);\n            onChange({ ...generator, applicability: [...rules, newRule] });\n          }}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema, pressures, eras }", "type": "{ generator: any; onChange: Function; schema: any; pressures: any[]; eras: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js::createNewRule", "name": "createNewRule", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/createNewRule.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any"}, {"id": "apps/coherence-engine/webui/src/components/generators/applicability/index.js::createNewRule", "name": "createNewRule", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/applicability/index.js", "sourceCode": "/**\n * createNewRule - Factory for creating new applicability rules\n */\n\n/**\n * Creates a new applicability rule with default values based on type\n * @param {string} type - The rule type\n * @param {Array} pressures - Available pressure definitions\n * @returns {Object} A new rule object with default values\n */\nexport function createNewRule(type, pressures) {\n  // Create rules with empty required fields - validation will flag them\n  // No domain-specific defaults - user must explicitly select values\n  const newRule = { type };\n  const firstPressure = (pressures || [])[0]?.id || \"\";\n\n  switch (type) {\n    case \"pressure\":\n      return { ...newRule, pressureId: firstPressure, min: 0, max: 100 };\n    case \"pressure_any_above\":\n      return { ...newRule, pressureIds: firstPressure ? [firstPressure] : [], threshold: 50 };\n    case \"pressure_compare\":\n      return { ...newRule, pressureA: firstPressure, pressureB: firstPressure, operator: \">\" };\n    case \"entity_count\":\n      return { ...newRule, kind: \"\", min: 0 };\n    case \"relationship_count\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\", min: 0 };\n    case \"relationship_exists\":\n      return { ...newRule, relationshipKind: \"\", direction: \"both\" };\n    case \"tag_exists\":\n      return { ...newRule, tag: \"\" };\n    case \"tag_absent\":\n      return { ...newRule, tag: \"\" };\n    case \"status\":\n      return { ...newRule, status: \"\" };\n    case \"prominence\":\n      return { ...newRule, min: \"recognized\" };\n    case \"time_elapsed\":\n      return { ...newRule, minTicks: 10, since: \"updated\" };\n    case \"growth_phases_complete\":\n      return { ...newRule, minPhases: 2 };\n    case \"era_match\":\n      return { ...newRule, eras: [] };\n    case \"random_chance\":\n      return { ...newRule, chance: 0.5 };\n    case \"cooldown_elapsed\":\n      return { ...newRule, cooldownTicks: 10 };\n    case \"creations_per_epoch\":\n      return { ...newRule, maxPerEpoch: 1 };\n    case \"graph_path\":\n      return { ...newRule, assert: { check: \"exists\", path: [] } };\n    case \"entity_exists\":\n      return { ...newRule, entity: \"$target\" };\n    case \"entity_has_relationship\":\n      return { ...newRule, entity: \"$target\", relationshipKind: \"\", direction: \"both\" };\n    case \"or\":\n    case \"and\":\n      return { ...newRule, conditions: [] };\n    case \"always\":\n    default:\n      return newRule;\n  }\n}", "parameters": [{"name": "type", "type": "string", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}], "returnType": "any"}, {"id": "apps/coherence-engine/webui/src/components/generators/cards/GeneratorListCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/cards/GeneratorListCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator to display\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {Function} props.onToggle - Callback to toggle enabled state\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport function GeneratorListCard({ generator, onClick, onToggle, usageMap }) {\n  const isEnabled = generator.enabled !== false;\n\n  const summary = useMemo(() => {\n    const creates =\n      generator.creation?.map((c) => c.kind).filter((v, i, a) => a.indexOf(v) === i) || [];\n    const rels = generator.relationships?.length || 0;\n    const effects = generator.stateUpdates?.length || 0;\n    return { creates, rels, effects };\n  }, [generator]);\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"generator\", generator.id)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, generator.id]\n  );\n\n  const eraUsage = useMemo(() => {\n    if (!usageMap?.generators?.[generator.id]) return [];\n    return usageMap.generators[generator.id].eras || [];\n  }, [usageMap, generator.id]);\n\n  const errorCount = validation.invalidRefs.length;\n  const hasErrors = errorCount > 0;\n  const isOrphan = validation.isOrphan;\n\n  return (\n    <div\n      className={`card card-clickable ${!isEnabled ? \"card-disabled\" : \"\"} ${hasErrors ? \"card-error\" : \"\"} ${isOrphan && !hasErrors ? \"card-warning\" : \"\"}`}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{generator.name || generator.id}</span>\n            <ErrorBadge count={errorCount} />\n          </div>\n          <div className=\"card-id\">{generator.id}</div>\n        </div>\n        <EnableToggle\n          enabled={isEnabled}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n        />\n      </div>\n\n      <div className=\"card-stats\">\n        <div className=\"card-stat\">\n          <span>\u2728</span> {generator.creation?.length || 0} creates\n        </div>\n        <div className=\"card-stat\">\n          <span>\ud83d\udd17</span> {summary.rels} rels\n        </div>\n        <div className=\"card-stat\">\n          <span>\u26a1</span> {summary.effects} effects\n        </div>\n      </div>\n\n      <div className=\"card-badges\">\n        {summary.creates.slice(0, 3).map((kind) => (\n          <span key={kind} className=\"badge badge-entity-kind\">\n            + {kind}\n          </span>\n        ))}\n      </div>\n\n      <EraBadges eras={eraUsage} />\n      {isOrphan && (\n        <div className=\"mt-md\">\n          <OrphanBadge isOrphan={isOrphan} />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onClick, onToggle, usageMap }", "type": "{ generator: any; onClick: Function; onToggle: Function; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/GraphPathEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/GraphPathEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.assert - The path assertion configuration\n * @param {Function} props.onChange - Callback when assertion changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function GraphPathEditor({ assert, onChange, schema, availableRefs }) {\n  const [showConstraintMenu, setShowConstraintMenu] = useState(false);\n\n  const assertion = assert || { check: \"exists\", path: [] };\n\n  const updateAssertion = (field, value) => {\n    onChange({ ...assertion, [field]: value });\n  };\n\n  const addStep = () => {\n    // Create with empty required fields - validation will flag them\n    const newStep = { via: \"\", direction: \"\", targetKind: \"\", targetSubtype: \"\" };\n    updateAssertion(\"path\", [...(assertion.path || []), newStep]);\n  };\n\n  const updateStep = (index, updated) => {\n    const newPath = [...(assertion.path || [])];\n    newPath[index] = updated;\n    updateAssertion(\"path\", newPath);\n  };\n\n  const removeStep = (index) => {\n    updateAssertion(\n      \"path\",\n      (assertion.path || []).filter((_, i) => i !== index)\n    );\n  };\n\n  const addConstraint = (type) => {\n    const newConstraint = { type };\n    if (type === \"has_relationship\" || type === \"lacks_relationship\") {\n      newConstraint.direction = \"any\";\n    }\n    updateAssertion(\"where\", [...(assertion.where || []), newConstraint]);\n    setShowConstraintMenu(false);\n  };\n\n  const updateConstraint = (index, updated) => {\n    const newWhere = [...(assertion.where || [])];\n    newWhere[index] = updated;\n    updateAssertion(\"where\", newWhere);\n  };\n\n  const removeConstraint = (index) => {\n    const newWhere = (assertion.where || []).filter((_, i) => i !== index);\n    updateAssertion(\"where\", newWhere.length > 0 ? newWhere : undefined);\n  };\n\n  // Collect variables from path steps for constraint references\n  const pathVars = (assertion.path || []).filter((s) => s.as).map((s) => s.as);\n  const allRefs = [...(availableRefs || []), ...pathVars];\n\n  return (\n    <div className=\"graph-path-editor\">\n      {/* Check type and count */}\n      <div className=\"path-editor-grid\">\n        <div>\n          <label className=\"label label-tiny\">Check Type\n          <ReferenceDropdown\n            value={assertion.check || \"exists\"}\n            onChange={(v) => updateAssertion(\"check\", v)}\n            options={PATH_CHECK_TYPES}\n          />\n          </label>\n        </div>\n        {(assertion.check === \"count_min\" || assertion.check === \"count_max\") && (\n          <div>\n            <label className=\"label label-tiny\">Count\n            <NumberInput\n              value={assertion.count ?? 1}\n              onChange={(v) => updateAssertion(\"count\", v ?? 1)}\n              min={0}\n              integer\n              className=\"input input-compact\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      {/* Path steps */}\n      <div>\n        <span className=\"label label-tiny\">Path Steps (traverse relationships)</span>\n        <div className=\"path-steps-list\">\n          {(assertion.path || []).map((step, index) => (\n            <PathStepEditor\n              key={index}\n              step={step}\n              onChange={(updated) => updateStep(index, updated)}\n              onRemove={() => removeStep(index)}\n              schema={schema}\n              stepIndex={index}\n            />\n          ))}\n          {(assertion.path || []).length < 2 && (\n            <button onClick={addStep} className=\"button button-add-step\">\n              + Add Step {(assertion.path || []).length === 0 ? \"(required)\" : \"(optional)\"}\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* Where constraints */}\n      <div>\n        <span className=\"label label-tiny\">Where Constraints (optional)</span>\n        <div className=\"path-constraints-list\">\n          {(assertion.where || []).map((constraint, index) => (\n            <PathConstraintEditor\n              key={index}\n              constraint={constraint}\n              onChange={(updated) => updateConstraint(index, updated)}\n              onRemove={() => removeConstraint(index)}\n              schema={schema}\n              availableRefs={allRefs}\n            />\n          ))}\n          <div className=\"relative\">\n            <button\n              onClick={() => setShowConstraintMenu(!showConstraintMenu)}\n              className=\"button button-add-constraint\"\n            >\n              + Add Constraint\n            </button>\n            {showConstraintMenu && (\n              <div className=\"dropdown-menu\">\n                {PATH_CONSTRAINT_TYPES.map(({ value, label }) => (\n                  <div\n                    key={value}\n                    onClick={() => addConstraint(value)}\n                    className=\"dropdown-menu-item\"\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    {label}\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ assert, onChange, schema, availableRefs }", "type": "{ assert: any; onChange: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/PathConstraintEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/PathConstraintEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.constraint - The path constraint configuration\n * @param {Function} props.onChange - Callback when constraint changes\n * @param {Function} props.onRemove - Callback to remove this constraint\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function PathConstraintEditor({ constraint, onChange, onRemove, schema, availableRefs }) {\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const entityKinds = schema?.entityKinds || [];\n  const entityKindOptions = entityKinds.map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  // Gather all subtypes from all entity kinds for subtype_equals constraint\n  const allSubtypeOptions = entityKinds.flatMap((ek) =>\n    (ek.subtypes || []).map((st) => ({\n      value: st.id,\n      label: `${st.name || st.id} (${ek.kind})`,\n    }))\n  );\n\n  const refOptions = (availableRefs || []).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  const updateConstraint = (field, value) => {\n    onChange({ ...constraint, [field]: value || undefined });\n  };\n\n  const renderConstraintFields = () => {\n    switch (constraint.type) {\n      case \"not_self\":\n        return <span className=\"text-muted text-small\">Target cannot be the starting entity</span>;\n\n      case \"not_in\":\n      case \"in\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Set Variable\n            <ReferenceDropdown\n              value={constraint.set || \"\"}\n              onChange={(v) => updateConstraint(\"set\", v)}\n              options={refOptions}\n              placeholder=\"e.g. $allies\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"kind_equals\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Entity Kind\n            <ReferenceDropdown\n              value={constraint.kind || \"\"}\n              onChange={(v) => updateConstraint(\"kind\", v)}\n              options={entityKindOptions}\n            />\n            </label>\n          </div>\n        );\n\n      case \"subtype_equals\":\n        return (\n          <div>\n            <label className=\"label label-micro\">Subtype\n            <ReferenceDropdown\n              value={constraint.subtype || \"\"}\n              onChange={(v) => updateConstraint(\"subtype\", v)}\n              options={allSubtypeOptions}\n              placeholder=\"Select subtype...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_relationship\":\n      case \"lacks_relationship\":\n        return (\n          <div className=\"constraint-fields-grid\">\n            <div>\n              <label className=\"label label-micro\">Kind\n              <ReferenceDropdown\n                value={constraint.kind || \"\"}\n                onChange={(v) => updateConstraint(\"kind\", v)}\n                options={relationshipKindOptions}\n              />\n              </label>\n            </div>\n            <div>\n              <label className=\"label label-micro\">With\n              <ReferenceDropdown\n                value={constraint.with || \"\"}\n                onChange={(v) => updateConstraint(\"with\", v)}\n                options={refOptions}\n              />\n              </label>\n            </div>\n            <div>\n              <label className=\"label label-micro\">Direction\n              <ReferenceDropdown\n                value={constraint.direction || \"any\"}\n                onChange={(v) => updateConstraint(\"direction\", v)}\n                options={PATH_DIRECTIONS}\n              />\n              </label>\n            </div>\n          </div>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  const constraintLabel =\n    PATH_CONSTRAINT_TYPES.find((c) => c.value === constraint.type)?.label || constraint.type;\n\n  return (\n    <div className=\"path-constraint-card\">\n      <div className=\"path-constraint-header\">\n        <span className=\"path-constraint-label\">{constraintLabel}</span>\n        <button onClick={onRemove} className=\"button button-remove-micro\">\n          \u00d7\n        </button>\n      </div>\n      {renderConstraintFields()}\n    </div>\n  );\n}", "parameters": [{"name": "{ constraint, onChange, onRemove, schema, availableRefs }", "type": "{ constraint: any; onChange: Function; onRemove: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/PathStepEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/PathStepEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.step - The path step configuration\n * @param {Function} props.onChange - Callback when step changes\n * @param {Function} props.onRemove - Callback to remove this step\n * @param {Object} props.schema - Domain schema\n * @param {number} props.stepIndex - Index of this step in the path\n */\nexport function PathStepEditor({ step, onChange, onRemove, schema, stepIndex }) {\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const entityKindOptions = [\n    { value: \"any\", label: \"Any kind\" },\n    ...(schema?.entityKinds || []).map((ek) => ({\n      value: ek.kind,\n      label: ek.description || ek.kind,\n    })),\n  ];\n\n  const getSubtypeOptions = (kind) => {\n    if (!kind || kind === \"any\") return [{ value: \"any\", label: \"Any subtype\" }];\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [{ value: \"any\", label: \"Any subtype\" }];\n    return [\n      { value: \"any\", label: \"Any subtype\" },\n      ...ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id })),\n    ];\n  };\n\n  const updateStep = (field, value) => {\n    onChange({ ...step, [field]: value });\n  };\n\n  return (\n    <div className=\"path-step-card\">\n      <div className=\"path-step-header\">\n        <span className=\"path-step-label\">Step {stepIndex + 1}</span>\n        <button onClick={onRemove} className=\"button button-remove-micro\">\n          \u00d7\n        </button>\n      </div>\n      <div className=\"path-step-grid\">\n        <div>\n          <label className=\"label label-micro\">Via Relationship\n          <ReferenceDropdown\n            value={step.via || \"\"}\n            onChange={(v) => updateStep(\"via\", v)}\n            options={relationshipKindOptions}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Direction\n          <ReferenceDropdown\n            value={step.direction || \"any\"}\n            onChange={(v) => updateStep(\"direction\", v)}\n            options={PATH_DIRECTIONS}\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Target Kind\n          <ReferenceDropdown\n            value={step.targetKind}\n            onChange={(v) => updateStep(\"targetKind\", v)}\n            options={entityKindOptions}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div>\n          <label className=\"label label-micro\">Target Subtype\n          <ReferenceDropdown\n            value={step.targetSubtype}\n            onChange={(v) => updateStep(\"targetSubtype\", v)}\n            options={getSubtypeOptions(step.targetKind)}\n            placeholder=\"Select...\"\n          />\n          </label>\n        </div>\n        <div className=\"path-step-full-width\">\n          <label htmlFor=\"store-as-variable-optional\" className=\"label label-micro\">Store As Variable (optional)</label>\n          <input id=\"store-as-variable-optional\"\n            type=\"text\"\n            value={step.as || \"\"}\n            onChange={(e) => updateStep(\"as\", e.target.value)}\n            className=\"input input-micro\"\n            placeholder=\"e.g. $allies\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ step, onChange, onRemove, schema, stepIndex }", "type": "{ step: any; onChange: Function; onRemove: Function; schema: any; stepIndex: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFilterCard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFilterCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.filter - The filter configuration\n * @param {Function} props.onChange - Callback when filter changes\n * @param {Function} props.onRemove - Callback to remove this filter\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function SelectionFilterCard({ filter, onChange, onRemove, schema, availableRefs }) {\n  const [expanded, setExpanded] = useState(false);\n  const typeConfig = FILTER_TYPES[filter.type] || {\n    label: filter.type,\n    icon: \"\u2753\",\n    color: \"#6b7280\",\n  };\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const refOptions = (availableRefs || []).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  const updateFilter = (field, value) => {\n    onChange({ ...filter, [field]: value });\n  };\n\n  const getSummary = () => {\n    switch (filter.type) {\n      case \"has_tag\": {\n        const valueSuffix = filter.value !== undefined ? ` = ${filter.value}` : \"\";\n        return `${filter.tag || \"?\"}${valueSuffix}`;\n      }\n      case \"has_tags\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"has_any_tag\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"lacks_tag\":\n        return filter.tag || \"tag?\";\n      case \"lacks_any_tag\":\n        return (filter.tags || []).join(\", \") || \"no tags\";\n      case \"has_culture\":\n        return filter.culture || \"culture?\";\n      case \"matches_culture\":\n        return `with ${filter.with || \"?\"}`;\n      case \"has_status\":\n        return filter.status || \"status?\";\n      case \"has_prominence\":\n        return filter.minProminence || \"prominence?\";\n      case \"has_relationship\": {\n        const withLabel = filter.with ? ` with ${filter.with}` : \"\";\n        const direction = filter.direction ? ` [${filter.direction}]` : \"\";\n        return `${filter.kind || \"?\"}${withLabel}${direction}`;\n      }\n      case \"lacks_relationship\": {\n        const withLabel = filter.with ? ` with ${filter.with}` : \"\";\n        return `${filter.kind || \"?\"}${withLabel}`;\n      }\n      case \"exclude\":\n        return `${(filter.entities || []).length} excluded`;\n      case \"shares_related\":\n        return `${filter.relationshipKind || \"?\"} with ${filter.with || \"?\"}`;\n      case \"graph_path\":\n        return `graph path (${filter.assert?.check || \"exists\"})`;\n      default:\n        return \"\";\n    }\n  };\n\n  const summary = getSummary();\n\n  const renderFilterFields = () => {\n    switch (filter.type) {\n      case \"has_tag\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-wide\">\n              <label className=\"label label-small\">Tag\n              <TagSelector\n                value={filter.tag ? [filter.tag] : []}\n                onChange={(v) => updateFilter(\"tag\", v[0] || \"\")}\n                tagRegistry={schema?.tagRegistry || []}\n                placeholder=\"Select tag...\"\n                singleSelect\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-wide\">\n              <label htmlFor=\"value-optional\" className=\"label label-small\">Value (optional)</label>\n              <input id=\"value-optional\"\n                type=\"text\"\n                value={filter.value ?? \"\"}\n                onChange={(e) => updateFilter(\"value\", e.target.value || undefined)}\n                className=\"input input-compact\"\n                placeholder=\"Any value\"\n              />\n            </div>\n          </div>\n        );\n\n      case \"has_tags\":\n      case \"has_any_tag\":\n        return (\n          <div>\n            <label className=\"label label-small\">\n              {filter.type === \"has_tags\" ? \"Tags (must have ALL)\" : \"Tags (must have at least ONE)\"}\n            </label>\n            <TagSelector\n              value={filter.tags || []}\n              onChange={(v) => updateFilter(\"tags\", v)}\n              tagRegistry={schema?.tagRegistry || []}\n              placeholder=\"Select tags...\"\n            />\n          </div>\n        );\n\n      case \"lacks_tag\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-wide\">\n              <label className=\"label label-small\">Tag\n              <TagSelector\n                value={filter.tag ? [filter.tag] : []}\n                onChange={(v) => updateFilter(\"tag\", v[0] || \"\")}\n                tagRegistry={schema?.tagRegistry || []}\n                placeholder=\"Select tag...\"\n                singleSelect\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-wide\">\n              <label htmlFor=\"value-optional\" className=\"label label-small\">Value (optional)</label>\n              <input id=\"value-optional\"\n                type=\"text\"\n                value={filter.value ?? \"\"}\n                onChange={(e) => updateFilter(\"value\", e.target.value || undefined)}\n                className=\"input input-compact\"\n                placeholder=\"Any value\"\n              />\n            </div>\n          </div>\n        );\n\n      case \"lacks_any_tag\":\n        return (\n          <div>\n            <label className=\"label label-small\">Tags (exclude if has ANY)\n            <TagSelector\n              value={filter.tags || []}\n              onChange={(v) => updateFilter(\"tags\", v)}\n              tagRegistry={schema?.tagRegistry || []}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n        );\n\n\n      case \"has_culture\":\n        return (\n          <div>\n            <label className=\"label label-small\">Culture\n            <ReferenceDropdown\n              value={filter.culture || \"\"}\n              onChange={(v) => updateFilter(\"culture\", v)}\n              options={(schema?.cultures || []).map((c) => ({\n                value: c.id,\n                label: c.name || c.id,\n              }))}\n              placeholder=\"Select culture...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"matches_culture\":\n        return (\n          <div>\n            <label className=\"label label-small\">Same Culture As\n            <ReferenceDropdown\n              value={filter.with || \"\"}\n              onChange={(v) => updateFilter(\"with\", v)}\n              options={refOptions}\n              placeholder=\"Select variable...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_status\":\n        return (\n          <div>\n            <label htmlFor=\"status\" className=\"label label-small\">Status</label>\n            <input id=\"status\"\n              type=\"text\"\n              value={filter.status || \"\"}\n              onChange={(e) => updateFilter(\"status\", e.target.value)}\n              className=\"input input-compact\"\n              placeholder=\"e.g., active, historical\"\n            />\n          </div>\n        );\n\n      case \"has_prominence\":\n        return (\n          <div>\n            <label className=\"label label-small\">Minimum Prominence\n            <ReferenceDropdown\n              value={filter.minProminence || \"\"}\n              onChange={(v) => updateFilter(\"minProminence\", v)}\n              options={PROMINENCE_LEVELS.map((p) => ({ value: p.value, label: p.label }))}\n              placeholder=\"Select prominence...\"\n            />\n            </label>\n          </div>\n        );\n\n      case \"has_relationship\":\n      case \"lacks_relationship\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-medium\">\n              <label className=\"label label-small\">Relationship Kind\n              <ReferenceDropdown\n                value={filter.kind || \"\"}\n                onChange={(v) => updateFilter(\"kind\", v)}\n                options={relationshipKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-narrow\">\n              <label className=\"label label-small\">With Entity (optional)\n              <ReferenceDropdown\n                value={filter.with || \"\"}\n                onChange={(v) => updateFilter(\"with\", v || undefined)}\n                options={refOptions}\n                placeholder=\"Any entity\"\n              />\n              </label>\n            </div>\n            {filter.type === \"has_relationship\" && (\n              <div className=\"sfc-flex-field-tiny\">\n                <label className=\"label label-small\">Direction\n                <ReferenceDropdown\n                  value={filter.direction || \"both\"}\n                  onChange={(v) => updateFilter(\"direction\", v)}\n                  options={[\n                    { value: \"both\", label: \"Both\" },\n                    { value: \"src\", label: \"Outgoing\" },\n                    { value: \"dst\", label: \"Incoming\" },\n                  ]}\n                />\n                </label>\n              </div>\n            )}\n          </div>\n        );\n\n      case \"exclude\":\n        return (\n          <ChipSelect\n            label=\"Entities to Exclude\"\n            value={filter.entities || []}\n            onChange={(v) => updateFilter(\"entities\", v)}\n            options={refOptions}\n            placeholder=\"+ Add variable...\"\n          />\n        );\n\n      case \"shares_related\":\n        return (\n          <div className=\"filter-fields\">\n            <div className=\"sfc-flex-field-medium\">\n              <label className=\"label label-small\">Via Relationship\n              <ReferenceDropdown\n                value={filter.relationshipKind || \"\"}\n                onChange={(v) => updateFilter(\"relationshipKind\", v)}\n                options={relationshipKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              </label>\n            </div>\n            <div className=\"sfc-flex-field-narrow\">\n              <label className=\"label label-small\">With Entity\n              <ReferenceDropdown\n                value={filter.with || \"\"}\n                onChange={(v) => updateFilter(\"with\", v)}\n                options={refOptions}\n                placeholder=\"Select variable...\"\n              />\n              </label>\n            </div>\n          </div>\n        );\n\n      case \"graph_path\":\n// ... (truncated)", "parameters": [{"name": "{ filter, onChange, onRemove, schema, availableRefs }", "type": "{ filter: any; onChange: Function; onRemove: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFiltersEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/filters/SelectionFiltersEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array} props.filters - Array of filter configurations\n * @param {Function} props.onChange - Callback when filters change\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.availableRefs - Available entity references\n */\nexport function SelectionFiltersEditor({ filters, onChange, schema, availableRefs }) {\n  const [showTypeMenu, setShowTypeMenu] = useState(false);\n  const [dropdownPos, setDropdownPos] = useState({ top: 0, left: 0, width: 0 });\n  const containerRef = useRef(null);\n\n  // Calculate dropdown position when opening (like TagSelector)\n  useLayoutEffect(() => {\n    if (showTypeMenu && containerRef.current) {\n      const rect = containerRef.current.getBoundingClientRect();\n      setDropdownPos({\n        top: rect.bottom + 4,\n        left: rect.left,\n        width: Math.max(rect.width, 220),\n      });\n    }\n  }, [showTypeMenu]);\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    if (!showTypeMenu) return;\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setShowTypeMenu(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showTypeMenu]);\n\n  const handleAddFilter = (type) => {\n    // Create with empty required fields - validation will flag them\n    const newFilter = { type };\n    // Tag filters\n    if (type === \"has_tag\") newFilter.tag = \"\";\n    if (type === \"has_tags\") newFilter.tags = [];\n    if (type === \"has_any_tag\") newFilter.tags = [];\n    if (type === \"lacks_tag\") newFilter.tag = \"\";\n    if (type === \"lacks_any_tag\") newFilter.tags = [];\n    // Attribute filters\n    if (type === \"has_culture\") newFilter.culture = \"\";\n    if (type === \"matches_culture\") newFilter.with = \"\";\n    if (type === \"has_status\") newFilter.status = \"\";\n    if (type === \"has_prominence\") newFilter.minProminence = \"\";\n    // Relationship filters\n    if (type === \"has_relationship\") newFilter.kind = \"\";\n    if (type === \"lacks_relationship\") newFilter.kind = \"\";\n    if (type === \"shares_related\") {\n      newFilter.relationshipKind = \"\";\n      newFilter.with = \"\";\n    }\n    // Other\n    if (type === \"exclude\") newFilter.entities = [];\n    if (type === \"graph_path\")\n      newFilter.assert = {\n        check: \"\",\n        path: [{ via: \"\", direction: \"\", targetKind: \"\", targetSubtype: \"\" }],\n      };\n    onChange([...(filters || []), newFilter]);\n    setShowTypeMenu(false);\n  };\n\n  const handleUpdateFilter = (index, updated) => {\n    const newFilters = [...(filters || [])];\n    newFilters[index] = updated;\n    onChange(newFilters);\n  };\n\n  const handleRemoveFilter = (index) => {\n    onChange((filters || []).filter((_, i) => i !== index));\n  };\n\n  return (\n    <div>\n      {(filters || []).length === 0 ? (\n        <div className=\"empty-state-compact\">\n          No filters defined. Filters narrow down which entities can be selected as targets.\n        </div>\n      ) : (\n        <div className=\"condition-list\">\n          {(filters || []).map((filter, index) => (\n            <SelectionFilterCard\n              key={index}\n              filter={filter}\n              onChange={(updated) => handleUpdateFilter(index, updated)}\n              onRemove={() => handleRemoveFilter(index)}\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))}\n        </div>\n      )}\n\n      <div ref={containerRef} className=\"relative mt-lg\">\n        <button onClick={() => setShowTypeMenu(!showTypeMenu)} className=\"btn-add-inline\">\n          + Add Filter\n        </button>\n\n        {showTypeMenu && (\n          <div\n            className=\"dropdown-menu sfe-dropdown-fixed\"\n            // eslint-disable-next-line local/no-inline-styles -- dynamic position from measured DOM rect\n            style={{ '--sfe-dd-top': `${dropdownPos.top}px`, '--sfe-dd-left': `${dropdownPos.left}px`, '--sfe-dd-width': `${dropdownPos.width}px`, top: 'var(--sfe-dd-top)', left: 'var(--sfe-dd-left)', width: 'var(--sfe-dd-width)' }}\n          >\n            {Object.entries(FILTER_TYPES).map(([type, config]) => (\n              <div key={type} onClick={() => handleAddFilter(type)} className=\"dropdown-menu-item\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                <span\n                  className=\"dropdown-menu-icon\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic color per filter type\n                  style={{ '--sfe-icon-bg': `${config.color}20`, backgroundColor: 'var(--sfe-icon-bg)' }}\n                >\n                  {config.icon}\n                </span>\n                <span className=\"dropdown-menu-label\">{config.label}</span>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ filters, onChange, schema, availableRefs }", "type": "{ filters: any[]; onChange: Function; schema: any; availableRefs: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx", "sourceCode": "// ============================================================================\n// CreationTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.tagRegistry - Available tags\n * @param {Function} props.onAddToRegistry - Callback to add new tag to registry\n * @param {Array} props.pressures - Available pressure definitions\n */\nexport function CreationTab({\n  generator,\n  onChange,\n  schema,\n  tagRegistry = [],\n  onAddToRegistry,\n  pressures = [],\n}) {\n  const creation = generator.creation || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    creation.forEach((c) => {\n      if (c.entityRef && !refs.includes(c.entityRef)) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, creation]);\n\n  const culturesById = useMemo(() => {\n    const map = {};\n    (schema?.cultures || []).forEach((culture) => {\n      map[culture.id] = culture;\n    });\n    return map;\n  }, [schema?.cultures]);\n\n  const cultureIds = useMemo(() => Object.keys(culturesById), [culturesById]);\n\n  const handleAdd = () => {\n    const nextNum = creation.length + 1;\n    onChange({\n      ...generator,\n      creation: [\n        ...creation,\n        { entityRef: `$entity${nextNum}`, kind: \"npc\", prominence: \"marginal\" },\n      ],\n    });\n  };\n\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Entity Creation</div>\n        <div className=\"section-desc\">\n          Define entities that this generator creates. Each entity gets a reference (like{\" \"}\n          <code className=\"inline-code\">$hero</code>) that can be used in relationships.\n        </div>\n\n        {creation.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\u2728</div>\n            <div className=\"empty-state-title\">No entities created</div>\n            <div className=\"empty-state-desc\">\n              This generator only modifies existing entities. Add creation rules to spawn new\n              entities.\n            </div>\n          </div>\n        ) : (\n          creation.map((item, index) => (\n            <CreationCard\n              key={index}\n              item={item}\n              onChange={(updated) => {\n                const newCreation = [...creation];\n                newCreation[index] = updated;\n                onChange({ ...generator, creation: newCreation });\n              }}\n              onRemove={() =>\n                onChange({ ...generator, creation: creation.filter((_, i) => i !== index) })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n              culturesById={culturesById}\n              cultureIds={cultureIds}\n              generator={generator}\n              tagRegistry={tagRegistry}\n              onAddToRegistry={onAddToRegistry}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Entity Creation\n        </button>\n      </div>\n\n      <VariantsSection\n        generator={generator}\n        onChange={onChange}\n        pressures={pressures}\n        schema={schema}\n        tagRegistry={tagRegistry}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  generator,\n  onChange,\n  schema,\n  tagRegistry = [],\n  onAddToRegistry,\n  pressures = [],\n}", "type": "{ generator: any; onChange: Function; schema: any; tagRegistry: any[]; onAddToRegistry: Function; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/EffectsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/EffectsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Object} props.schema - Domain schema\n */\nexport function EffectsTab({ generator, onChange, pressures, schema }) {\n  const stateUpdates = generator.stateUpdates || [];\n  const [showTypeMenu, setShowTypeMenu] = useState(false);\n  const [dropdownPos, setDropdownPos] = useState({ top: 0, left: 0, width: 0 });\n  const addButtonRef = useRef(null);\n\n  // Build available entity references from target + variables + created entities\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  const createMutation = (type) => {\n    let newUpdate;\n    switch (type) {\n      case \"modify_pressure\":\n        newUpdate = { type: \"modify_pressure\", pressureId: pressures?.[0]?.id || \"\", delta: 0 };\n        break;\n      case \"archive_relationship\":\n        newUpdate = {\n          type: \"archive_relationship\",\n          entity: \"$target\",\n          relationshipKind: \"\",\n          direction: \"both\",\n        };\n        break;\n      case \"change_status\":\n        newUpdate = { type: \"change_status\", entity: \"$target\", newStatus: \"\" };\n        break;\n      case \"set_tag\":\n        newUpdate = { type: \"set_tag\", entity: \"$target\", tag: \"\", value: true };\n        break;\n      case \"remove_tag\":\n        newUpdate = { type: \"remove_tag\", entity: \"$target\", tag: \"\" };\n        break;\n      case \"update_rate_limit\":\n        newUpdate = { type: \"update_rate_limit\" };\n        break;\n      default:\n        return null;\n    }\n    return newUpdate;\n  };\n\n  const addMutation = (type) => {\n    const next = createMutation(type);\n    if (!next) return;\n    onChange({ ...generator, stateUpdates: [...stateUpdates, next] });\n  };\n\n  const updateMutation = (index, updated) => {\n    const newUpdates = [...stateUpdates];\n    newUpdates[index] = updated;\n    onChange({ ...generator, stateUpdates: newUpdates });\n  };\n\n  const removeMutation = (index) => {\n    onChange({ ...generator, stateUpdates: stateUpdates.filter((_, i) => i !== index) });\n  };\n\n  const knownTypes = new Set(DEFAULT_MUTATION_TYPES.map((type) => type.value));\n  const unrecognizedUpdates = stateUpdates\n    .map((update, index) => (knownTypes.has(update.type) ? null : { update, index }))\n    .filter(Boolean);\n\n  useLayoutEffect(() => {\n    if (showTypeMenu && addButtonRef.current) {\n      const rect = addButtonRef.current.getBoundingClientRect();\n      setDropdownPos({\n        top: rect.bottom + 4,\n        left: rect.left,\n        width: Math.max(rect.width, 220),\n      });\n    }\n  }, [showTypeMenu]);\n\n  useEffect(() => {\n    if (!showTypeMenu) return;\n    const handleClickOutside = (event) => {\n      if (addButtonRef.current && !addButtonRef.current.contains(event.target)) {\n        setShowTypeMenu(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showTypeMenu]);\n\n  return (\n    <div>\n      {/* Unrecognized Effects - shown first to draw attention */}\n      {unrecognizedUpdates.length > 0 && (\n        <div className=\"section et-unrecognized-section\">\n          <div className=\"section-title et-unrecognized-title\">\n            <span>\u26a0\ufe0f</span> Unrecognized Effects\n          </div>\n          <div className=\"section-desc mb-lg\">\n            These state updates have unrecognized types and may be from an older version. Remove\n            them to clear validation errors.\n          </div>\n\n          {unrecognizedUpdates.map((entry) => {\n            const globalIdx = entry.index;\n            const update = entry.update;\n            return (\n              <div\n                key={globalIdx}\n                className=\"item-card et-unrecognized-card\"\n              >\n                <div className=\"et-unrecognized-body\">\n                  <div className=\"et-unrecognized-layout\">\n                    <div className=\"flex-1\">\n                      <div className=\"et-unrecognized-type\">\n                        Unknown type: &quot;{update.type || \"(no type)\"}&quot;\n                      </div>\n                      <pre className=\"et-unrecognized-json\">\n                        {JSON.stringify(update, null, 2)}\n                      </pre>\n                    </div>\n                    <button\n                      className=\"btn btn-danger flex-shrink-0\"\n                      onClick={() => removeMutation(globalIdx)}\n                    >\n                      Remove\n                    </button>\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      <div className=\"section\">\n        <div className=\"section-title\">\u26a1 Effects ({stateUpdates.length})</div>\n        <div className=\"section-desc\">\n          Apply state updates when this generator runs. Effects use the unified mutation library.\n        </div>\n\n        {stateUpdates.map((update, index) => {\n          if (!knownTypes.has(update.type)) return null;\n          return (\n            <MutationCard\n              key={index}\n              mutation={update}\n              onChange={(updated) => updateMutation(index, updated)}\n              onRemove={() => removeMutation(index)}\n              schema={schema}\n              pressures={pressures}\n              entityOptions={availableRefs}\n              typeOptions={DEFAULT_MUTATION_TYPES}\n              createMutation={createMutation}\n            />\n          );\n        })}\n\n        <div ref={addButtonRef} className=\"relative mt-lg\">\n          <button onClick={() => setShowTypeMenu(!showTypeMenu)} className=\"btn-add-inline\">\n            + Add Effect\n          </button>\n\n          {showTypeMenu && (\n            <div\n              className=\"dropdown-menu et-dropdown-fixed\"\n              // eslint-disable-next-line local/no-inline-styles -- dynamic position from measured DOM rect\n              style={{ '--et-dd-top': `${dropdownPos.top}px`, '--et-dd-left': `${dropdownPos.left}px`, '--et-dd-width': `${dropdownPos.width}px`, top: 'var(--et-dd-top)', left: 'var(--et-dd-left)', width: 'var(--et-dd-width)' }}\n            >\n              {MUTATION_TYPE_OPTIONS.map((opt) => (\n                <div\n                  key={opt.value}\n                  onClick={() => {\n                    addMutation(opt.value);\n                    setShowTypeMenu(false);\n                  }}\n                  className=\"dropdown-menu-item\"\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <span\n                    className=\"dropdown-menu-icon\"\n                    // eslint-disable-next-line local/no-inline-styles -- dynamic color per mutation type\n                    style={{ '--et-icon-bg': `${opt.color}20`, backgroundColor: 'var(--et-icon-bg)' }}\n                  >\n                    {opt.icon}\n                  </span>\n                  <span className=\"dropdown-menu-label\">{opt.label}</span>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, pressures, schema }", "type": "{ generator: any; onChange: Function; pressures: any[]; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Function} props.onDelete - Callback to delete the generator\n * @param {Function} props.onDuplicate - Callback to duplicate the generator\n */\nexport function OverviewTab({ generator, onChange, onDelete, onDuplicate }) {\n  const updateField = (field, value) => {\n    onChange({ ...generator, [field]: value });\n  };\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(generator.id, (value) =>\n    updateField(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(generator.name, (value) =>\n    updateField(\"name\", value)\n  );\n\n  const summary = useMemo(() => {\n    return {\n      rules: generator.applicability?.length || 0,\n      variables: Object.keys(generator.variables || {}).length,\n      creates: generator.creation?.length || 0,\n      relationships: generator.relationships?.length || 0,\n      effects: generator.stateUpdates?.length || 0,\n    };\n  }, [generator]);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Basic Information</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label htmlFor=\"generator-id\" className=\"label\">Generator ID</label>\n            <input id=\"generator-id\"\n              type=\"text\"\n              value={localId}\n              onChange={(e) => setLocalId(e.target.value)}\n              onBlur={handleIdBlur}\n              className=\"input\"\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"display-name\" className=\"label\">Display Name</label>\n            <input id=\"display-name\"\n              type=\"text\"\n              value={localName}\n              onChange={(e) => setLocalName(e.target.value)}\n              onBlur={handleNameBlur}\n              className=\"input\"\n              placeholder=\"Optional friendly name\"\n            />\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Enabled\n          <EnableToggle\n            enabled={generator.enabled !== false}\n            onChange={(enabled) => updateField(\"enabled\", enabled)}\n            label={generator.enabled !== false ? \"Generator is active\" : \"Generator is disabled\"}\n          />\n          </label>\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">Narration Template</span>\n          <div className=\"section-desc mb-md\">\n            Syntax: {\"{$target.field}\"}, {\"{$var.field}\"}, {\"{count:kind}\"}, {\"{list:created}\"},{\" \"}\n            {\"{field|fallback}\"}.\n          </div>\n          <LocalTextArea\n            value={generator.narrationTemplate || \"\"}\n            onChange={(value) => updateField(\"narrationTemplate\", value || undefined)}\n            placeholder=\"e.g., From {$target.name}, {count:npc} new souls emerged to shape the realm.\"\n            rows={2}\n          />\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Summary</div>\n        <div className=\"summary-stats-grid\">\n          {[\n            { label: \"Rules\", value: summary.rules, icon: \"\u2713\" },\n            { label: \"Variables\", value: summary.variables, icon: \"\ud83d\udce6\" },\n            { label: \"Creates\", value: summary.creates, icon: \"\u2728\" },\n            { label: \"Connects\", value: summary.relationships, icon: \"\ud83d\udd17\" },\n            { label: \"Effects\", value: summary.effects, icon: \"\u26a1\" },\n          ].map((stat) => (\n            <div key={stat.label} className=\"summary-stat\">\n              <div className=\"summary-stat-icon\">{stat.icon}</div>\n              <div className=\"summary-stat-value\">{stat.value}</div>\n              <div className=\"summary-stat-label\">{stat.label}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"danger-zone\">\n        <button className=\"btn btn-secondary\" onClick={onDuplicate}>\n          Duplicate Generator\n        </button>\n        <button className=\"btn btn-danger\" onClick={onDelete}>\n          Delete Generator\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, onDelete, onDuplicate }", "type": "{ generator: any; onChange: Function; onDelete: Function; onDuplicate: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function RelationshipsTab({ generator, onChange, schema }) {\n  const relationships = generator.relationships || [];\n  const saturationLimits = generator.selection?.saturationLimits || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  // Find the first created entity ref for implied relationships\n  const firstCreatedRef = useMemo(() => {\n    const creation = generator.creation || [];\n    return creation.length > 0 ? creation[0].entityRef : \"$created\";\n  }, [generator.creation]);\n\n  const handleAdd = () => {\n    onChange({\n      ...generator,\n      relationships: [\n        ...relationships,\n        {\n          kind: schema?.relationshipKinds?.[0]?.kind || \"ally_of\",\n          src: availableRefs[1] || \"$entity1\",\n          dst: \"$target\",\n          strength: 0.8,\n        },\n      ],\n    });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Relationships</div>\n        <div className=\"section-desc\">\n          Define relationships created between entities. Use entity references like{\" \"}\n          <code className=\"inline-code\">$target</code>, created entities like{\" \"}\n          <code className=\"inline-code\">$hero</code>, or variables like{\" \"}\n          <code className=\"inline-code\">$faction</code>.\n        </div>\n\n        {/* Implied relationships from saturation limits */}\n        {saturationLimits.length > 0 && (\n          <div className=\"mb-xl\">\n            {saturationLimits.map((limit, index) => (\n              <ImpliedRelationshipCard\n                key={`implied-${index}`}\n                saturationLimit={limit}\n                schema={schema}\n                createdEntityRef={firstCreatedRef}\n              />\n            ))}\n          </div>\n        )}\n\n        {relationships.length === 0 && saturationLimits.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udd17</div>\n            <div className=\"empty-state-title\">No relationships</div>\n            <div className=\"empty-state-desc\">\n              This generator doesn&apos;t create any relationships. Add relationships to connect\n              entities.\n            </div>\n          </div>\n        ) : (\n          relationships.map((rel, index) => (\n            <RelationshipCard\n              key={index}\n              rel={rel}\n              onChange={(updated) => {\n                const newRels = [...relationships];\n                newRels[index] = updated;\n                onChange({ ...generator, relationships: newRels });\n              }}\n              onRemove={() =>\n                onChange({\n                  ...generator,\n                  relationships: relationships.filter((_, i) => i !== index),\n                })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Relationship\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema with entity/relationship kinds\n */\nexport function TargetTab({ generator, onChange, schema }) {\n  const selection = generator.selection || { strategy: \"by_kind\" };\n\n  // Get the kind of the first created entity for saturation limit inference\n  const firstCreatedKind = (generator.creation || [])[0]?.kind;\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Target Selection</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What is $target?</div>\n          <div className=\"info-box-text\">\n            The <code className=\"inline-code\">$target</code> is the primary entity this generator\n            operates on. It&apos;s selected from the world graph based on the rules you define here. Once\n            selected, you can reference it in creation rules (e.g., inherit culture from $target)\n            and relationships (e.g., connect new entity to $target).\n          </div>\n        </div>\n\n        <SelectionRuleEditor\n          value={selection}\n          onChange={(updated) => onChange({ ...generator, selection: updated })}\n          schema={schema}\n          availableRefs={[\"$target\", ...Object.keys(generator.variables || {})]}\n        />\n\n        {/* Saturation Limits */}\n        <div className=\"mt-2xl\">\n          <span className=\"label\">Saturation Limits</span>\n          <div className=\"info-box-text mb-lg text-sm\">\n            Limit targets based on existing relationship counts. Only targets with fewer than the\n            max count of relationships will be selected.\n          </div>\n          <SaturationLimitsEditor\n            limits={selection.saturationLimits || []}\n            onChange={(limits) =>\n              onChange({\n                ...generator,\n                selection: {\n                  ...selection,\n                  saturationLimits: limits.length > 0 ? limits : undefined,\n                },\n              })\n            }\n            schema={schema}\n            createdKind={firstCreatedKind}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx", "sourceCode": "// ============================================================================\n// VariablesTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function VariablesTab({ generator, onChange, schema }) {\n  const variables = generator.variables || {};\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddForm, setShowAddForm] = useState(false);\n\n  // Build available refs for relationship queries (target + other vars + creation refs)\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$target\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef && !refs.includes(c.entityRef)) refs.push(c.entityRef);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    // Ensure the name starts with $\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    // Create with empty required fields - validation will flag them\n    onChange({\n      ...generator,\n      variables: {\n        ...variables,\n        [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"\" } },\n      },\n    });\n    setNewVarName(\"\");\n    setShowAddForm(false);\n  };\n\n  const varEntries = Object.entries(variables);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Variables</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What are variables?</div>\n          <div className=\"info-box-text\">\n            Variables let you select additional entities from the graph to use in creation and\n            relationships. For example, you might select a{\" \"}\n            <code className=\"inline-code\">$faction</code> to make a new NPC a member of, or an{\" \"}\n            <code className=\"inline-code\">$ability</code> for them to practice. Variables are\n            selected after <code className=\"inline-code\">$target</code> is chosen.\n          </div>\n        </div>\n\n        {varEntries.length === 0 && !showAddForm ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udce6</div>\n            <div className=\"empty-state-title\">No variables defined</div>\n            <div className=\"empty-state-desc\">\n              Add variables to select additional entities for use in creation and relationships.\n            </div>\n          </div>\n        ) : (\n          varEntries.map(([name, config]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={config}\n              onChange={(updated) =>\n                onChange({ ...generator, variables: { ...variables, [name]: updated } })\n              }\n              onRemove={() => {\n                const newVars = { ...variables };\n                delete newVars[name];\n                onChange({ ...generator, variables: newVars });\n              }}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/analyzeNamingMappings.js::analyzeNamingMappings", "name": "analyzeNamingMappings", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/analyzeNamingMappings.js", "sourceCode": "export function analyzeNamingMappings(generators, schema) {\n  const mappings = [];\n  const warnings = [];\n\n  // Build culture lookup\n  const culturesById = {};\n  (schema.cultures || []).forEach((c) => {\n    culturesById[c.id] = c;\n  });\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    if (!gen.creation || gen.creation.length === 0) continue;\n\n    for (const creation of gen.creation) {\n      const entityKind = creation.kind;\n      // Subtype can be a string or object - ensure we get a string\n      const subtype = typeof creation.subtype === \"string\" ? creation.subtype : null;\n      const prominence = creation.prominence;\n      const tags = creation.tags ? Object.keys(creation.tags) : [];\n\n      // Determine culture source\n      let cultureSource = null;\n      let cultureIds = [];\n\n      if (creation.culture) {\n        if (typeof creation.culture === \"string\") {\n          cultureIds = [creation.culture];\n          cultureSource = \"explicit\";\n        } else if (creation.culture.inherit) {\n          cultureSource = \"inherited\";\n          // Culture is inherited from target - could be any culture\n          cultureIds = Object.keys(culturesById);\n        } else if (creation.culture.from) {\n          cultureSource = \"reference\";\n          cultureIds = Object.keys(culturesById);\n        }\n      } else {\n        // No culture specified - could be any\n        cultureSource = \"any\";\n        cultureIds = Object.keys(culturesById);\n      }\n\n      // Check each possible culture for naming profile match\n      for (const cultureId of cultureIds) {\n        const culture = culturesById[cultureId];\n        const namingConfig = culture?.naming;\n        const hasProfiles = !!namingConfig?.profiles?.length;\n        const match = hasProfiles\n          ? findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags)\n          : null;\n\n        mappings.push({\n          generatorId: gen.id,\n          generatorName: gen.name || gen.id,\n          entityKind,\n          subtype,\n          prominence,\n          cultureId,\n          cultureName: culture?.name || cultureId,\n          cultureColor: culture?.color || \"#888\",\n          cultureSource,\n          hasNamingProfile: hasProfiles,\n          match,\n        });\n\n        // Add warning if no match found\n        if (!match && hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"No matching strategy group\",\n          });\n        } else if (!hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"Culture has no naming profiles\",\n          });\n        }\n      }\n    }\n  }\n\n  return { mappings, warnings };\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}], "returnType": "{ mappings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; prominence: any; cultureId: any; cultureName: any; cultureColor: any; cultureSource: string; hasNamingProfile: boolean; match: { profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }; }[]; warnings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; cultureId: any; cultureName: any; cultureSource: string; reason: string; }[]; }"}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/findMatchingProfile.js::findMatchingProfile", "name": "findMatchingProfile", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/findMatchingProfile.js", "sourceCode": "/**\n * Find which naming profile strategy group matches a given entity creation\n */\n\nexport function findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags = []) {\n  if (!namingConfig?.profiles) return null;\n\n  for (const profile of namingConfig.profiles) {\n    for (const group of profile.strategyGroups || []) {\n      const cond = group.conditions || {};\n\n      // Check entity kind\n      if (cond.entityKinds?.length > 0 && !cond.entityKinds.includes(entityKind)) {\n        continue;\n      }\n\n      // Check subtype\n      if (cond.subtypes?.length > 0) {\n        // Check if subtype matches (same logic for matchAll or matchAny on single entity)\n        if (!subtype || !cond.subtypes.includes(subtype)) continue;\n      }\n\n      // Check prominence\n      if (cond.prominence?.length > 0 && !cond.prominence.includes(prominence)) {\n        continue;\n      }\n\n      // Check tags\n      if (cond.tags?.length > 0) {\n        const entityTags = Array.isArray(tags) ? tags : Object.keys(tags || {});\n        if (cond.tagMatchAll) {\n          // All tags must be present\n          if (!cond.tags.every((t) => entityTags.includes(t))) continue;\n        } else {\n          // Any tag matches\n          if (!cond.tags.some((t) => entityTags.includes(t))) continue;\n        }\n      }\n\n      // Found a match!\n      return {\n        profileId: profile.id,\n        profileName: profile.name,\n        groupName: group.name,\n        strategy: group.strategy,\n        grammarId: group.grammarId,\n      };\n    }\n  }\n\n  return null;\n}", "parameters": [{"name": "namingConfig", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}, {"name": "subtype", "type": "any", "optional": false}, {"name": "prominence", "type": "any", "optional": false}, {"name": "tags", "type": "any[]", "optional": true}], "returnType": "{ profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }"}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js::findMatchingProfile", "name": "findMatchingProfile", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js", "sourceCode": "/**\n * Find which naming profile strategy group matches a given entity creation\n */\n\nexport function findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags = []) {\n  if (!namingConfig?.profiles) return null;\n\n  for (const profile of namingConfig.profiles) {\n    for (const group of profile.strategyGroups || []) {\n      const cond = group.conditions || {};\n\n      // Check entity kind\n      if (cond.entityKinds?.length > 0 && !cond.entityKinds.includes(entityKind)) {\n        continue;\n      }\n\n      // Check subtype\n      if (cond.subtypes?.length > 0) {\n        // Check if subtype matches (same logic for matchAll or matchAny on single entity)\n        if (!subtype || !cond.subtypes.includes(subtype)) continue;\n      }\n\n      // Check prominence\n      if (cond.prominence?.length > 0 && !cond.prominence.includes(prominence)) {\n        continue;\n      }\n\n      // Check tags\n      if (cond.tags?.length > 0) {\n        const entityTags = Array.isArray(tags) ? tags : Object.keys(tags || {});\n        if (cond.tagMatchAll) {\n          // All tags must be present\n          if (!cond.tags.every((t) => entityTags.includes(t))) continue;\n        } else {\n          // Any tag matches\n          if (!cond.tags.some((t) => entityTags.includes(t))) continue;\n        }\n      }\n\n      // Found a match!\n      return {\n        profileId: profile.id,\n        profileName: profile.name,\n        groupName: group.name,\n        strategy: group.strategy,\n        grammarId: group.grammarId,\n      };\n    }\n  }\n\n  return null;\n}", "parameters": [{"name": "namingConfig", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}, {"name": "subtype", "type": "any", "optional": false}, {"name": "prominence", "type": "any", "optional": false}, {"name": "tags", "type": "any[]", "optional": true}], "returnType": "{ profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }"}, {"id": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js::analyzeNamingMappings", "name": "analyzeNamingMappings", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/naming-profile-viewer/utils/index.js", "sourceCode": "export function analyzeNamingMappings(generators, schema) {\n  const mappings = [];\n  const warnings = [];\n\n  // Build culture lookup\n  const culturesById = {};\n  (schema.cultures || []).forEach((c) => {\n    culturesById[c.id] = c;\n  });\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    if (!gen.creation || gen.creation.length === 0) continue;\n\n    for (const creation of gen.creation) {\n      const entityKind = creation.kind;\n      // Subtype can be a string or object - ensure we get a string\n      const subtype = typeof creation.subtype === \"string\" ? creation.subtype : null;\n      const prominence = creation.prominence;\n      const tags = creation.tags ? Object.keys(creation.tags) : [];\n\n      // Determine culture source\n      let cultureSource = null;\n      let cultureIds = [];\n\n      if (creation.culture) {\n        if (typeof creation.culture === \"string\") {\n          cultureIds = [creation.culture];\n          cultureSource = \"explicit\";\n        } else if (creation.culture.inherit) {\n          cultureSource = \"inherited\";\n          // Culture is inherited from target - could be any culture\n          cultureIds = Object.keys(culturesById);\n        } else if (creation.culture.from) {\n          cultureSource = \"reference\";\n          cultureIds = Object.keys(culturesById);\n        }\n      } else {\n        // No culture specified - could be any\n        cultureSource = \"any\";\n        cultureIds = Object.keys(culturesById);\n      }\n\n      // Check each possible culture for naming profile match\n      for (const cultureId of cultureIds) {\n        const culture = culturesById[cultureId];\n        const namingConfig = culture?.naming;\n        const hasProfiles = !!namingConfig?.profiles?.length;\n        const match = hasProfiles\n          ? findMatchingProfile(namingConfig, entityKind, subtype, prominence, tags)\n          : null;\n\n        mappings.push({\n          generatorId: gen.id,\n          generatorName: gen.name || gen.id,\n          entityKind,\n          subtype,\n          prominence,\n          cultureId,\n          cultureName: culture?.name || cultureId,\n          cultureColor: culture?.color || \"#888\",\n          cultureSource,\n          hasNamingProfile: hasProfiles,\n          match,\n        });\n\n        // Add warning if no match found\n        if (!match && hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"No matching strategy group\",\n          });\n        } else if (!hasProfiles) {\n          warnings.push({\n            generatorId: gen.id,\n            generatorName: gen.name || gen.id,\n            entityKind,\n            subtype,\n            cultureId,\n            cultureName: culture?.name || cultureId,\n            cultureSource,\n            reason: \"Culture has no naming profiles\",\n          });\n        }\n      }\n    }\n  }\n\n  return { mappings, warnings };\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}], "returnType": "{ mappings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; prominence: any; cultureId: any; cultureName: any; cultureColor: any; cultureSource: string; hasNamingProfile: boolean; match: { profileId: any; profileName: any; groupName: any; strategy: any; grammarId: any; }; }[]; warnings: { generatorId: any; generatorName: any; entityKind: any; subtype: any; cultureId: any; cultureName: any; cultureSource: string; reason: string; }[]; }"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::formatValidationForExport", "name": "formatValidationForExport", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "/**\n * Export functions for validation results\n */\n\nexport function formatValidationForExport(validationResults) {\n  const items = [];\n\n  // Process errors\n  for (const error of validationResults.errors) {\n    for (const item of error.affectedItems) {\n      items.push({\n        severity: \"ERROR\",\n        category: error.id,\n        title: error.title,\n        message: error.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  // Process warnings\n  for (const warning of validationResults.warnings) {\n    for (const item of warning.affectedItems) {\n      items.push({\n        severity: \"WARNING\",\n        category: warning.id,\n        title: warning.title,\n        message: warning.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  return items;\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "{ severity: string; category: any; title: any; message: any; itemId: any; itemLabel: any; detail: any; }[]"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::exportAsJson", "name": "exportAsJson", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "export function exportAsJson(validationResults) {\n  const items = formatValidationForExport(validationResults);\n  const json = JSON.stringify(\n    {\n      exportedAt: new Date().toISOString(),\n      summary: {\n        errorCount: validationResults.errors.length,\n        warningCount: validationResults.warnings.length,\n        totalItems: items.length,\n      },\n      issues: items,\n    },\n    null,\n    2\n  );\n\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.json`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js::exportAsCsv", "name": "exportAsCsv", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/exportFunctions.js", "sourceCode": "export function exportAsCsv(validationResults) {\n  const items = formatValidationForExport(validationResults);\n\n  // CSV header\n  const headers = [\"Severity\", \"Category\", \"Title\", \"Message\", \"Item ID\", \"Item Label\", \"Detail\"];\n\n  // Escape CSV field\n  const escapeField = (field) => {\n    const str = String(field || \"\");\n    if (str.includes(\",\") || str.includes('\"') || str.includes(\"\\n\")) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n\n  // Build CSV rows\n  const rows = [\n    headers.join(\",\"),\n    ...items.map((item) =>\n      [\n        item.severity,\n        item.category,\n        escapeField(item.title),\n        escapeField(item.message),\n        escapeField(item.itemId),\n        escapeField(item.itemLabel),\n        escapeField(item.detail),\n      ].join(\",\")\n    ),\n  ];\n\n  const csv = rows.join(\"\\n\");\n  const blob = new Blob([csv], { type: \"text/csv\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.csv`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::formatValidationForExport", "name": "formatValidationForExport", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "/**\n * Export functions for validation results\n */\n\nexport function formatValidationForExport(validationResults) {\n  const items = [];\n\n  // Process errors\n  for (const error of validationResults.errors) {\n    for (const item of error.affectedItems) {\n      items.push({\n        severity: \"ERROR\",\n        category: error.id,\n        title: error.title,\n        message: error.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  // Process warnings\n  for (const warning of validationResults.warnings) {\n    for (const item of warning.affectedItems) {\n      items.push({\n        severity: \"WARNING\",\n        category: warning.id,\n        title: warning.title,\n        message: warning.message,\n        itemId: item.id,\n        itemLabel: item.label,\n        detail: item.detail || \"\",\n      });\n    }\n  }\n\n  return items;\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "{ severity: string; category: any; title: any; message: any; itemId: any; itemLabel: any; detail: any; }[]"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::exportAsJson", "name": "exportAsJson", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function exportAsJson(validationResults) {\n  const items = formatValidationForExport(validationResults);\n  const json = JSON.stringify(\n    {\n      exportedAt: new Date().toISOString(),\n      summary: {\n        errorCount: validationResults.errors.length,\n        warningCount: validationResults.warnings.length,\n        totalItems: items.length,\n      },\n      issues: items,\n    },\n    null,\n    2\n  );\n\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.json`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::exportAsCsv", "name": "exportAsCsv", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function exportAsCsv(validationResults) {\n  const items = formatValidationForExport(validationResults);\n\n  // CSV header\n  const headers = [\"Severity\", \"Category\", \"Title\", \"Message\", \"Item ID\", \"Item Label\", \"Detail\"];\n\n  // Escape CSV field\n  const escapeField = (field) => {\n    const str = String(field || \"\");\n    if (str.includes(\",\") || str.includes('\"') || str.includes(\"\\n\")) {\n      return `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n  };\n\n  // Build CSV rows\n  const rows = [\n    headers.join(\",\"),\n    ...items.map((item) =>\n      [\n        item.severity,\n        item.category,\n        escapeField(item.title),\n        escapeField(item.message),\n        escapeField(item.itemId),\n        escapeField(item.itemLabel),\n        escapeField(item.detail),\n      ].join(\",\")\n    ),\n  ];\n\n  const csv = rows.join(\"\\n\");\n  const blob = new Blob([csv], { type: \"text/csv\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `validation-report-${new Date().toISOString().split(\"T\")[0]}.csv`;\n  a.click();\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "validationResults", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::runValidations", "name": "runValidations", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "/**\n * Run all validations\n * @param {Object} usageMap - Pre-computed usage map from computeUsageMap\n * @param {Object} schema - Domain schema\n * @param {Array} eras - Era configurations\n * @param {Array} pressures - Pressure configurations\n * @param {Array} generators - Generator configurations\n * @param {Array} systems - System configurations\n */\nexport function runValidations(usageMap, schema, eras, pressures, generators, systems) {\n  const results = {\n    errors: [],\n    warnings: [],\n  };\n\n  // Run each validation rule\n  // Rules that use usageMap only\n  const usageMapRules = [\n    () => validationRules.invalidEntityKind(usageMap),\n    () => validationRules.invalidRelationshipKind(usageMap),\n    () => validationRules.invalidPressureId(usageMap),\n    () => validationRules.invalidEraTemplateRef(usageMap),\n    () => validationRules.invalidEraSystemRef(usageMap),\n    () => validationRules.orphanGenerators(usageMap),\n    () => validationRules.orphanSystems(usageMap),\n    () => validationRules.relationshipCompatibility(usageMap),\n  ];\n\n  // Rules that need additional data\n  const dataRules = [\n    () => validationRules.pressureWithoutSources(usageMap, pressures, generators, systems),\n    () => validationRules.pressureWithoutSinks(usageMap, pressures, generators, systems),\n    () => validationRules.zeroWeightGenerators(usageMap, eras, generators),\n    () => validationRules.invalidSubtypeRef(usageMap, schema, generators, pressures),\n    () => validationRules.invalidStatusRef(usageMap, schema, generators),\n    () => validationRules.invalidCultureRef(usageMap, schema),\n    () => validationRules.undefinedTagRefs(usageMap, schema),\n    () => validationRules.conflictingTagsInUse(usageMap, schema, generators),\n    () => validationRules.numericRangeIssues(usageMap, pressures, eras),\n  ];\n\n  const allRules = [...usageMapRules, ...dataRules];\n\n  for (const rule of allRules) {\n    const result = rule();\n    if (result) {\n      if (result.severity === \"error\") {\n        results.errors.push(result);\n      } else {\n        results.warnings.push(result);\n      }\n    }\n  }\n\n  return results;\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any[]", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}, {"name": "generators", "type": "any[]", "optional": false}, {"name": "systems", "type": "any[]", "optional": false}], "returnType": "{ errors: any[]; warnings: any[]; }"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/index.js::getOverallStatus", "name": "getOverallStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/index.js", "sourceCode": "export function getOverallStatus(results) {\n  if (results.errors.length > 0) return \"error\";\n  if (results.warnings.length > 0) return \"warning\";\n  return \"clean\";\n}", "parameters": [{"name": "results", "type": "any", "optional": false}], "returnType": "\"error\" | \"warning\" | \"clean\""}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js::runValidations", "name": "runValidations", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js", "sourceCode": "/**\n * Run all validations\n * @param {Object} usageMap - Pre-computed usage map from computeUsageMap\n * @param {Object} schema - Domain schema\n * @param {Array} eras - Era configurations\n * @param {Array} pressures - Pressure configurations\n * @param {Array} generators - Generator configurations\n * @param {Array} systems - System configurations\n */\nexport function runValidations(usageMap, schema, eras, pressures, generators, systems) {\n  const results = {\n    errors: [],\n    warnings: [],\n  };\n\n  // Run each validation rule\n  // Rules that use usageMap only\n  const usageMapRules = [\n    () => validationRules.invalidEntityKind(usageMap),\n    () => validationRules.invalidRelationshipKind(usageMap),\n    () => validationRules.invalidPressureId(usageMap),\n    () => validationRules.invalidEraTemplateRef(usageMap),\n    () => validationRules.invalidEraSystemRef(usageMap),\n    () => validationRules.orphanGenerators(usageMap),\n    () => validationRules.orphanSystems(usageMap),\n    () => validationRules.relationshipCompatibility(usageMap),\n  ];\n\n  // Rules that need additional data\n  const dataRules = [\n    () => validationRules.pressureWithoutSources(usageMap, pressures, generators, systems),\n    () => validationRules.pressureWithoutSinks(usageMap, pressures, generators, systems),\n    () => validationRules.zeroWeightGenerators(usageMap, eras, generators),\n    () => validationRules.invalidSubtypeRef(usageMap, schema, generators, pressures),\n    () => validationRules.invalidStatusRef(usageMap, schema, generators),\n    () => validationRules.invalidCultureRef(usageMap, schema),\n    () => validationRules.undefinedTagRefs(usageMap, schema),\n    () => validationRules.conflictingTagsInUse(usageMap, schema, generators),\n    () => validationRules.numericRangeIssues(usageMap, pressures, eras),\n  ];\n\n  const allRules = [...usageMapRules, ...dataRules];\n\n  for (const rule of allRules) {\n    const result = rule();\n    if (result) {\n      if (result.severity === \"error\") {\n        results.errors.push(result);\n      } else {\n        results.warnings.push(result);\n      }\n    }\n  }\n\n  return results;\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "schema", "type": "any", "optional": false}, {"name": "eras", "type": "any[]", "optional": false}, {"name": "pressures", "type": "any[]", "optional": false}, {"name": "generators", "type": "any[]", "optional": false}, {"name": "systems", "type": "any[]", "optional": false}], "returnType": "{ errors: any[]; warnings: any[]; }"}, {"id": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js::getOverallStatus", "name": "getOverallStatus", "kind": "function", "filePath": "apps/coherence-engine/webui/src/components/validation/utils/validationRules.js", "sourceCode": "export function getOverallStatus(results) {\n  if (results.errors.length > 0) return \"error\";\n  if (results.warnings.length > 0) return \"warning\";\n  return \"clean\";\n}", "parameters": [{"name": "results", "type": "any", "optional": false}], "returnType": "\"error\" | \"warning\" | \"clean\""}]