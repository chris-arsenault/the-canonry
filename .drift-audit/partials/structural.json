[
  {
    "id": "typescript-javascript-migration-state",
    "name": "TypeScript/JavaScript Migration State",
    "type": "structural",
    "description": "The monorepo has 824 source files split roughly 50/50 between TypeScript (424 .ts/.tsx) and JavaScript (392 .js/.jsx), but the distribution is wildly inconsistent across apps. Some apps are fully TypeScript, some fully JavaScript, some have clean separation by directory, and one (illuminator) has .ts and .js files interleaved in the same directories. The shared-components package — consumed by every MFE — is 100% JavaScript with PropTypes instead of TypeScript interfaces.",
    "impact": "HIGH",
    "total_files": 824,
    "variants": [
      {
        "name": "fully-typescript",
        "description": "Apps written entirely or nearly entirely in TypeScript/TSX. All components use TypeScript interfaces for props, import type {} syntax for type-only imports, and have tsconfig.json with project references. archivist has 21 .ts/.tsx files and 1 .js file; chronicler has 23 .ts/.tsx and 1 .js file; world-schema has 20 .ts and 0 .js.",
        "file_count": 65,
        "files": [
          "apps/archivist/webui/src/ArchivistRemote.tsx",
          "apps/archivist/webui/src/components/EntityDetail.tsx",
          "apps/archivist/webui/src/types/world.ts",
          "apps/chronicler/webui/src/ChroniclerRemote.tsx",
          "apps/chronicler/webui/src/components/WikiExplorer.tsx",
          "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts",
          "packages/world-schema/src/index.ts"
        ],
        "sample_file": "apps/archivist/webui/src/components/EntityDetail.tsx",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/src/components/EntityDetail.tsx",
            "start_line": 1,
            "end_line": 24,
            "snippet": "import React, { useState, useCallback } from \"react\";\nimport type {\n  WorldState,\n  LoreData,\n  DescriptionLore,\n  RelationshipBackstoryLore,\n  ChainLinkLore,\n  DiscoveryEventLore,\n  Region,\n} from \"../types/world.ts\";\nimport {\n  getEntityById,\n  getRelatedEntities,\n  getRelationships,\n  getTagsArray,\n} from \"../utils/dataTransform.ts\";\nimport { useImageUrl } from \"@the-canonry/image-store\";\nimport LoreSection from \"./LoreSection.tsx\";\nimport RelationshipStoryModal from \"./RelationshipStoryModal.tsx\";\nimport ChainLinkSection from \"./ChainLinkSection.tsx\";\nimport DiscoveryStory from \"./DiscoveryStory.tsx\";\nimport \"./EntityDetail.css\";\n\ninterface EntityDetailProps {"
          }
        ],
        "implementation_details": "These apps have full tsconfig.json with project references (tsconfig.app.json + tsconfig.node.json), use explicit .tsx/.ts file extensions in local imports, define TypeScript interfaces for all component props, and use 'import type {}' for type-only imports. They represent the target state of the migration. archivist and chronicler are the newest apps in the monorepo and were built with TypeScript from the start."
      },
      {
        "name": "library-typescript-webui-javascript",
        "description": "Apps with a clean directory-level split: the core library (lib/) is written in strict TypeScript, while the web UI (webui/) is written entirely in JavaScript/JSX. lore-weave has 87 .ts in lib/ and 28 .jsx in webui/; name-forge has 36 .ts in lib/ and 28 .jsx in webui/; cosmographer has 16 .ts in lib/ and 8 .jsx in webui/. One exception: lore-weave has a single .ts hook (useSimulationWorker.ts) that bridges the worker/UI type boundary.",
        "file_count": 203,
        "files": [
          "apps/lore-weave/lib/engine/worldEngine.ts",
          "apps/lore-weave/lib/engine/templateInterpreter.ts",
          "apps/lore-weave/webui/src/LoreWeaveRemote.jsx",
          "apps/lore-weave/webui/src/hooks/useSimulationWorker.ts",
          "apps/name-forge/lib/generate.ts",
          "apps/name-forge/webui/src/lib/browser-generator.js",
          "apps/cosmographer/lib/generator/index.ts",
          "apps/cosmographer/webui/src/CosmographerRemote.jsx"
        ],
        "sample_file": "apps/name-forge/webui/src/lib/browser-generator.js",
        "code_excerpts": [
          {
            "file": "apps/name-forge/webui/src/lib/browser-generator.js",
            "start_line": 1,
            "end_line": 15,
            "snippet": "/**\n * Browser-compatible name generator\n *\n * Thin wrapper around the name-forge lib.\n */\n\nimport { generate, generateFromDomain, previewGrammar } from '@lib/generate.js';\nimport { setMarkovBaseUrl } from '@lib/markov-loader.js';\n\n// Configure base URL for Markov models in browser\nsetMarkovBaseUrl(`${import.meta.env.BASE_URL}markov-models`);\n\nfunction toNameForgeCulture(culture) {\n  if (!culture) return null;\n  const naming = culture.naming || {};"
          }
        ],
        "implementation_details": "The TypeScript library code uses strict mode ('strict': true in tsconfig.json) with full type annotations, while the JavaScript UI code has no type annotations, no JSDoc @ts-check directives, and no tsconfig.json for the webui directory (name-forge, cosmographer). lore-weave's webui/ does have a tsconfig with 'allowJs: true' but the JS files contain zero type annotations. This split is semi-intentional — the library is the 'important' code — but means UI bugs from type errors go undetected."
      },
      {
        "name": "mixed-typescript-javascript-same-directories",
        "description": "Illuminator is the most complex app (272 files) and has .ts and .js files interleaved in the same directories. The hooks/ directory alone contains 13 .js hooks and 19 .ts hooks side by side. Components/ has 37 .tsx files mixed with 67 .jsx files. The tsconfig uses 'strict: false' and 'allowJs: true' to permit this coexistence. The .ts files use full type imports and interface definitions; the .js files have zero type annotations.",
        "file_count": 272,
        "files": [
          "apps/illuminator/webui/src/hooks/useApiKeys.js",
          "apps/illuminator/webui/src/hooks/useBackportFlow.js",
          "apps/illuminator/webui/src/hooks/useHistorianCallbacks.js",
          "apps/illuminator/webui/src/hooks/useConfigSync.js",
          "apps/illuminator/webui/src/hooks/useBulkBackport.ts",
          "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
          "apps/illuminator/webui/src/hooks/useEraNarrative.ts",
          "apps/illuminator/webui/src/hooks/useEntityCrud.ts",
          "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
          "apps/illuminator/webui/src/components/CreateEntityModal.tsx",
          "apps/illuminator/webui/src/lib/db/entityStore.ts",
          "apps/illuminator/webui/src/lib/db/chronicleStore.ts"
        ],
        "sample_file": "apps/illuminator/webui/src/hooks/useApiKeys.js",
        "code_excerpts": [
          {
            "file": "apps/illuminator/webui/src/hooks/useApiKeys.js",
            "start_line": 1,
            "end_line": 12,
            "snippet": "import { useState, useEffect } from \"react\";\n\nfunction readPersistedFlag(key) {\n  try {\n    return localStorage.getItem(key) === \"true\";\n  } catch {\n    return false;\n  }\n}\n\nfunction readPersistedApiKey(keyName) {\n  try {"
          },
          {
            "file": "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
            "start_line": 9,
            "end_line": 25,
            "snippet": "import { useCallback } from \"react\";\nimport type { ChronicleGenerationContext, ChronicleSampling } from \"../lib/chronicleTypes\";\nimport type { EnrichmentType, ChronicleStep } from \"../lib/enrichmentTypes\";\nimport { getEnqueue } from \"../lib/db/enrichmentQueueBridge\";\nimport { useChronicleStore } from \"../lib/db/chronicleStore\";\nimport type { ChronicleRecord } from \"../lib/db/chronicleRepository\";\n\nexport interface ChronicleMetadata {\n  chronicleId: string;\n  title?: string;\n  format: \"story\" | \"document\";\n  generationSampling: ChronicleSampling;\n  roleAssignments: Array<{\n    role: string;\n    entityId: string;\n    entityName: string;\n    entityKind: string;"
          }
        ],
        "implementation_details": "The illuminator app has 153 .ts files and 82 .js files in its webui directory. The lib/db/ subdirectory is fully TypeScript (Dexie stores, type definitions), while the hooks/ directory is 40% JS and 60% TS. The .js hooks were written alongside .ts hooks — both patterns coexist without any migration deadline. tsconfig.app.json has 'strict: false' and 'allowJs: true', meaning TypeScript provides essentially no safety guarantees in this app. New code is being added in both extensions."
      },
      {
        "name": "fully-javascript-no-tsconfig",
        "description": "canonry (47 files) and coherence-engine (115 files) are 100% JavaScript with no tsconfig.json, no JSDoc type annotations, and no plans for TypeScript migration. Both are significant apps with complex component trees.",
        "file_count": 162,
        "files": [
          "apps/canonry/webui/src/App.jsx",
          "apps/canonry/webui/src/stores/useCanonryUiStore.js",
          "apps/canonry/webui/src/storage/worldStore.js",
          "apps/coherence-engine/webui/src/CoherenceEngineRemote.jsx",
          "apps/coherence-engine/webui/src/components/ActionsEditor.jsx",
          "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx"
        ],
        "sample_file": "apps/coherence-engine/webui/src/components/ActionsEditor.jsx",
        "code_excerpts": [
          {
            "file": "apps/coherence-engine/webui/src/components/ActionsEditor.jsx",
            "start_line": 1,
            "end_line": 5,
            "snippet": "/**\n * ActionsEditor - Re-exports from modular actions/ folder\n */\n\nexport { default } from \"./actions\";"
          }
        ],
        "implementation_details": "canonry is the shell/host MFE that orchestrates all other apps. coherence-engine is the validation and configuration editor — the second-largest webui by file count (115 files). Neither has any TypeScript tooling configured. These apps use PropTypes for runtime type checking where it's used at all. Given that coherence-engine directly manipulates schema.json configuration consumed by typed TypeScript libraries (lore-weave, name-forge), the lack of compile-time type safety creates a gap where invalid configuration can be authored without detection."
      },
      {
        "name": "shared-components-javascript-with-proptypes",
        "description": "The shared-components package (37 files) is 100% JavaScript using PropTypes for runtime type validation. This package is consumed by every MFE app via @the-canonry/shared-components. It provides foundational UI components (ModalShell, FormGroup, TagSelector, etc.) without TypeScript declarations, forcing consuming TypeScript apps to use it without type safety.",
        "file_count": 37,
        "files": [
          "packages/shared-components/src/index.js",
          "packages/shared-components/src/TagSelector.jsx",
          "packages/shared-components/src/components/ModalShell.jsx",
          "packages/shared-components/src/components/FormGroup.jsx",
          "packages/shared-components/src/components/EmptyState.jsx"
        ],
        "sample_file": "packages/shared-components/src/index.js",
        "code_excerpts": [
          {
            "file": "packages/shared-components/src/index.js",
            "start_line": 1,
            "end_line": 15,
            "snippet": "/**\n * Shared Components for Canonry MFEs\n *\n * Re-exports UI components, form components, hooks, and utilities\n * that can be shared across all micro-frontends.\n *\n * CSS styles are available via: import '@the-canonry/shared-components/styles'\n */\n\n// Canonry-specific components\nexport { default as TagSelector } from './TagSelector.jsx';\n\n// Badge components\nexport { ToolUsageBadges } from './components/badges';\nexport { DetailUsageBadges } from './components/badges';"
          }
        ],
        "implementation_details": "shared-components is the cross-cutting dependency consumed by archivist, chronicler, illuminator, coherence-engine, and canonry. It uses PropTypes (import PropTypes from 'prop-types') instead of TypeScript interfaces. There are no .d.ts declaration files. TypeScript-consuming apps (archivist, chronicler) must rely on Vite's implicit 'any' for these imports. This is the highest-impact gap because it's the shared foundation layer — migrating it to TypeScript would immediately benefit all consuming apps."
      }
    ],
    "analysis": "The monorepo exhibits five distinct TypeScript adoption states across nine apps, with no single migration trajectory. The divergence appears evolutionary rather than intentional: the oldest apps (canonry, coherence-engine) were written in JavaScript before TypeScript was adopted; library-focused apps (lore-weave, name-forge) typed their core code but left UIs untyped; the newest apps (archivist, chronicler) were built in TypeScript from the start; and illuminator is mid-migration with both extensions coexisting in the same directories under 'strict: false'. The critical structural issue is that shared-components — the universal dependency — remains in JavaScript with PropTypes, creating a type safety gap at the foundation layer. Convergence would mean: (1) migrating shared-components to TypeScript first, (2) adding tsconfig.json to canonry and coherence-engine, (3) enabling 'strict: true' in illuminator and converting remaining .js files, (4) adding tsconfig to webui dirs in lore-weave/name-forge/cosmographer.",
    "recommendation": "Start with shared-components: convert its 37 files to .tsx with TypeScript interfaces replacing PropTypes. This immediately benefits all consuming TS apps. Then add tsconfig.json (with allowJs: true, strict: false as a first step) to canonry and coherence-engine. For illuminator, enforce a rule that new files must be .ts/.tsx and incrementally convert the 13 remaining .js hooks.",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "component-organization-pattern",
    "name": "Component Directory Organization",
    "type": "structural",
    "description": "MFE apps use three fundamentally different patterns for organizing component files within webui/src/components/: flat single-file components, deeply nested feature directories with barrel index exports, and a hybrid approach. This affects import ergonomics, code discoverability, and the mechanics of adding new components.",
    "impact": "MEDIUM",
    "total_files": 500,
    "variants": [
      {
        "name": "flat-single-file-components",
        "description": "All component files live at the top level of components/ with no subdirectories. Each component is a single PascalCase file with a co-located .css file. archivist has 30 top-level files and 0 subdirectories; canonry has 14 files and 1 subdirectory (SchemaEditor); chronicler has 20 files and 0 subdirectories.",
        "file_count": 64,
        "files": [
          "apps/archivist/webui/src/components/EntityDetail.tsx",
          "apps/archivist/webui/src/components/GraphView.tsx",
          "apps/archivist/webui/src/components/FilterPanel.tsx",
          "apps/chronicler/webui/src/components/WikiExplorer.tsx",
          "apps/chronicler/webui/src/components/WikiPage.tsx",
          "apps/canonry/webui/src/components/HelpModal.jsx"
        ],
        "sample_file": "apps/archivist/webui/src/components/EntityDetail.tsx",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/src/components/EntityDetail.tsx",
            "start_line": 1,
            "end_line": 10,
            "snippet": "import React, { useState, useCallback } from \"react\";\nimport type {\n  WorldState,\n  LoreData,\n  DescriptionLore,\n  RelationshipBackstoryLore,\n  ChainLinkLore,\n  DiscoveryEventLore,\n  Region,\n} from \"../types/world.ts\";"
          }
        ],
        "implementation_details": "Components are single PascalCase-named files (EntityDetail.tsx, GraphView.tsx) with co-located PascalCase.css files. No barrel index.js files. No subdirectory grouping. Components import each other via relative paths (import LoreSection from './LoreSection.tsx'). This pattern is simple and discoverable but becomes unwieldy as component count grows — archivist has 30 files in a single flat directory."
      },
      {
        "name": "deeply-nested-feature-directories-with-barrel-exports",
        "description": "Components are organized into feature directories (actions/, generators/, eras/, pressures/, systems/, validation/) each with subdirectories (cards/, tabs/, modals/, shared/) and barrel index.js re-exports at every level. coherence-engine has 11 top-level subdirectories, 28 nested directories total, and 28 barrel index.js files. name-forge uses a similar pattern with 7 top-level feature directories.",
        "file_count": 200,
        "files": [
          "apps/coherence-engine/webui/src/components/actions/index.js",
          "apps/coherence-engine/webui/src/components/actions/cards/index.js",
          "apps/coherence-engine/webui/src/components/actions/modals/index.js",
          "apps/coherence-engine/webui/src/components/generators/index.js",
          "apps/coherence-engine/webui/src/components/generators/tabs/index.js",
          "apps/name-forge/webui/src/components/generator/index.js",
          "apps/name-forge/webui/src/components/workspace/index.js",
          "apps/lore-weave/webui/src/components/dashboard/index.js"
        ],
        "sample_file": "apps/coherence-engine/webui/src/components/actions/index.js",
        "code_excerpts": [
          {
            "file": "apps/coherence-engine/webui/src/components/actions/index.js",
            "start_line": 1,
            "end_line": 8,
            "snippet": "/**\n * ActionsEditor module\n *\n * Main entry point - only exports the main component.\n * Internal modules (cards, modals, shared, tabs) are used internally.\n */\n\nexport { default, ActionsEditor } from \"./ActionsEditor\";"
          }
        ],
        "implementation_details": "Each feature has a hierarchical structure: feature/index.js (barrel re-export) → feature/FeatureEditor.jsx (main component) → feature/cards/ (card sub-components), feature/tabs/ (tab sub-components), feature/modals/ (modal sub-components). Every directory has an index.js barrel. Consumers import via the feature barrel: import { ActionsEditor } from './components/actions'. This pattern provides excellent encapsulation but requires maintaining 28+ barrel files. Only coherence-engine fully commits to this pattern; lore-weave and name-forge use it partially."
      },
      {
        "name": "flat-with-massive-file-count",
        "description": "illuminator has 128 top-level component files and only 3 subdirectories (ChronicleWizard/, plus 2 others). This is the flat pattern pushed to its limit — a single directory with 128 files, each a component plus its CSS file.",
        "file_count": 128,
        "files": [
          "apps/illuminator/webui/src/components/ActivityPanel.jsx",
          "apps/illuminator/webui/src/components/BackportConfigModal.jsx",
          "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
          "apps/illuminator/webui/src/components/EntityBrowser.jsx",
          "apps/illuminator/webui/src/components/EntityDetailView.jsx",
          "apps/illuminator/webui/src/components/CreateEntityModal.tsx",
          "apps/illuminator/webui/src/components/CorpusFindReplace.tsx"
        ],
        "sample_file": "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
        "code_excerpts": [
          {
            "file": "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
            "start_line": 1,
            "end_line": 8,
            "snippet": "/**\n * ChroniclePanel - Chronicle navigation, generation controls, and detail view.\n *\n * A single-panel layout that shows a filterable sidebar of chronicles\n * (organized by era) alongside a detail area for the selected chronicle.\n * Generation, deletion, backport, and image-generation controls are\n * integrated directly into the detail view.\n */"
          }
        ],
        "implementation_details": "This is the flat pattern from archivist/chronicler but at 128 files — making the components/ directory extremely dense. The ChroniclePanel.jsx alone is 2621 lines. Files are sorted alphabetically by OS but there is no logical grouping. Finding related components (e.g., all chronicle-related components) requires knowing their naming prefix (Chronicle*, BulkChronicle*, etc.) rather than navigating a directory tree. This suggests the app outgrew the flat pattern without being restructured."
      },
      {
        "name": "directory-per-component-with-barrel",
        "description": "cosmographer wraps each component in its own PascalCase directory with an index.jsx barrel. Components are imported via the directory name rather than the file name. 5 top-level directories, 0 top-level files.",
        "file_count": 15,
        "files": [
          "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx",
          "apps/cosmographer/webui/src/components/CultureEditor/index.jsx",
          "apps/cosmographer/webui/src/components/EntityEditor/index.jsx",
          "apps/cosmographer/webui/src/components/RelationshipEditor/index.jsx",
          "apps/cosmographer/webui/src/components/SemanticPlane/index.jsx"
        ],
        "sample_file": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx",
        "code_excerpts": [
          {
            "file": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx",
            "start_line": 1,
            "end_line": 1,
            "snippet": "// (barrel export from AxisRegistry directory)"
          }
        ],
        "implementation_details": "Each top-level component gets its own PascalCase directory (AxisRegistry/, CultureEditor/, etc.) with an index.jsx barrel export. Sub-components and CSS live inside the directory. This is the 'one directory per component' pattern common in larger React apps. Only cosmographer uses this pattern in the monorepo."
      }
    ],
    "analysis": "The component organization divergence correlates roughly with app size and age. Smaller/newer apps (archivist: 30 files, chronicler: 20 files) use a flat pattern that works well at their scale. coherence-engine (115 files) uses deep nesting with barrels, which provides good encapsulation but requires maintaining many index.js files. illuminator (128+ top-level files) has outgrown its flat structure — 128 files in a single directory is hard to navigate. cosmographer uses directory-per-component, which is standard in the React ecosystem but unique in this monorepo. The lack of a consistent convention means developers switching between apps must learn different component location patterns each time.",
    "recommendation": "Adopt a two-tier convention: flat for apps with <30 components (archivist, canonry, chronicler, cosmographer), feature-directory with barrel exports for larger apps (coherence-engine, illuminator, name-forge, lore-weave). The immediate win is restructuring illuminator's 128-file flat directory into feature groups (chronicle/, entity/, historian/, backport/, etc.).",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "css-architecture-and-scoping",
    "name": "CSS Architecture and Scoping Strategy",
    "type": "structural",
    "description": "Three fundamentally different CSS architectures coexist across the MFEs: standard co-located CSS with manual prefix namespacing (7 apps), CSS Modules with automatic scoping (1 app), and a centralized design system directory with reusable component styles (1 app). Class naming conventions also diverge — some use full component names (.entity-detail-header), others use 2-3 letter abbreviations (.edv-meta-row, .chron-card), and CSS Modules use generic semantic names (.container, .heading).",
    "impact": "MEDIUM",
    "total_files": 215,
    "variants": [
      {
        "name": "co-located-css-with-manual-prefix-namespacing",
        "description": "Each component has a co-located PascalCase.css file imported directly. Class names are manually namespaced using a component-specific prefix to avoid global collisions. illuminator uses 2-4 letter abbreviations (.chron-*, .edv-*, .abm-*); archivist uses full names (.entity-detail-*) or short abbreviations (.ed-*). 7 apps (archivist, canonry, cosmographer, illuminator, lore-weave, name-forge, viewer) use this pattern.",
        "file_count": 158,
        "files": [
          "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
          "apps/illuminator/webui/src/components/EntityDetailView.jsx",
          "apps/archivist/webui/src/components/EntityDetail.css",
          "apps/canonry/webui/src/components/HelpModal.css",
          "apps/lore-weave/webui/src/components/dashboard/trace/SimulationTraceVisx.jsx"
        ],
        "sample_file": "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
        "code_excerpts": [
          {
            "file": "apps/illuminator/webui/src/components/ChroniclePanel.jsx",
            "start_line": 1,
            "end_line": 5,
            "snippet": "/* CSS classes use .chron-* prefix for namespace isolation */\n.chron-card { ... }\n.chron-card-default { ... }\n.chron-card-selected { ... }\n.chron-card-title-row { ... }"
          },
          {
            "file": "apps/archivist/webui/src/components/EntityDetail.css",
            "start_line": 1,
            "end_line": 5,
            "snippet": "/* Full component name prefix */\n.entity-detail { ... }\n.entity-detail-header { ... }\n.entity-detail-name { ... }\n/* But also abbreviated: */ .ed-culture-badge { ... }"
          }
        ],
        "implementation_details": "The most common pattern (7 of 9 apps). Each component imports its CSS directly: import './ChroniclePanel.css'. Classes use a component-derived prefix to avoid global namespace collisions. The prefix convention is inconsistent: illuminator abbreviates heavily (.chron- for ChroniclePanel, .edv- for EntityDetailView, .abm- for ActivityBrowserModal), while archivist mixes full names (.entity-detail-) with abbreviations (.ed-). Some files even mix both conventions internally. This pattern provides zero compile-time scoping guarantees — a typo in a class name silently fails."
      },
      {
        "name": "css-modules-scoped",
        "description": "chronicler uses CSS Modules (.module.css files) that provide automatic compile-time class name scoping. CSS classes use short semantic names (.container, .heading, .controls) because the module loader adds unique suffixes. A shared variables.css file in styles/ provides design tokens.",
        "file_count": 12,
        "files": [
          "apps/chronicler/webui/src/components/ChronicleIndex.module.css",
          "apps/chronicler/webui/src/components/WikiExplorer.module.css",
          "apps/chronicler/webui/src/components/WikiNav.module.css",
          "apps/chronicler/webui/src/components/EntityTimeline.module.css",
          "apps/chronicler/webui/src/styles/variables.css"
        ],
        "sample_file": "apps/chronicler/webui/src/components/ChronicleIndex.module.css",
        "code_excerpts": [
          {
            "file": "apps/chronicler/webui/src/components/ChronicleIndex.module.css",
            "start_line": 1,
            "end_line": 6,
            "snippet": "/* CSS Modules — short semantic names, scoped automatically */\n.container { ... }\n.heading { ... }\n.description { ... }\n.description-row { ... }\n.controls { ... }"
          }
        ],
        "implementation_details": "chronicler is the only app using CSS Modules. Components import styles as an object: import styles from './ChronicleIndex.module.css', then reference classes as styles.container, styles.heading etc. Vite compiles these to unique class names at build time, eliminating namespace collision risk entirely. The styles/variables.css file provides shared CSS custom properties (--color-bg-primary, --color-accent, etc.) imported globally. This is the most modern CSS architecture in the monorepo but is isolated to one app."
      },
      {
        "name": "centralized-design-system-directory",
        "description": "coherence-engine has a styles/ directory containing 17 CSS files organized as a mini design system: theme.css (tokens), base.css (reset), utilities.css (helpers), and 14 reusable component style files (button.css, form.css, badge.css, modal.css, card.css, etc.). These shared styles are imported via a single entry point (styles/index.css) while component-specific CSS still lives co-located with components.",
        "file_count": 45,
        "files": [
          "apps/coherence-engine/webui/src/styles/index.css",
          "apps/coherence-engine/webui/src/styles/theme.css",
          "apps/coherence-engine/webui/src/styles/base.css",
          "apps/coherence-engine/webui/src/styles/utilities.css",
          "apps/coherence-engine/webui/src/styles/components/button.css",
          "apps/coherence-engine/webui/src/styles/components/form.css",
          "apps/coherence-engine/webui/src/styles/components/badge.css",
          "apps/coherence-engine/webui/src/styles/components/modal.css",
          "apps/coherence-engine/webui/src/components/generators/tabs/CreationTab.jsx"
        ],
        "sample_file": "apps/coherence-engine/webui/src/styles/components/button.css",
        "code_excerpts": [
          {
            "file": "apps/coherence-engine/webui/src/styles/components/button.css",
            "start_line": 1,
            "end_line": 10,
            "snippet": "/* Reusable button styles — used across all coherence-engine components */\n.btn { /* base */ }\n.btn-primary { ... }\n.btn-secondary { ... }\n.btn-danger { ... }\n.btn-icon { ... }\n.btn-add { ... }\n.btn-close { ... }\n.btn-tab { ... }\n.btn-tab-active { ... }"
          }
        ],
        "implementation_details": "coherence-engine's styles/ directory is a locally-scoped design system with 14 reusable component style files (button, form, badge, modal, card, section, toggle, dropdown, etc.). The entry point styles/index.css imports all shared styles. Individual components import their own CSS on top. This provides a consistent visual language within coherence-engine but the styles are NOT shared with other apps. Other apps (illuminator, archivist) independently reinvent .btn, .badge, .form-group equivalents in their component CSS files. This is the root of cross-app visual inconsistency."
      }
    ],
    "analysis": "The CSS architecture drift creates two problems: (1) within-app scoping risk (co-located CSS has no compile-time scoping, relying on manual prefix conventions that are applied inconsistently), and (2) cross-app visual inconsistency (each app independently defines button, badge, form, and modal styles with no shared design tokens). coherence-engine's centralized design system is the most mature approach but is siloed. chronicler's CSS Modules are the most technically sound for scoping but are also isolated. The shared-components package provides some cross-app components (ModalShell, FormGroup, EmptyState) but their CSS is in yet another format (co-located .css in packages/shared-components/src/styles/). Convergence would require choosing: CSS Modules everywhere (safest, most modern), or extending the shared-components design system to cover all apps.",
    "recommendation": "The pragmatic convergence path: (1) Extract coherence-engine's styles/theme.css and base.css into shared-components as the shared design token layer. (2) Adopt CSS Modules as the canonical scoping strategy for new components (chronicler's pattern). (3) Add a stylelint rule enforcing .module.css for new files. Migrating existing co-located CSS is low-priority since the manual prefix convention works adequately for existing code.",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "vite-config-language-mismatch",
    "name": "Vite Config File Extension Inconsistency",
    "type": "structural",
    "description": "Vite configuration files use two different extensions: vite.config.ts (TypeScript, 2 apps) vs vite.config.js (JavaScript, 7 apps). The TypeScript configs import types (type PluginOption) and use path from 'node:path', while JS configs use resolve from 'node:path'. Both sets share the same federation config import (config/federation.js) and follow the same structural pattern.",
    "impact": "LOW",
    "total_files": 9,
    "variants": [
      {
        "name": "vite-config-typescript",
        "description": "archivist and chronicler use vite.config.ts with TypeScript-specific imports (import { defineConfig, type PluginOption } from 'vite') and type annotations on the federation plugin cast ((federation({...})) as PluginOption).",
        "file_count": 2,
        "files": [
          "apps/archivist/webui/vite.config.ts",
          "apps/chronicler/webui/vite.config.ts"
        ],
        "sample_file": "apps/archivist/webui/vite.config.ts",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/vite.config.ts",
            "start_line": 1,
            "end_line": 10,
            "snippet": "import { defineConfig, type PluginOption } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { federation } from '@module-federation/vite';\nimport path from 'node:path';\nimport { federationOnWarn, sharedDeps } from '../../../config/federation.js';\n\n// Archivist is an MFE remote for The Canonry shell.\n// To use Archivist, run The Canonry (apps/canonry/webui).\n\nexport default defineConfig({"
          }
        ],
        "implementation_details": "The two TypeScript vite configs correspond exactly to the two apps that have full TypeScript adoption (archivist, chronicler). They cast the federation plugin result as PluginOption to satisfy type checking. Otherwise structurally identical to the JS configs."
      },
      {
        "name": "vite-config-javascript",
        "description": "7 apps use vite.config.js: canonry, coherence-engine, cosmographer, illuminator, lore-weave, name-forge, viewer. These omit type imports and the PluginOption cast.",
        "file_count": 7,
        "files": [
          "apps/canonry/webui/vite.config.js",
          "apps/coherence-engine/webui/vite.config.js",
          "apps/cosmographer/webui/vite.config.js",
          "apps/illuminator/webui/vite.config.js",
          "apps/lore-weave/webui/vite.config.js",
          "apps/name-forge/webui/vite.config.js",
          "apps/viewer/webui/vite.config.js"
        ],
        "sample_file": "apps/canonry/webui/vite.config.js",
        "code_excerpts": [
          {
            "file": "apps/canonry/webui/vite.config.js",
            "start_line": 1,
            "end_line": 5,
            "snippet": "import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { federation } from '@module-federation/vite';\nimport { federationOnWarn, sharedDeps } from '../../../config/federation.js';"
          }
        ],
        "implementation_details": "Functionally identical to the TypeScript variants but without type imports or casts. The JS configs are slightly simpler (no 'as PluginOption' cast needed) but miss type-checking for configuration shape. This is a downstream effect of the broader TS/JS migration drift — apps without tsconfig.json naturally use .js for their vite config too."
      }
    ],
    "analysis": "This drift is a minor symptom of the larger TypeScript migration state. The vite configs are functionally identical regardless of extension — they import the same federation config, use the same plugin setup, and expose the same federation remotes. The TypeScript versions provide slightly better IDE autocomplete for the config shape but this is a marginal benefit for a file that changes rarely. This would resolve naturally as part of a broader TypeScript migration.",
    "recommendation": "Low priority. Will resolve naturally when apps adopt TypeScript. Not worth addressing independently.",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "vite-path-alias-configuration",
    "name": "Vite Path Alias Configuration Patterns",
    "type": "structural",
    "description": "Apps use four different Vite resolve.alias patterns to reference shared code: @lib pointing to ../lib (3 apps), @the-canonry/* pointing to package source (2 apps), @name-forge pointing to another app's source (1 app), @chronicler pointing to another app's source (1 app), and no aliases at all (3 apps). This creates inconsistent import ergonomics and hidden cross-app coupling.",
    "impact": "MEDIUM",
    "total_files": 9,
    "variants": [
      {
        "name": "lib-alias-to-sibling-directory",
        "description": "lore-weave, name-forge, and illuminator configure @lib as an alias to their sibling ../lib directory. This lets webui code import from the core library using @lib/module instead of relative paths like ../../lib/module.",
        "file_count": 3,
        "files": [
          "apps/lore-weave/webui/vite.config.js",
          "apps/name-forge/webui/vite.config.js",
          "apps/illuminator/webui/vite.config.js"
        ],
        "sample_file": "apps/name-forge/webui/vite.config.js",
        "code_excerpts": [
          {
            "file": "apps/name-forge/webui/vite.config.js",
            "start_line": 25,
            "end_line": 29,
            "snippet": "resolve: {\n  alias: {\n    '@lib': resolve(__dirname, '../lib'),\n  },\n},"
          }
        ],
        "implementation_details": "The @lib alias simplifies imports from the core library when the webui is deeply nested. Usage: import { generate } from '@lib/generate.js'. However, this alias is only configured in Vite — TypeScript apps also need a paths entry in tsconfig.json, and not all apps have both. The alias means @lib refers to a different actual directory in each app (lore-weave's lib/ vs name-forge's lib/ vs illuminator's lib/), which can be confusing in a monorepo context."
      },
      {
        "name": "package-source-alias",
        "description": "archivist and chronicler alias @the-canonry/world-store to the package's TypeScript source (../../../packages/world-store/src/index.ts) rather than its built output. This bypasses the package's build step and imports source directly.",
        "file_count": 2,
        "files": [
          "apps/archivist/webui/vite.config.ts",
          "apps/chronicler/webui/vite.config.ts"
        ],
        "sample_file": "apps/archivist/webui/vite.config.ts",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/vite.config.ts",
            "start_line": 23,
            "end_line": 30,
            "snippet": "resolve: {\n  alias: {\n    '@the-canonry/world-store': path.resolve(\n      __dirname,\n      '../../../packages/world-store/src/index.ts'\n    ),\n  },\n},"
          }
        ],
        "implementation_details": "By aliasing to the package's TypeScript source rather than its compiled output, these apps get live type checking and avoid needing to rebuild the package during development. However, this creates an implicit dependency on the package's internal file structure — if world-store reorganizes its src/ directory, these aliases break. Other apps that consume world-store (via module federation's shared config) rely on the compiled package instead."
      },
      {
        "name": "cross-app-source-alias",
        "description": "viewer aliases @chronicler to apps/chronicler/webui/src, importing directly from another app's source code. cosmographer aliases @name-forge to apps/name-forge/lib, importing from another app's library code. These create tight coupling between apps that bypasses the module federation boundary.",
        "file_count": 2,
        "files": [
          "apps/viewer/webui/vite.config.js",
          "apps/cosmographer/webui/vite.config.js"
        ],
        "sample_file": "apps/viewer/webui/vite.config.js",
        "code_excerpts": [
          {
            "file": "apps/viewer/webui/vite.config.js",
            "start_line": 7,
            "end_line": 10,
            "snippet": "resolve: {\n  alias: {\n    \"@chronicler\": resolve(__dirname, \"../../chronicler/webui/src\"),\n  },\n},"
          }
        ],
        "implementation_details": "These aliases create direct source-level coupling between apps, bypassing the Module Federation boundary that normally isolates MFEs. viewer imports ChroniclerRemote.tsx directly from chronicler's source rather than loading it as a federated remote. cosmographer imports name-forge's library functions directly. This means these apps cannot be deployed independently — they require the other app's source to be present at build time. This is the most architecturally problematic alias pattern."
      },
      {
        "name": "no-aliases",
        "description": "canonry, coherence-engine, and (partially) cosmographer have no resolve.alias configuration, using only bare package names or relative imports.",
        "file_count": 3,
        "files": [
          "apps/canonry/webui/vite.config.js",
          "apps/coherence-engine/webui/vite.config.js"
        ],
        "sample_file": "apps/canonry/webui/vite.config.js",
        "code_excerpts": [
          {
            "file": "apps/canonry/webui/vite.config.js",
            "start_line": 1,
            "end_line": 5,
            "snippet": "import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\nimport { federation } from '@module-federation/vite';\nimport { federationOnWarn, sharedDeps } from '../../../config/federation.js';"
          }
        ],
        "implementation_details": "These apps rely entirely on standard module resolution (node_modules, relative paths, or module federation remotes). This is the simplest approach — no alias configuration to maintain, no hidden path mappings. canonry as the shell/host loads all MFE remotes via module federation, so it doesn't need source-level aliases."
      }
    ],
    "analysis": "The four alias patterns reflect different development ergonomics preferences and different levels of inter-app coupling. The @lib alias (3 apps) is a reasonable convenience for apps with a lib/webui split. The @the-canonry/world-store source alias (2 apps) optimizes for development speed but creates fragile source-path dependencies. The cross-app source aliases (viewer → chronicler, cosmographer → name-forge) are the most concerning because they break the MFE isolation boundary — these apps cannot be built independently. The 'no alias' pattern (3 apps) is the simplest and most portable. Convergence means standardizing on one alias convention and eliminating cross-app source coupling.",
    "recommendation": "Eliminate cross-app source aliases first: viewer should load chronicler via module federation (or the chronicler components it needs should be extracted to a shared package). cosmographer should consume name-forge as a package dependency rather than aliasing to its source. For the @lib alias, standardize: either all lib-having apps use it or none do. The @the-canonry/world-store source alias is acceptable during development but should be documented as a dev-only optimization.",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "import-extension-conventions",
    "name": "Import Path Extension Conventions",
    "type": "structural",
    "description": "TypeScript apps use two different conventions for local import extensions: archivist includes explicit .tsx/.ts extensions in import paths (import LoreSection from './LoreSection.tsx'), while chronicler, illuminator, and all JavaScript apps omit extensions (import ChroniclePanel from './ChroniclePanel'). This creates inconsistency in how files reference each other across the monorepo.",
    "impact": "LOW",
    "total_files": 65,
    "variants": [
      {
        "name": "explicit-tsx-ts-extensions",
        "description": "archivist consistently includes .tsx and .ts extensions in local imports. Every component and utility import specifies the full file extension.",
        "file_count": 21,
        "files": [
          "apps/archivist/webui/src/components/EntityDetail.tsx",
          "apps/archivist/webui/src/components/GraphView.tsx",
          "apps/archivist/webui/src/ArchivistRemote.tsx"
        ],
        "sample_file": "apps/archivist/webui/src/components/EntityDetail.tsx",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/src/components/EntityDetail.tsx",
            "start_line": 10,
            "end_line": 21,
            "snippet": "import type {\n  WorldState,\n  LoreData,\n} from \"../types/world.ts\";\nimport {\n  getEntityById,\n  getRelatedEntities,\n} from \"../utils/dataTransform.ts\";\nimport LoreSection from \"./LoreSection.tsx\";\nimport RelationshipStoryModal from \"./RelationshipStoryModal.tsx\";\nimport ChainLinkSection from \"./ChainLinkSection.tsx\";\nimport DiscoveryStory from \"./DiscoveryStory.tsx\";"
          }
        ],
        "implementation_details": "Archivist uses explicit .tsx/.ts extensions on every local import. This matches Node.js ESM resolution rules (which require extensions) and is forward-compatible with TypeScript's 'nodenext' module resolution. However, it's unique in this monorepo — no other app follows this convention. It creates visual noise in import statements and means copying imports between apps requires adding or removing extensions."
      },
      {
        "name": "extensionless-imports",
        "description": "All other apps (chronicler, illuminator, coherence-engine, canonry, etc.) omit file extensions in local imports, relying on Vite's module resolution to find the correct file.",
        "file_count": 803,
        "files": [
          "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
          "apps/coherence-engine/webui/src/components/actions/index.js",
          "apps/canonry/webui/src/App.jsx",
          "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts"
        ],
        "sample_file": "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
        "code_excerpts": [
          {
            "file": "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
            "start_line": 9,
            "end_line": 14,
            "snippet": "import { useCallback } from \"react\";\nimport type { ChronicleGenerationContext, ChronicleSampling } from \"../lib/chronicleTypes\";\nimport type { EnrichmentType, ChronicleStep } from \"../lib/enrichmentTypes\";\nimport { getEnqueue } from \"../lib/db/enrichmentQueueBridge\";\nimport { useChronicleStore } from \"../lib/db/chronicleStore\";\nimport type { ChronicleRecord } from \"../lib/db/chronicleRepository\";"
          }
        ],
        "implementation_details": "The vast majority of imports across all apps omit file extensions. Vite resolves these by trying .ts, .tsx, .js, .jsx in order. This is the conventional approach in Vite/webpack projects and is consistent with the broader React ecosystem. The tradeoff is that it relies on bundler-specific resolution and wouldn't work under strict Node.js ESM rules."
      }
    ],
    "analysis": "This is a minor but noticeable inconsistency. archivist's explicit extensions are technically more correct for ESM compatibility, but they're unique in this monorepo and create friction when developers copy-paste imports between apps. The extensionless convention is overwhelmingly dominant (803 of 824 files). This drift likely occurred because archivist was scaffolded with a different template or by a developer who preferred explicit extensions. It's a cosmetic issue that doesn't affect runtime behavior (Vite handles both correctly) but contributes to visual inconsistency across apps.",
    "recommendation": "Low priority. If addressed, standardize on extensionless imports (the dominant convention) and remove .tsx/.ts extensions from archivist's imports. This is a quick find-and-replace task but shouldn't block other work.",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "test-infrastructure-coverage",
    "name": "Test Infrastructure Absence in WebUI Apps",
    "type": "structural",
    "description": "Only 2 of 9 apps (lore-weave, name-forge) have vitest configuration files, and even those have zero test files (.test.* or .spec.*). No webui app has any test infrastructure. The monorepo has 824 source files and 0 test files. This is a structural gap rather than drift between variants, but it means there is no testable pattern to standardize on.",
    "impact": "LOW",
    "total_files": 0,
    "variants": [
      {
        "name": "vitest-configured-no-tests",
        "description": "lore-weave and name-forge have vitest.config.ts files and vitest in devDependencies, indicating test infrastructure was set up but no test files exist. These are the core library apps with TypeScript code that would most benefit from testing.",
        "file_count": 2,
        "files": [
          "apps/lore-weave/vitest.config.ts",
          "apps/name-forge/vitest.config.ts"
        ],
        "sample_file": "apps/lore-weave/vitest.config.ts",
        "code_excerpts": [
          {
            "file": "apps/lore-weave/vitest.config.ts",
            "start_line": 1,
            "end_line": 1,
            "snippet": "// vitest.config.ts exists with coverage configuration"
          }
        ],
        "implementation_details": "Both apps include @vitest/coverage-v8 and @vitest/ui in devDependencies and have vitest.config.ts files. package.json has 'test' scripts configured. But find across the entire monorepo returns 0 .test.* or .spec.* files. The test infrastructure is scaffolded but unused."
      },
      {
        "name": "no-test-infrastructure",
        "description": "7 apps (archivist, canonry, chronicler, coherence-engine, cosmographer, illuminator, viewer) have no vitest configuration, no test runner, and no test files. Their webui directories contain only source code and CSS.",
        "file_count": 7,
        "files": [
          "apps/archivist/webui/package.json",
          "apps/canonry/webui/package.json",
          "apps/coherence-engine/webui/package.json"
        ],
        "sample_file": "apps/archivist/webui/package.json",
        "code_excerpts": [],
        "implementation_details": "No test-related devDependencies (vitest, jest, testing-library, etc.) in any webui app package.json. No __tests__ directories, no .test.* files, no .spec.* files. The monorepo's root package.json has a 'test' script that runs 'turbo run test', but this finds nothing to run in most apps."
      }
    ],
    "analysis": "The complete absence of tests is notable but is less 'drift' (inconsistency between implementations) and more a 'gap' (missing infrastructure entirely). The two library-focused apps set up vitest but never wrote tests, suggesting testing was intended but deprioritized. For a monorepo with 824 source files, zero tests means all validation is manual. This is flagged as structural context rather than a high-priority drift finding — the user almost certainly knows about this already.",
    "recommendation": "If testing becomes a priority, start with the core libraries (lore-weave/lib, name-forge/lib) which already have vitest configured. For webui apps, add @testing-library/react and vitest to the shared config and create a standard test file convention (ComponentName.test.tsx co-located with the component).",
    "evidence_quality": "high",
    "status": "pending"
  },
  {
    "id": "webui-src-directory-structure",
    "name": "WebUI Source Directory Organization",
    "type": "structural",
    "description": "The webui/src/ directories across MFE apps use different subdirectory conventions for organizing non-component code. Some use hooks/, some use lib/, some use stores/, some use storage/, some use utils/, some use types/, some use workers/, some use styles/ — with no consistent convention for which directories exist or what they contain. This means developers must learn a different organizational model for each app.",
    "impact": "MEDIUM",
    "total_files": 824,
    "variants": [
      {
        "name": "hooks-lib-types-pattern",
        "description": "illuminator and chronicler organize non-component code into hooks/ (React hooks), lib/ (business logic, types, utilities), and optionally types/ and workers/. illuminator has hooks/ (32 files), lib/ (with db/, chronicle/, preprint/ subdirectories), and workers/. chronicler has hooks/ (2 files), lib/ (wikiBuilder, chronicleStorage), types/, and styles/.",
        "file_count": 350,
        "files": [
          "apps/illuminator/webui/src/hooks/",
          "apps/illuminator/webui/src/lib/",
          "apps/illuminator/webui/src/workers/",
          "apps/chronicler/webui/src/hooks/",
          "apps/chronicler/webui/src/lib/",
          "apps/chronicler/webui/src/types/",
          "apps/chronicler/webui/src/styles/"
        ],
        "sample_file": "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
        "code_excerpts": [
          {
            "file": "apps/illuminator/webui/src/hooks/useChronicleActions.ts",
            "start_line": 1,
            "end_line": 7,
            "snippet": "/**\n * useChronicleActions - Thin hook for enqueue-dependent chronicle actions.\n *\n * Receives onEnqueue from props (the enrichment queue system) and provides\n * action functions that read chronicle data from the Zustand store imperatively.\n * This separation keeps the store free of prop-dependent closures.\n */"
          }
        ],
        "implementation_details": "The hooks/lib split provides clear separation between React-specific code (hooks with useState/useCallback) and pure business logic (lib with classes, utilities, data access). illuminator is the most developed example: hooks/ contains 32 custom hooks, lib/db/ contains Dexie database and Zustand stores, lib/chronicle/ contains chronicle generation logic, workers/ contains web worker tasks. chronicler follows the same pattern at smaller scale."
      },
      {
        "name": "stores-storage-pattern",
        "description": "canonry splits state management into two sibling directories: stores/ (Zustand reactive stores) and storage/ (IndexedDB data access). It also has lib/ for utilities and aws/ for deployment.",
        "file_count": 47,
        "files": [
          "apps/canonry/webui/src/stores/useCanonryAwsStore.js",
          "apps/canonry/webui/src/stores/useCanonryUiStore.js",
          "apps/canonry/webui/src/storage/worldStore.js",
          "apps/canonry/webui/src/storage/runStore.js",
          "apps/canonry/webui/src/lib/"
        ],
        "sample_file": "apps/canonry/webui/src/stores/useCanonryUiStore.js",
        "code_excerpts": [
          {
            "file": "apps/canonry/webui/src/stores/useCanonryUiStore.js",
            "start_line": 1,
            "end_line": 5,
            "snippet": "import { create } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\n\nconst initial = { /* ... */ };\n\nexport const useCanonryUiStore = create("
          }
        ],
        "implementation_details": "canonry's stores/ directory contains Zustand stores (reactive, synchronous UI state), while storage/ contains IndexedDB access functions (async, persistent domain data). This separation makes sense conceptually but the naming is confusing — 'stores' and 'storage' are near-synonyms. No other app uses this dual-directory pattern. canonry also has lib/ (utilities), aws/ (deployment config), and remotes/ (MFE loading), adding more unique directories."
      },
      {
        "name": "minimal-flat-pattern",
        "description": "archivist, cosmographer, lore-weave, and name-forge have minimal subdirectory structure. archivist has types/ and utils/ alongside components/. cosmographer has just components/. lore-weave has components/ and hooks/. name-forge has components/ and lib/.",
        "file_count": 150,
        "files": [
          "apps/archivist/webui/src/types/",
          "apps/archivist/webui/src/utils/",
          "apps/archivist/webui/src/components/",
          "apps/lore-weave/webui/src/components/",
          "apps/lore-weave/webui/src/hooks/"
        ],
        "sample_file": "apps/archivist/webui/src/ArchivistRemote.tsx",
        "code_excerpts": [
          {
            "file": "apps/archivist/webui/src/ArchivistRemote.tsx",
            "start_line": 1,
            "end_line": 6,
            "snippet": "import React, { useEffect, useMemo, useState } from \"react\";\nimport \"./index.css\";\nimport WorldExplorer from \"./components/WorldExplorer.tsx\";\nimport type { WorldState } from \"./types/world.ts\";\nimport { validateWorldData } from \"./utils/schemaValidation.ts\";\nimport { buildWorldStateForSlot } from \"@the-canonry/world-store\";"
          }
        ],
        "implementation_details": "These apps keep it simple: components/ for React components, and one or two utility directories. archivist uses types/ (TypeScript type definitions) and utils/ (data transformation utilities). The naming is conventional and easily understood. This pattern works well for smaller apps but provides less guidance for where new non-component code should go."
      },
      {
        "name": "styles-utils-only-pattern",
        "description": "coherence-engine has a unique structure: components/ (with deep feature nesting), styles/ (centralized design system), and utils/ (shared utilities). No hooks/, no lib/, no types/.",
        "file_count": 115,
        "files": [
          "apps/coherence-engine/webui/src/components/",
          "apps/coherence-engine/webui/src/styles/",
          "apps/coherence-engine/webui/src/utils/"
        ],
        "sample_file": "apps/coherence-engine/webui/src/CoherenceEngineRemote.jsx",
        "code_excerpts": [
          {
            "file": "apps/coherence-engine/webui/src/CoherenceEngineRemote.jsx",
            "start_line": 1,
            "end_line": 5,
            "snippet": "import React, { useMemo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"@the-canonry/shared-components/styles\";\nimport { ErasEditor } from \"./components/eras\";\n"
          }
        ],
        "implementation_details": "coherence-engine puts all React logic in deeply-nested feature directories under components/, shared CSS in styles/, and JavaScript utilities in utils/. It has no hooks/ directory — hooks are inline within components or don't exist (this app uses prop drilling). It has no types/ directory because it's pure JavaScript. The deep nesting under components/ (28 directories) is unusual and specific to coherence-engine's feature-module architecture."
      }
    ],
    "analysis": "Each app has evolved its own directory structure organically based on its complexity and development history. The core issue isn't that any single pattern is wrong — they're all reasonable for their app's size and needs — but that there's no shared convention. A developer working across apps must mentally switch between 'hooks/ + lib/' (illuminator), 'stores/ + storage/' (canonry), 'types/ + utils/' (archivist), and 'styles/ + utils/' (coherence-engine) organizational models. The nomenclature is also inconsistent: utility functions live in utils/ (archivist, coherence-engine), lib/ (canonry, name-forge, chronicler), or are spread across hooks/ and components/ (lore-weave). Convergence means establishing a reference directory structure for new apps and gradually aligning existing apps during major refactors.",
    "recommendation": "Define a canonical webui/src/ structure in a pattern doc: components/ (React components), hooks/ (React hooks), lib/ (business logic, data access, non-React utilities), types/ (TypeScript type definitions), styles/ (shared/global CSS). This aligns with the illuminator/chronicler pattern which is the most complete. Rename canonry's stores/ and storage/ to align (Zustand stores could live in lib/stores/). Don't force-migrate immediately — adopt for new code and align during feature work.",
    "evidence_quality": "high",
    "status": "pending"
  }
]
